"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[32929],{15868:(e,n,t)=>{t.d(n,{A:()=>o});var i=t(65162),s=t(62540);function o(e){let{header:n,inline:t,updated:o,version:r}=e;return(0,s.jsx)(i.A,{text:`v${r}`,variant:o?"success":"info",className:n?"absolute right-0 top-1.5":t?"inline-block ml-1":"ml-2"})}},37940:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"proto/wasm-plugin","title":"WASM plugin","description":"If you want more control over how your tool works, a WASM plugin is the way to go.","source":"@site/docs/proto/wasm-plugin.mdx","sourceDirName":"proto","slug":"/proto/wasm-plugin","permalink":"/docs/proto/wasm-plugin","draft":false,"unlisted":false,"editUrl":"https://github.com/moonrepo/moon/tree/master/website/docs/proto/wasm-plugin.mdx","tags":[],"version":"current","frontMatter":{"title":"WASM plugin","sidebar_label":"WASM","toc_max_heading_level":5},"sidebar":"proto","previous":{"title":"Plugins","permalink":"/docs/proto/plugins"},"next":{"title":"Non-WASM","permalink":"/docs/proto/non-wasm-plugin"}}');var s=t(62540),o=t(43023),r=t(15868);const l={title:"WASM plugin",sidebar_label:"WASM",toc_max_heading_level:5},a=void 0,c={},d=[{value:"Concepts",id:"concepts",level:2},{value:"Tool context",id:"tool-context",level:3},{value:"Tool configuration",id:"tool-configuration",level:3},{value:"Creating a plugin",id:"creating-a-plugin",level:2},{value:"Implementing plugin functions",id:"implementing-plugin-functions",level:2},{value:"Registering metadata",id:"registering-metadata",level:3},{value:"Configuration schema<VersionLabel></VersionLabel>",id:"configuration-schema",level:4},{value:"Downloading pre-builts",id:"downloading-pre-builts",level:3},{value:"Unpacking an archive",id:"unpacking-an-archive",level:4},{value:"Locating executables",id:"locating-executables",level:3},{value:"Loading and resolving versions",id:"loading-and-resolving-versions",level:3},{value:"Detecting versions",id:"detecting-versions",level:3},{value:"Testing",id:"testing",level:2},{value:"Unit tests",id:"unit-tests",level:3},{value:"Testing plugin functions",id:"testing-plugin-functions",level:4},{value:"Generating cases from macros",id:"generating-cases-from-macros",level:4},{value:"Building and publishing",id:"building-and-publishing",level:2},{value:"Resources",id:"resources",level:2}];function u(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"If you want more control over how your tool works, a WASM plugin is the way to go."}),"\n",(0,s.jsx)(n.admonition,{type:"success",children:(0,s.jsxs)(n.p,{children:["Refer to our ",(0,s.jsx)(n.a,{href:"../guides/wasm-plugins",children:"official WASM guide"})," for more information on how our WASM\nplugins work, critical concepts to know, and more. Once you have a good understanding, you may\ncontinue this proto specific guide."]})}),"\n",(0,s.jsx)(n.h2,{id:"concepts",children:"Concepts"}),"\n",(0,s.jsxs)(n.p,{children:["The following concepts are unique to proto, but be sure to also read about the general concepts in\nour ",(0,s.jsx)(n.a,{href:"../guides/wasm-plugins#concepts",children:"WASM plugins guide"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"tool-context",children:"Tool context"}),"\n",(0,s.jsxs)(n.p,{children:["For plugin functions, we provide what we call the tool context, which is information that is\nconstantly changing depending on the current step or state of proto's execution. The context cannot\nbe accessed with a stand-alone function, and is instead passed as a ",(0,s.jsx)(n.code,{children:"context"})," field in the input of\nmany plugin functions."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[plugin_fn]\npub fn download_prebuilt(Json(input): Json<DownloadPrebuiltInput>) -> FnResult<Json<DownloadPrebuiltOutput>> {\n    let version = input.context.version;\n    // ...\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following fields are available on the\n",(0,s.jsx)(n.a,{href:"https://docs.rs/proto_pdk/latest/proto_pdk/struct.ToolContext.html",children:"context object"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"proto_version"})," - The version of proto executing the plugin. Note that this version may be for the\n",(0,s.jsxs)(n.a,{href:"https://crates.io/crates/proto_core",children:[(0,s.jsx)(n.code,{children:"proto_core"})," crate"]}),", and not the CLI. Patch numbers will\ndrift, but major and minor numbers should be in sync."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"temp_dir"})," - A virtual path to a temporary directory unique to this tool.","\n",(0,s.jsx)(r.A,{version:"0.45.0"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tool_dir"})," - A virtual path to the tool's directory for the current version."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"version"}),' - The current version or alias. If not resolved, will be "latest".']}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"caution",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"version"}),' field is either a fully-qualified version (1.2.3), an alias ("latest", "stable"), or\ncanary ("canary"). Be sure to account for all these variations when implementing plugin functions!']})}),"\n",(0,s.jsx)(n.h3,{id:"tool-configuration",children:"Tool configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Users can configure tools through the ",(0,s.jsx)(n.a,{href:"./config#tools",children:(0,s.jsx)(n.code,{children:"[tools.*]"})})," section of their ",(0,s.jsx)(n.code,{children:".prototools"}),",\nwhich can then be accessed within the WASM plugin using the\n",(0,s.jsx)(n.a,{href:"https://docs.rs/proto_pdk/latest/proto_pdk/fn.get_tool_config.html",children:(0,s.jsx)(n.code,{children:"get_tool_config"})})," function."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"let config = get_tool_config::<NodeConfig>()?;\nconfig.bundled_npm;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This function requires a struct to deserialize into. It should implement ",(0,s.jsx)(n.code,{children:"Default"}),", enable serde\ndefaults, and map keys from ",(0,s.jsx)(n.code,{children:"kebab-case"}),". If you want to error on unknown settings, also enable\n",(0,s.jsx)(n.code,{children:"deny_unknown_fields"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[derive(Debug, Default, serde::Deserialize)]\n#[serde(default, deny_unknown_fields, rename_all = "kebab-case")]\nstruct NodeConfig {\n    pub bundled_npm: bool,\n    pub intercept_globals: bool,\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creating-a-plugin",children:"Creating a plugin"}),"\n",(0,s.jsx)(n.admonition,{type:"success",children:(0,s.jsxs)(n.p,{children:["Refer to our ",(0,s.jsx)(n.a,{href:"../guides/wasm-plugins#creating-a-plugin",children:"official WASM guide"})," for steps on how to\ncreate a Rust based plugin."]})}),"\n",(0,s.jsx)(n.h2,{id:"implementing-plugin-functions",children:"Implementing plugin functions"}),"\n",(0,s.jsxs)(n.p,{children:["Plugins are powered by a set of functions that are called from the host, and are annotated with\n",(0,s.jsx)(n.code,{children:"#[plugin_fn]"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"registering-metadata",children:"Registering metadata"}),"\n",(0,s.jsxs)(n.p,{children:["The first step in a plugin's life-cycle is to register metadata about the plugin with the\n",(0,s.jsx)(n.code,{children:"register_tool"})," function. This function is called immediately after a plugin is loaded at runtime,\nand must return a human-readable name and plugin type."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn register_tool(_: ()) -> FnResult<Json<RegisterToolOutput>> {\n    Ok(Json(RegisterToolOutput {\n        name: "Node.js".into(),\n        type_of: PluginType::Language,\n        minimum_proto_version: Some(Version::new(0, 42, 0)),\n        plugin_version: Version::parse(env!("CARGO_PKG_VERSION")).ok(),\n        ..RegisterToolOutput::default()\n    }))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This function also receives the plugin ID as input, allowing for conditional logic based on the ID.\nThe ID is the ",(0,s.jsx)(n.a,{href:"./plugins#enabling-plugins",children:"key the plugin was configured with"}),", and what is passed\nto ",(0,s.jsx)(n.code,{children:"proto"})," commands (e.g. ",(0,s.jsx)(n.code,{children:"proto install <id>"}),")."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[plugin_fn]\npub fn register_tool(Json(input): Json<RegisterToolInput>) -> FnResult<Json<RegisterToolOutput>> {\n  input.id\n  // ...\n}\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"configuration-schema",children:["Configuration schema",(0,s.jsx)(r.A,{version:"0.40.0"})]}),"\n",(0,s.jsxs)(n.p,{children:["If you are using ",(0,s.jsx)(n.a,{href:"#tool-configuration",children:"tool configuration"}),", you can register the shape of the\nconfiguration using the ",(0,s.jsx)(n.a,{href:"https://crates.io/crates/schematic",children:(0,s.jsx)(n.code,{children:"schematic"})})," crate. This shape will be\nused to generate outputs such as JSON schemas, or TypeScript types."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[plugin_fn]\npub fn register_tool(_: ()) -> FnResult<Json<RegisterToolOutput>> {\n    Ok(Json(RegisterToolOutput {\n        // ...\n        config_schema: Some(schematic::SchemaBuilder::generate::<NodeConfig>()),\n    }))\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Schematic is a heavy library, so we suggest adding the dependency like so:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[dependencies]\nschematic = { version = "*", default-features = false, features = ["schema"] }\n'})}),"\n",(0,s.jsx)(n.h3,{id:"downloading-pre-builts",children:"Downloading pre-builts"}),"\n",(0,s.jsxs)(n.p,{children:["Our plugin layer ",(0,s.jsx)(n.em,{children:"only"})," supports downloading pre-built tools, typically as an archive, and does\n",(0,s.jsx)(n.em,{children:"not"})," support building from source. The ",(0,s.jsx)(n.code,{children:"download_prebuilt"})," function ",(0,s.jsx)(n.em,{children:"must"})," be defined, whichs\nconfigures how the tool should be downloaded and installed."]}),"\n",(0,s.jsx)(n.p,{children:"The following fields are available:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"archive_prefix"})," - If the tool is distributed as an archive (zip, tar, etc), this is the name of\nthe direct folder within the archive that contains the tool, and will be removed when unpacking\nthe archive. If there is no prefix folder within the archive, this setting can be omitted."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"download_url"})," (required) - A secure URL to download the tool/archive."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"download_name"})," - File name of the archive to download. If not provided, will attempt to extract\nit from the URL."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"checksum"})," - The checksum hash itself. Will be used if no other option was provided.","\n",(0,s.jsx)(r.A,{version:"0.47.0"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"checksum_url"})," - A secure URL to download the checksum file for verification. If the tool does not\nsupport checksum verification, this setting can be omitted."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"checksum_public_key"})," - Public key used for verifying checksums. Only used for ",(0,s.jsx)(n.code,{children:".minisig"})," files."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn download_prebuilt(Json(input): Json<DownloadPrebuiltInput>) -> FnResult<Json<DownloadPrebuiltOutput>> {\n     let env = get_host_environment()?;\n\n    check_supported_os_and_arch(\n        NAME,\n        &env,\n        permutations! [\n            HostOS::Linux => [HostArch::X64, HostArch::Arm64, HostArch::Arm, HostArch::Powerpc64, HostArch::S390x],\n            HostOS::MacOS => [HostArch::X64, HostArch::Arm64],\n            HostOS::Windows => [HostArch::X64, HostArch::X86, HostArch::Arm64],\n        ],\n    )?;\n\n    let version = input.context.version;\n    let arch = env.arch;\n    let os = env.os;\n\n    let prefix = match os {\n        HostOS::Linux => format!("node-v{version}-linux-{arch}"),\n        HostOS::MacOS => format!("node-v{version}-darwin-{arch}"),\n        HostOS::Windows => format!("node-v{version}-win-{arch}"),\n        other => {\n            return Err(PluginError::UnsupportedPlatform("Node.js".into(), other.into()))?;\n        }\n    };\n\n    let filename = if os == HostOS::Windows {\n        format!("{prefix}.zip")\n    } else {\n        format!("{prefix}.tar.xz")\n    };\n\n    Ok(Json(DownloadPrebuiltOutput {\n        archive_prefix: Some(prefix),\n        download_url: format!("https://nodejs.org/dist/v{version}/{filename}"),\n        download_name: Some(filename),\n        checksum_url: Some(format!("https://nodejs.org/dist/v{version}/SHASUMS256.txt")),\n        ..DownloadPrebuiltOutput::default()\n    }))\n}\n'})}),"\n",(0,s.jsx)(n.h4,{id:"unpacking-an-archive",children:"Unpacking an archive"}),"\n",(0,s.jsxs)(n.p,{children:["Our plugin layer will do its best to detect file extensions, unpack the downloaded file (if an\narchive), and install the tool to the correct directory. However, we're unable to account for ",(0,s.jsx)(n.em,{children:"all"}),"\nedge cases, so for situations where the install params above are not sufficient, you may define an\n",(0,s.jsx)(n.code,{children:"unpack_archive"})," function."]}),"\n",(0,s.jsx)(n.p,{children:"This function receives an input with the following fields:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"input_file"})," - Virtual path to the downloaded file. Maps to ",(0,s.jsx)(n.code,{children:"~/.proto/temp/<id>/<file>"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"output_dir"})," - Virtual directory to unpack the archive into, or copy the binary to. Maps to\n",(0,s.jsx)(n.code,{children:"~/.proto/tools/<id>/<version>"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:"#[plugin_fn]\npub fn unpack_archive(Json(input): Json<UnpackArchiveInput>) -> FnResult<()> {\n    untar(input.input_file, input.output_dir)?;\n    Ok(())\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"locating-executables",children:"Locating executables"}),"\n",(0,s.jsxs)(n.p,{children:["Even though a tool has been installed, we must inform proto of where to find executables. This can\nbe achieved with the required ",(0,s.jsx)(n.code,{children:"locate_executables"})," function. The ",(0,s.jsx)(n.code,{children:"exes"})," field defines the location\nof the executables, relative from the installation directory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn locate_executables(\n    Json(_): Json<LocateExecutablesInput>,\n) -> FnResult<Json<LocateExecutablesOutput>> {\n    let env = get_host_environment()?;\n\n    Ok(Json(LocateExecutablesOutput {\n        exes: HashMap::from_iter([\n            // Primary\n            (\n                "node".into(),\n                ExecutableConfig::new_primary(\n                    // Helper that chooses between distinct Unix or Windows values\n                    env.os.for_native("bin/node", "node.exe"),\n                    // Or the same value with optional Windows extension\n                    // env.os.get_file_name("node", "exe")\n                )\n            ),\n            // Secondary\n            (\n                "corepack".into(),\n                ExecutableConfig::new(env.os.for_native("bin/corepack", "corepack.exe"))\n            ),\n        ]),\n        ..LocateExecutablesOutput::default()\n    }))\n}\n'})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["The main executable of the tool must be marked as primary, either with\n",(0,s.jsx)(n.code,{children:"ExecutableConfig::new_primary"}),", or setting the ",(0,s.jsx)(n.code,{children:"ExecutableConfig.primary"})," field to true."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Furthermore, the ",(0,s.jsx)(n.code,{children:"locate_executables"})," function can define a list of lookups for the globals\ninstallation directory. proto will loop through each lookup, and return the first directory that\nexists on the current file system. proto will also expand environment variables in the format of\n",(0,s.jsx)(n.code,{children:"$VAR_NAME"}),". If a variable is not defined, or has an empty value, the lookup will be skipped. To\ndemonstrate this, we'll use ",(0,s.jsx)(n.a,{href:"https://deno.land/manual@v1.35.0/tools/script_installer",children:"Deno"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn locate_executables(\n    Json(_): Json<LocateExecutablesInput>,\n) -> FnResult<Json<LocateExecutablesOutput>> {\n    let env = get_host_environment()?;\n\n    Ok(Json(LocateExecutablesOutput {\n        globals_lookup_dirs: vec!["$DENO_INSTALL_ROOT/bin".into(), "$HOME/.deno/bin".into()],\n        // ...\n        ..LocateExecutablesOutput::default()\n    }))\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"loading-and-resolving-versions",children:"Loading and resolving versions"}),"\n",(0,s.jsxs)(n.p,{children:["Now that the tool can be downloaded and installed, we must configure how to resolve available\nversions to actually be installed. To provide a list of versions and language specific aliases, the\n",(0,s.jsx)(n.code,{children:"load_versions"})," function must be defined."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn load_versions(Json(_): Json<LoadVersionsInput>) -> FnResult<Json<LoadVersionsOutput>> {\n    let mut output = LoadVersionsOutput::default();\n    let response: Vec<NodeDistVersion> = fetch_json("https://nodejs.org/dist/index.json")?;\n\n    for (index, item) in response.iter().enumerate() {\n        let version = VersionSpec::parse(&item.version[1..])?; // Starts with v\n\n        if index == 0 {\n            output.latest = Some(version.clone());\n        }\n\n        output.versions.push(version);\n    }\n\n    Ok(Json(output))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Furthermore, we support an optional function named ",(0,s.jsx)(n.code,{children:"resolve_version"}),", that can be defined to\nintercept the version resolution process. This function receives an input with an initial candidate,\neither an alias or version, and can replace it with a new candidate. The candidate must be a valid\nalias or version as defined in ",(0,s.jsx)(n.code,{children:"load_versions"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn resolve_version(\n    Json(input): Json<ResolveVersionInput>,\n) -> FnResult<Json<ResolveVersionOutput>> {\n    let mut output = ResolveVersionOutput::default();\n\n    if let UnresolvedVersionSpec::Alias(alias) = input.initial {\n        let candidate = if alias == "node" {\n            "latest"\n        } else if alias == "lts-*" || alias == "lts/*" {\n            "stable"\n        } else if alias.starts_with("lts-") || alias.starts_with("lts/") {\n            &alias[4..]\n        } else {\n            return Ok(Json(output));\n        };\n\n        output.candidate = Some(UnresolvedVersionSpec::Alias(candidate.to_owned()));\n    }\n\n    Ok(Json(output))\n}\n\n'})}),"\n",(0,s.jsx)(n.h3,{id:"detecting-versions",children:"Detecting versions"}),"\n",(0,s.jsxs)(n.p,{children:["And lastly, we can configure how to ",(0,s.jsx)(n.a,{href:"./detection",children:"detect a version"})," contextually at runtime, using\nthe ",(0,s.jsx)(n.code,{children:"detect_version_files"})," function and optional ",(0,s.jsx)(n.code,{children:"parse_version_file"})," function. The\n",(0,s.jsx)(n.code,{children:"detect_version_files"})," function can return a list of files to locate within a directory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn detect_version_files(input: Json<DetectVersionInput>) -> FnResult<Json<DetectVersionOutput>> {\n    Ok(Json(DetectVersionOutput {\n        files: vec![\n            ".nvmrc".into(),\n            ".node-version".into(),\n            "package.json".into(),\n        ],\n        ignore: vec!["node_modules".into()],\n    }))\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:['By default our plugin layer will assume the version file\'s contents contain the literal version, and\nnothing else, like "1.2.3". If any of the files in the ',(0,s.jsx)(n.code,{children:"detect_version_files"})," list require custom\nparsing (for example, ",(0,s.jsx)(n.code,{children:"package.json"})," above), you can define the ",(0,s.jsx)(n.code,{children:"parse_version_file"})," function."]}),"\n",(0,s.jsx)(n.p,{children:"This function receives the file name and contents as input, and must return the parsed version (if\napplicable)."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'#[plugin_fn]\npub fn parse_version_file(Json(input): Json<ParseVersionFileInput>) -> FnResult<Json<ParseVersionFileOutput>> {\n    let mut version = None;\n\n    if input.file == "package.json" {\n        let json: PackageJson = serde_json::from_str(&input.content)?;\n\n        if let Some(engines) = json.engines {\n            if let Some(constraint) = engines.get("node") {\n                version = Some(UnresolvedVersionSpec::parse(constraint)?);\n            }\n        }\n    } else {\n        version = Some(UnresolvedVersionSpec::parse(input.content.trim())?);\n    }\n\n    Ok(Json(ParseVersionFileOutput { version }))\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsxs)(n.p,{children:["The best way to test the plugin is to execute it through ",(0,s.jsx)(n.code,{children:"proto"})," directly. To do this, you'll need\nto configure a ",(0,s.jsx)(n.code,{children:".prototools"})," file at the root of your plugin's repository that maps the plugin to a\ndebug build:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-toml",children:'[plugins]\n<id> = "file://./target/wasm32-wasip1/debug/<name>.wasm"\n'})}),"\n",(0,s.jsx)(n.p,{children:"And everytime you make a change to the plugin, you'll need to rebuild it with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"cargo build --target wasm32-wasip1\n"})}),"\n",(0,s.jsxs)(n.p,{children:["With these 2 pieces in place, you can now execute ",(0,s.jsx)(n.code,{children:"proto"})," commands. Be sure you're running them from\nthe directory with the ",(0,s.jsx)(n.code,{children:".prototools"})," file, and that you're passing ",(0,s.jsx)(n.code,{children:"--log trace"}),". Logs are extremely\nhelpful for figuring out what's going on."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"proto --log trace install <id>\nproto --log trace list-remote <id>\n...\n"})}),"\n",(0,s.jsx)(n.h3,{id:"unit-tests",children:"Unit tests"}),"\n",(0,s.jsx)(n.p,{children:"Testing WASM plugins is a bit tricky, but we've taken it upon ourselves to streamline this process\nas much as possible with built-in test utilities, and Rust macros for generating common test cases.\nTo begin, install all necessary development dependencies:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"cargo add --dev proto_pdk_test_utils starbase_sandbox tokio\n"})}),"\n",(0,s.jsx)(n.p,{children:"And as mentioned above, everytime you make a change to the plugin, you'll need to rebuild it with:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:"cargo build --target wasm32-wasip1\n"})}),"\n",(0,s.jsx)(n.h4,{id:"testing-plugin-functions",children:"Testing plugin functions"}),"\n",(0,s.jsxs)(n.p,{children:["The common test case is simply calling plugin functions with a provided input and asserting the\noutput is correct. This can be achieved by creating a plugin instance with ",(0,s.jsx)(n.code,{children:"create_plugin"})," and\ncalling the appropriate method."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use proto_pdk_test_utils::*;\nuse starbase_sandbox::create_empty_sandbox;\n\n#[tokio::test(flavor = "multi_thread")]\nasync fn registers_metadata() {\n    let sandbox = create_empty_proto_sandbox();\n    let plugin = sandbox.create_plugin("id").await;\n\n    assert_eq!(\n        plugin.register_tool(RegisterToolInput::default()).await,\n        RegisterToolOutput {\n            name: "Name".into(),\n            ..RegisterToolOutput::default()\n        }\n    );\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"We suggest using this pattern for static functions that return a deterministic output from a\nprovided input, and not for dynamic functions that make HTTP requests or execute host commands."})}),"\n",(0,s.jsx)(n.h4,{id:"generating-cases-from-macros",children:"Generating cases from macros"}),"\n",(0,s.jsx)(n.p,{children:"To reduce the burden of writing custom tests for common flows, like downloading a pre-built,\nresolving versions, and generating shims, we provide a set of Rust decl macros that will generate\nthe tests for you."}),"\n",(0,s.jsxs)(n.p,{children:["To test downloading and installing, use ",(0,s.jsx)(n.code,{children:"generate_download_install_tests!"}),". This macro requires a\nplugin ID and a real version to test with."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'use proto_pdk_test_utils::*;\n\ngenerate_download_install_tests!("id", "1.2.3");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To test version resolving, use ",(0,s.jsx)(n.code,{children:"generate_resolve_versions_tests!"}),". This macro requires a plugin ID,\nand a mapping of version/aliases assertions to expectations."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'generate_resolve_versions_tests!("id", {\n    "0.4" => "0.4.12",\n    "0.5.1" => "0.5.1",\n    "stable" => "1.0.0",\n});\n'})}),"\n",(0,s.jsxs)(n.p,{children:["To test installing and uninstalling globals, use ",(0,s.jsx)(n.code,{children:"generate_globals_test!"}),". This macro requires a\nplugin ID, the dependency to install, and an optional environment variable to the globals directory."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'// Doesn\'t support all use cases! If this doesn\'t work, implement a test case manually.\ngenerate_globals_test!("id", "dependency", "GLOBAL_INSTALL_ROOT");\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And lastly, to test shims, use ",(0,s.jsx)(n.code,{children:"generate_shims_test!"}),". This requires a plugin ID and a list of shim\nfile names. This macro generates snapshots using ",(0,s.jsx)(n.a,{href:"https://insta.rs/",children:"Insta"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-rust",children:'generate_shims_test!("id", ["primary", "secondary"]);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"building-and-publishing",children:"Building and publishing"}),"\n",(0,s.jsx)(n.admonition,{type:"success",children:(0,s.jsxs)(n.p,{children:["Refer to our ",(0,s.jsx)(n.a,{href:"../guides/wasm-plugins#building-and-publishing",children:"official WASM guide"})," for steps on how\nto build and publish your plugin."]})}),"\n",(0,s.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsx)(n.p,{children:"Some helpful resources for learning about and building plugins."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://github.com/moonrepo/plugins",children:"Official proto WASM plugins"})}),"\n",(0,s.jsxs)(n.li,{children:["Plugin development kit","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://docs.rs/proto_pdk/",children:[(0,s.jsx)(n.code,{children:"proto_pdk"})," docs"]})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsxs)(n.a,{href:"https://docs.rs/proto_pdk_test_utils/",children:[(0,s.jsx)(n.code,{children:"proto_pdk_test_utils"})," docs"]})}),"\n"]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},43023:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var i=t(63696);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}},65162:(e,n,t)=>{t.d(n,{A:()=>l});var i=t(11750),s=t(74599),o=t(62540);const r={failure:"bg-red-100 text-red-900",info:"bg-pink-100 text-pink-900",success:"bg-green-100 text-green-900",warning:"bg-orange-100 text-orange-900"};function l(e){let{className:n,icon:t,text:l,variant:a}=e;return(0,o.jsxs)("span",{className:(0,i.A)("inline-flex items-center px-1 py-0.5 rounded text-xs font-bold uppercase",a?r[a]:"bg-gray-100 text-gray-800",n),children:[t&&(0,o.jsx)(s.A,{icon:t,className:"mr-1"}),l]})}}}]);