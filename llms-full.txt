# moonrepo

> A developer productivity tooling platform.

This file contains all documentation content in a single document following the llmtxt.org standard.

## Cheat sheet

import Columns from '@site/src/components/Columns';

Don't have time to read the docs? Here's a quick cheat sheet to get you started.

## Tasks

Learn more about [tasks](./concepts/task) and [targets](./concepts/target).

#### Run all build and test tasks for all projects

```shell
moon check --all
```

#### Run all build and test tasks in a project

```shell
moon check project
```

#### Run all build and test tasks for closest project based on working directory

```shell
moon check
```

#### Run a task in all projects

```shell
moon run :task
```

#### Run a task in all projects with a tag

```shell
moon run '#tag:task'
# OR
moon run \#tag:task
# OR
moon run :task --query "tag=tag"
```

#### Run a task in a project

```shell
moon run project:task
```

#### Run multiple tasks in all projects

```shell
moon run :task1 :task2
```

#### Run multiple tasks in any project

```shell
moon run projecta:task1 projectb:task2
```

#### Run a task in applications, libraries, or tools

```shell
moon run :task --query "projectType=application"
```

#### Run a task in projects of a specific language

```shell
moon run :task --query "language=typescript"
```

#### Run a task in projects matching a keyword

```shell
moon run :task --query "project~react-*"
```

#### Run a task in projects based on file path

```shell
moon run :task --query "projectSource~packages/*"
```

## Task configuration

Learn more about [available options](./config/project#tasks).

#### Disable caching

```yaml title="moon.yml"
tasks:
  example:
    # ...
    options:
      cache: false
```

#### Re-run flaky tasks

```yaml title="moon.yml"
tasks:
  example:
    # ...
    options:
      retryCount: 3
```

#### Depend on tasks from parent project's dependencies

```yaml title="moon.yml"
# Also inferred from the language
dependsOn:
  - 'project-a'
  - 'project-b'

tasks:
  example:
    # ...
    deps:
      - '^:build'
```

#### Depend on tasks from arbitrary projects

```yaml title="moon.yml"
tasks:
  example:
    # ...
    deps:
      - 'other-project:task'
```

#### Run dependencies serially

```yaml title="moon.yml"
tasks:
  example:
    # ...
    deps:
      - 'first'
      - 'second'
      - 'third'
    options:
      runDepsInParallel: false
```

#### Run multiple watchers/servers in parallel

```yaml title="moon.yml"
tasks:
  example:
    command: 'noop'
    deps:
      - 'app:watch'
      - 'backend:start'
      - 'tailwind:watch'
    local: true
```

> The `local` or `persistent` settings are required for this to work.

## Languages

#### Run system binaries available on `PATH`

```yaml title="moon.yml"
language: 'bash' # batch, etc

tasks:
  example:
    command: 'printenv'
```

```yaml title="moon.yml"
tasks:
  example:
    command: 'printenv'
    toolchain: 'system'
```

#### Run language binaries not supported in moon's toolchain

```yaml title="moon.yml"
language: 'ruby'

tasks:
  example:
    command: 'rubocop'
    toolchain: 'system'
```

#### Run npm binaries (Node.js)

```yaml title="moon.yml"
language: 'javascript' # typescript

tasks:
  example:
    command: 'eslint'
```

```yaml title="moon.yml"
tasks:
  example:
    command: 'eslint'
    toolchain: 'node'
```

---

## action-graph

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon action-graph [target]` (or `moon ag`) command will generate and serve a visual graph of
all actions and tasks within the workspace, known as the
[action graph](../how-it-works/action-graph). In other tools, this is sometimes referred to as a
dependency graph or task graph.

```shell
# Run the visualizer locally
$ moon action-graph

# Export to DOT format
$ moon action-graph --dot > graph.dot
```

> A target can be passed to focus the graph, including dependencies _and_ dependents. For example,
> `moon action-graph app:build`.

### Arguments

- `[target]` - Optional target to focus.

### Options

- `--dependents` - Include dependents of the focused target.
- `--dot` - Print the graph in DOT format.
- `--host` - The host address. Defaults to `127.0.0.1`. 
- `--json` - Print the graph in JSON format.
- `--port` - The port to bind to. Defaults to a random port. 

### Configuration

- [`runner`](../config/workspace#runner) in `.moon/workspace.yml`
- [`tasks`](../config/tasks#tasks) in `.moon/tasks.yml`
- [`tasks`](../config/project#tasks) in `moon.yml`

## Example output

The following output is an example of the graph in DOT format.

```dot
digraph {
    0 [ label="SetupToolchain(node)" style=filled, shape=oval, fillcolor=black, fontcolor=white]
    1 [ label="InstallWorkspaceDeps(node)" style=filled, shape=oval, fillcolor=gray, fontcolor=black]
    2 [ label="SyncProject(node, node)" style=filled, shape=oval, fillcolor=gray, fontcolor=black]
    3 [ label="RunTask(node:standard)" style=filled, shape=oval, fillcolor=gray, fontcolor=black]
    1 -> 0 [ arrowhead=box, arrowtail=box]
    2 -> 0 [ arrowhead=box, arrowtail=box]
    3 -> 1 [ arrowhead=box, arrowtail=box]
    3 -> 2 [ arrowhead=box, arrowtail=box]
}
```

---

## bin

The `moon bin ` command will return an absolute path to a tool's binary within the toolchain.
If a tool has not been configured or installed, this will return a 1 or 2 exit code with no value
respectively.

```shell
$ moon bin node
/Users/example/.proto/tools/node/x.x.x/bin/node
```

> A tool is considered "not configured" when not in use, for example, querying yarn/pnpm when the
> package manager is configured for "npm". A tool is considered "not installed", when it has not
> been downloaded and installed into the tools directory.

### Arguments

- `` - Name of the tool to query.

---

## check

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon check [...projects]` (or `moon c`) command will run _all_
[build and test tasks](../concepts/task#types) for one or many projects. This is a convenience
command for verifying the current state of a project, instead of running multiple
[`moon run`](./run) commands.

```shell
# Check project at current working directory
$ moon check

# Check project by name
$ moon check app

# Check multiple projects by name
$ moon check client server

# Check ALL projects (may be costly)
$ moon check --all
```

### Arguments

- `[...names]` - List of project names or aliases to explicitly check, as defined in
  [`projects`](../config/workspace#projects).

### Options

- `--all` - Run check for all projects in the workspace.
- `-u`, `--updateCache` - Bypass cache and force update any existing items.
- `--summary` - Display a summary and stats of the current run. 

### Configuration

- [`projects`](../config/workspace#projects) in `.moon/workspace.yml`
- [`tasks`](../config/tasks#tasks) in `.moon/tasks.yml`
- [`tasks`](../config/project#tasks) in `moon.yml`

---

## ci

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon ci` command is a special command that should be ran in a continuous integration (CI)
environment, as it does all the heavy lifting necessary for effectively running tasks.

By default this will run all tasks that are affected by touched files and have the
[`runInCI`](../config/project#runinci) task option enabled.

```shell
$ moon ci
```

However, you can also provide a list of targets to explicitly run, which will still be filtered down
by `runInCI`.

```shell
$ moon ci :build :lint
```

> View the official [continuous integration guide](../guides/ci) for a more in-depth example of how
> to utilize this command.

### Arguments

- `...[target]` - [Targets](../concepts/target) to run.

### Options

- `--base ` - Base branch, commit, or revision to compare against
  ([learn more](../guides/ci#comparing-revisions)).
- `--head ` - Current branch, commit, or revision to compare with
  ([learn more](../guides/ci#comparing-revisions)).
- `--job ` - Index of the current job.
- `--jobTotal ` Total amount of jobs to run.
- `--stdin` - Accept touched files from stdin for affected checks. 

### Configuration

- [`tasks`](../config/tasks#tasks) in `.moon/tasks.yml`
- [`tasks`](../config/project#tasks) in `moon.yml`
- [`tasks.*.options.runInCI`](../config/project#runinci) in `moon.yml`

---

## clean

The `moon clean` command will clean the current workspace by deleting stale cache. For the most
part, the action pipeline will clean automatically, but this command can be used to reset the
workspace entirely.

```shell
$ moon clean

# Delete cache with a custom lifetime
$ moon clean --lifetime '24 hours'
```

### Options

- `--lifetime` - The maximum lifetime of cached artifacts before being marked as stale. Defaults to
  "7 days".

---

## completions

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The `moon completions` command will generate moon command and argument completions for your current
shell. This command will write to stdout, which can then be redirected to a file of your choice.

```shell
$ moon completions > ./path/to/write/to
```

### Options

- `--shell` - Shell to explicitly generate for.

### Examples

If using [bash-completion](https://github.com/scop/bash-completion).

```shell
mkdir -p ~/.bash_completion.d
moon completions > ~/.bash_completion.d/moon.sh
```

Otherwise write the file to a common location, and source it in your profile.

```shell
mkdir -p ~/.bash_completions
moon completions > ~/.bash_completions/moon.sh

# In your profile
source ~/.bash_completions/moon.sh
```

Write the file to Fish's completions directory.

```shell
mkdir -p ~/.config/fish/completions
moon completions > ~/.config/fish/completions/moon.fish
```

If using [oh-my-zsh](https://ohmyz.sh/) (the `_` prefix is required).

```shell
mkdir -p ~/.oh-my-zsh/completions
moon completions > ~/.oh-my-zsh/completions/_moon

# Reload shell (or restart terminal)
omz reload
```

---

## docker file

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon docker file ` command can be used to generate a multi-staged `Dockerfile` for a
project, that takes full advantage of Docker's layer caching, and is primarily for production
deploys (this should not be used for development).

```shell
$ moon docker file 
```

As mentioned above, the generated `Dockerfile` uses a multi-stage approach, where each stage is
broken up into the following:

- `base` - The base stage, which simply installs moon for a chosen Docker image. This stage requires
  Bash.
- `skeleton` - Scaffolds workspace and sources repository skeletons using
  [`moon docker scaffold`](./scaffold).
- `build` - Copies required sources, installs the toolchain using [`moon docker setup`](./setup),
  optionally builds the project, and optionally prunes the image using
  [`moon docker prune`](./prune).
- `start` - Runs the project after it has been built. This is typically starting an HTTP server, or
  executing a binary.

:::info

View the official [Docker usage guide](../../guides/docker) for a more in-depth example of how to
utilize this command.

:::

### Arguments

- `` - Name or alias of a project, as defined in
  [`projects`](../../config/workspace#projects).
- `[dest]` - Destination to write the file, relative from the project root. Defaults to
  `Dockerfile`.

### Options

- `--defaults` - Use default options instead of prompting in the terminal.
- `--buildTask` - Name of a task to build the project. Defaults to the
  [`docker.file.buildTask`](../../config/project#buildtask) setting, or prompts in the terminal.
- `--image` - Base Docker image to use. Defaults to an image derived from the toolchain, or prompts
  in the terminal.
- `--no-prune` - Do not prune the workspace in the build stage.
- `--no-toolchain` - Do not use the toolchain and instead use system binaries.
- `--startTask` - Name of a task to start the project. Defaults to the
  [`docker.file.startTask`](../../config/project#starttask) setting, or prompts in the terminal.

### Configuration

- [`docker.file`](../../config/project#file) in `moon.yml`

---

## docker prune

The `moon docker prune` command will reduce the overall filesize of the Docker environment by
installing production only dependencies for projects that were scaffolded, and removing any
applicable extraneous files.

```shell
$ moon docker prune
```

:::info

View the official [Docker usage guide](../../guides/docker) for a more in-depth example of how to
utilize this command.

:::

:::caution

This command _must be_ ran after [`moon docker scaffold`](./scaffold) and is typically ran within a
`Dockerfile`! The [`moon docker file`](./file) command can be used to generate a `Dockerfile`.

:::

### Configuration

- [`docker.prune`](../../config/workspace#prune) in `.moon/workspace.yml`

---

## docker scaffold

The `moon docker scaffold ` command creates multiple repository skeletons for use
within `Dockerfile`s, to effectively take advantage of Docker's layer caching. It utilizes the
[project graph][graph] to copy only critical files, like manifests, lockfiles, and configuration.

```shell
# Scaffold a skeleton to .moon/docker
$ moon docker scaffold 
```

:::info

View the official [Docker usage guide](../../guides/docker) for a more in-depth example of how to
utilize this command.

:::

### Arguments

- `` - List of project names or aliases to scaffold sources for, as defined in
  [`projects`][graph].

### Configuration

- [`docker.scaffold`](../../config/workspace#scaffold) in `.moon/workspace.yml` (entire workspace)
- [`docker.scaffold`](../../config/project#scaffold) in `moon.yml` (per project)

## How it works

This command may seem like magic, but it's relative simple thanks to moon's infrastructure and its
project graph. When the command is ran, we generate 2 skeleton structures in `.moon/docker` (be sure
to gitignore this). One for the workspace, and the other for sources.

:::warning

Because scaffolding uses the project graph, it requires all projects with a `package.json` to be
[configured in moon][graph]. Otherwise, moon will fail to copy all required files and builds may
fail.

:::

### Workspace

The workspace skeleton mirrors the project folder structure of the repository 1:1, and only copies
files required for dependencies to install. This is typically manifests (`package.json`), lockfiles
(`yarn.lock`, etc), other critical configs, and `.moon` itself. This is necessary for package
managers to install dependencies (otherwise they will fail), and for dependencies to be layer cached
in Docker.

An example of this skeleton using Yarn may look like the following:

```
.moon/docker/workspace/
├── .moon/
├── .yarn/
├── apps/
│   ├── client/
│   │   └── package.json
│   └── server/
│       └── package.json
├── packages/
│   ├── foo/
│   │   └── package.json
│   ├── bar/
│   │   └── package.json
│   └── baz/
│       └── package.json
├── .yarnrc.yml
├── package.json
└── yarn.lock
```

### Sources

The sources skeleton is not a 1:1 mirror of the repository, and instead is the source files of a
project (passed as an argument to the command), and all of its dependencies. This allows
[`moon run`](../run) and other commands to work within the `Dockerfile`, and avoid having to
`COPY . .` the entire repository.

Using our example workspace above, our sources skeleton would look like the following, assuming our
`client` project is passed as an argument, and this project depends on the `foo` and `baz` projects.

```
.moon/docker/sources/
├── apps/
│   └── client/
|       ├── src/
|       ├── tests/
|       ├── public/
|       ├── package.json
|       ├── tsconfig.json
│       └── (anything else)
└── packages/
    ├── foo/
    │   ├── lib/
    │   ├── src/
    │   ├── package.json
    │   ├── tsconfig.json
    │   └── (anything else)
    └── baz/
        ├── lib/
        ├── src/
        ├── package.json
        ├── tsconfig.json
        └── (anything else)
```

[graph]: ../../config/workspace#projects

---

## docker setup

The `moon docker setup` command will efficiently install dependencies for focused projects. This is
an all-in-one command for tool and dependency installations, and should replace `npm install` and
other commands.

```shell
$ moon docker setup
```

:::info

View the official [Docker usage guide](../../guides/docker) for a more in-depth example of how to
utilize this command.

:::

:::caution

This command _must be_ ran after [`moon docker scaffold`](./scaffold) and is typically ran within a
`Dockerfile`! The [`moon docker file`](./file) command can be used to generate a `Dockerfile`.

:::

### Configuration

- [`*`](../../config/toolchain) in `.moon/toolchain.yml`

---

## ext

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon ext ` command will execute an extension (a WASM plugin) that has been configured with
the [`extensions`](../config/workspace#extensions) setting in [`.moon/workspace.yml`](../config).
View our official [extensions guide](../guides/extensions) for more information.

```shell
$ moon ext download -- --url https://github.com/moonrepo/moon/archive/refs/tags/v1.19.3.zip
```

Extensions typically support command line arguments, which _must_ be passed after a `--` separator
(as seen above). Any arguments before the separator will be passed to the `moon ext` command itself.

:::caution

This command requires an internet connection if the extension's `.wasm` file must be downloaded from
a URL, and it hasn't been cached locally.

:::

### Arguments

- `` - Name of the extension to execute.
- `[-- ]` - Arguments to pass to the extension.

### Configuration

- [`extensions`](../config/workspace#extensions) in `.moon/workspace.yml`

---

## generate

The `moon generate ` (or `moon g`) command will generate code (files and folders) from a
pre-defined template of the same name, using an interactive series of prompts. Templates are located
based on the [`generator.templates`](../config/workspace#templates) setting.

```shell
# Generate code from a template
$ moon generate npm-package

# Generate code from a template to a target directory
$ moon generate npm-package ./packages/example

# Generate code while declaring custom variable values
$ moon generate npm-package ./packages/example -- --name "@company/example"

# Create a new template
$ moon generate react-app --template
```

> View the official [code generation guide](../guides/codegen) for a more in-depth example of how to
> utilize this command.

### Arguments

- `` - Name of the template to generate.
- `[dest]` - Destination to write files to, relative from the current working directory. If not
  defined, will be prompted during generation.
- `[-- ]` - Additional arguments to override default variable values.

### Options

- `--defaults` - Use the default value of all variables instead of prompting the user.
- `--dryRun` - Run entire generator process without writing files.
- `--force` - Force overwrite any existing files at the destination.
- `--template` - Create a new template with the provided name.

### Configuration

- [`generator`](../config/workspace#generator) in `.moon/workspace.yml`

---

## init

The `moon init` command will initialize moon into a repository and scaffold necessary config files
by creating a `.moon` folder.

```shell
$ moon init

# In another directory
$ moon init --to ./app
```

#### Initializing a specific tool

The command can also be used to initialize a specific tool into the toolchain _after_ moon has
already been initialized. Perfect for adopting a new language into the workspace.

```shell
$ moon init node
```

When ran, we'll prompt you with a handful of questions, and generate (or modify) the
[`.moon/toolchain.yml`](../config/toolchain) file.

### Arguments

- `[tool]` - Individual tool to initialize and configure.
  - Accepts: `bun`, `node`, `rust`, `typescript`

### Options

- `--force` - Overwrite existing config files if they exist.
- `--minimal` - Generate minimal configurations and sane defaults.
- `--to` - Destination to initialize and scaffold into. Defaults to `.` (current working directory).
- `--yes` - Skip all prompts and enables tools based on file detection.

---

## mcp

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon mcp` command will start an [MCP](https://modelcontextprotocol.io) server that listens for
requests from AI assistants. This allows for agentic workflows in your favorite editor.

```shell
$ moon mcp
```

:::info

This command should not be ran manually and instead should be integrated into your editor. View the
[MCP guide](../guides/mcp) for more information.

:::

---

## migrate from-package-json

Use the `moon migrate from-package-json ` sub-command to migrate a project's `package.json`
to our [`moon.yml`](../../config/project) format. When ran, the following changes are made:

- Converts `package.json` scripts to `moon.yml` [tasks](../../config/project#tasks). Scripts and
  tasks are not 1:1, so we'll convert as close as possible while retaining functionality.
- Updates `package.json` by removing all converted scripts. If all scripts were converted, the
  entire block is removed.
- Links `package.json` dependencies as `moon.yml` [dependencies](../../config/project#dependson)
  (`dependsOn`). Will map a package's name to their moon project name.

This command is ran _per project_, and for this to operate correctly, requires all
[projects to be configured in the workspace](../../config/workspace#projects). There's also a
handful of [requirements and caveats](#caveats) to be aware of!

```shell
$ moon --log debug migrate from-package-json app
```

:::caution

moon does its best to infer the [`local`](../../config/project#local) option, given the small amount
of information available to use. When this option is incorrectly set, it'll result in CI
environments hanging for tasks that are long-running or never-ending (development servers, etc), or
won't run builds that should be. Be sure to audit each task after migration!

:::

### Arguments

- `` - Name of a project, as defined in [`projects`](../../config/workspace#projects).

## Caveats

- When running a script within another script, the full invocation of `npm run ...`, `pnpm run ...`,
  or `yarn run ...` must be used. Shorthand variants are **not** supported, for example, `npm test`
  or `yarn lint` or `pnpm format`. We cannot guarantee that moon will parse these correctly
  otherwise.

  ```diff title="package.json"
  {
  	// ...
  	"scripts": {
  		"lint": "eslint .",
  -		"lint:fix": "yarn lint --fix",
  +		"lint:fix": "yarn run lint --fix",
  	}
  }
  ```

- Scripts that run multiple commands with the AND operator (`&&`) will create an individual
  transient task for each command, with all tasks linked _in-order_ using task
  [`deps`](../../config/project#deps). These commands _will not_ run in parallel. For example, given
  the following script:

  ```json title="package.json"
  {
    // ...
    "scripts": {
      // ...
      "check": "yarn run lint && yarn run test && yarn run typecheck"
    }
  }
  ```

  Would create 3 tasks that create the dependency chain:
  `check-dep1 (lint) -> check-dep2 (test) -> check (typecheck)`, instead of the expected parallel
  execution of `lint | test | typecheck -> check`. If you would prefer these commands to run in
  parallel, then you'll need to craft your tasks manually.

- Scripts that change directory (`cd ...`), use pipes (`|`), redirects (`>`), or the OR operator
  (`||`) are **not** supported and will be skipped. Tasks and scripts are not 1:1 in functionality,
  as tasks represent that state of a single command execution. However, you can wrap this
  functionality in a
  [custom script that executes it on the task's behalf](../../faq#how-to-pipe-or-redirect-tasks).

- [Life cycle scripts](https://docs.npmjs.com/cli/v8/using-npm/scripts#life-cycle-scripts) are
  **not** converted to tasks and will remain in `package.json` since they're required by npm (and
  other package managers). However, their commands _will_ be updated to execute moon commands when
  applicable.

  ```diff title="package.json"
  {
  	// ...
  	"scripts": {
  -		"preversion": "yarn run lint && yarn run test",
  +		"preversion": "moon run project:lint && moon run project:test",
  	}
  }
  ```

  > This _does not_ apply to `run`, `start`, `stop`, and `test` life cycles.

- "Post" life cycles for
  [user defined scripts](https://docs.npmjs.com/cli/v8/using-npm/scripts#npm-run-user-defined) do
  not work, as moon tasks have no concept of "run this after the task completes", so we suggest
  _against using these entirely_. However, we still convert the script and include the base script
  as a task dependency.

  For example, a `posttest` script would be converted into a `posttest` task, with the `test` task
  included in [`deps`](../../config/project#deps). For this to actually run correctly, you'll need
  to use `moon run :posttest` AND NOT `moon run :test`.

---

## migrate from-turborepo

This command has been deprecated, use the
[`moon ext migrate-turborepo`](../../guides/extensions#migrate-turborepo) command instead.

---

## Overview

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The following options are available for _all_ moon commands.

- `--cache ` - The mode for [cache operations](#caching).
- `--color` - Force [colored output](#colors) for moon (not tasks).
- `--concurrency`, `-c` - Maximum number of threads to utilize.
- `--dump` - Dump a [trace profile](#profiling) to the working directory.
- `--help` - Display the help menu for the current command.
- `--log ` - The lowest [log level to output](#logging).
- `--logFile ` - Write logs to the defined file.
- `--quiet`, `-q` - Hide all non-important moon specific terminal output.
- `--theme` - Terminal theme to write output in. 
- `--version` - Display the version of the CLI.

## Caching

We provide a powerful [caching layer](../concepts/cache), but sometimes you need to debug failing or
broken tasks, and this cache may get in the way. To circumvent this, we support the `--cache` global
option, or the `MOON_CACHE` environment variable, both of which accept one of the following values.

- `off` - Turn off caching entirely. Every task will run fresh, including dependency installs.
- `read` - Read existing items from the cache, but do not write to them.
- `read-write` (default) - Read and write items to the cache.
- `write` - Do not read existing cache items, but write new items to the cache.

```shell
$ moon run app:build --cache off
# Or
$ MOON_CACHE=off moon run app:build
```

## Colors

Colored output is a complicated subject, with differing implementations and standards across tooling
and operating systems. moon aims to normalize this as much as possible, by doing the following:

- By default, moon colors are inherited from your terminal settings (`TERM` and `COLORTERM`
  environment variables).
- Colors can be force enabled by passing the `--color` option (preferred), or `MOON_COLOR` or
  `FORCE_COLOR` environment variables.

```shell
$ moon app:build --color run
# Or
$ MOON_COLOR=2 moon run app:build
```

When forcing colors with `MOON_COLOR` or `FORCE_COLOR`, you may set it to one of the following
numerical values for the desired level of color support. This is automatically inferred if you use
`--color`.

- `0` - No colors
- `1` - 16 colors (standard terminal colors)
- `2` - 256 colors
- `3` - 16 million colors (truecolor)

### Themes

By default, moon assumes a dark themed terminal is being used, and will output colors accordingly.
However, if you use a light theme, these colors are hard to read. To mitigate this, we support
changing the theme with the `--theme` global option, or the `MOON_THEME` environment variable.

```shell
$ moon run app:build --theme light
# Or
$ MOON_THEME=light moon run app:build
```

### Piped output

When tasks (child processes) are piped, colors and ANSI escape sequences are lost, since the target
is not a TTY and we do not implement a PTY. This is a common pattern this is quite annoying.
However, many tools and CLIs support a `--color` option to work around this limitation and to always
force colors, even when not a TTY.

To mitigate this problem as a whole, and to avoid requiring `--color` for every task, moon supports
the [`pipeline.inheritColorsForPipedTasks`](../config/workspace#inheritcolorsforpipedtasks)
configuration setting. When enabled, all piped child processes will inherit the color settings of
the currently running terminal.

## Concurrency

The `--concurrency` option or `MOON_CONCURRENCY` environment variable can be used to control the
maximum amount of threads to utilize in our thread pool. If not defined, defaults to the number of
operating system cores.

```shell
$ moon run app:build --concurrency 1
# Or
$ MOON_CONCURRENCY=1 moon run app:build
```

## Debugging

At minimum, most debugging can be done by passing [`--log trace`](#logging) on the command line and
sifting through the logs. We also provide the following environment variables to toggle output.

- `MOON_DEBUG_PROCESS_ENV` - By default moon hides the environment variables (except for `MOON_`)
  passed to processes to avoid leaking sensitive information. However, knowing what environment
  variables are passed around is helpful in debugging. Declare this variable to reveal the entire
  environment.
- `MOON_DEBUG_PROCESS_INPUT` - By default moon truncates the stdin passed to processes to avoid
  thrashing the console with a large input string. However, knowing what input is passed around is
  helpful in debugging. Declare this variable to reveal the entire input.
- `MOON_DEBUG_PROTO_INSTALL` - Debug the proto installation process.
- `MOON_DEBUG_REMOTE` - Debug our remote caching implementation by including additional logging
  output, and printing internal connection errors.
- `MOON_DEBUG_WASM` - Debug our WASM plugins by including additional logging output, and optionally
  dumping memory/core profiles.

## Logging

By default, moon aims to output as little as possible, as we want to preserve the original output of
the command's being ran, excluding warnings and errors. This is managed through log levels, which
can be defined with the `--log` global option, or the `MOON_LOG` environment variable. The following
levels are supported, in priority order.

- `off` - Turn off logging entirely.
- `error` - Only show error logs.
- `warn` - Only show warning logs and above.
- `info` (default) - Only show info logs and above.
- `debug` - Only show debug logs and above.
- `trace` - Show all logs, including network requests and child processes.
- `verbose` - Like `trace` but also includes span information. 

```shell
$ moon run app:build --log trace
# Or
$ MOON_LOG=trace moon run app:build
```

### Writing logs to a file

moon can dump the logs from a command to a file using the `--logFile` option, or the `MOON_LOG_FILE`
environment variable. The dumped logs will respect the `--log` option and filter the logs piped to
the output file.

```shell
$ moon run app:build --logFile=output.log
# Or
$ MOON_LOG_FILE=output.log moon run app:build
```

## Profiling

When the `--dump` option or `MOON_DUMP` environment variable is set, moon will generate a trace
profile and dump it to the current working directory. This profile can be opened with Chrome (via
`chrome://tracing`) or [Perfetto](https://ui.perfetto.dev/).

This profile will display many of the operations within moon as a flame chart, allowing you to
inspect and debug slow operations.

---

## project-graph

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon project-graph [id]` (or `moon pg`) command will generate and serve a visual graph of all
configured projects as nodes, with dependencies between as edges, and can also output the graph in
[Graphviz DOT format](https://graphviz.org/doc/info/lang.html).

```shell
# Run the visualizer locally
$ moon project-graph

# Export to DOT format
$ moon project-graph --dot > graph.dot
```

> A project name can be passed to focus the graph to only that project and its dependencies. For
> example, `moon project-graph app`.

### Arguments

- `[name]` - Optional name or alias of a project to focus, as defined in
  [`projects`](../config/workspace#projects).

### Options

- `--dependents` - Include direct dependents of the focused project.
- `--dot` - Print the graph in DOT format.
- `--host` - The host address. Defaults to `127.0.0.1`. 
- `--json` - Print the graph in JSON format.
- `--port` - The port to bind to. Defaults to a random port. 

### Configuration

- [`projects`](../config/workspace#projects) in `.moon/workspace.yml`

## Example output

The following output is an example of the graph in DOT format.

```dot
digraph {
    0 [ label="(workspace)" style=filled, shape=circle, fillcolor=black, fontcolor=white]
    1 [ label="runtime" style=filled, shape=circle, fillcolor=gray, fontcolor=black]
    2 [ label="website" style=filled, shape=circle, fillcolor=gray, fontcolor=black]
    0 -> 1 [ arrowhead=none]
    0 -> 2 [ arrowhead=none]
}
```

---

## project

The `moon project ` (or `moon p`) command will display all available information about a
project that has been configured and exists within the graph. If a project does not exist, the
program will return with a 1 exit code.

```shell
$ moon project web
```

### Arguments

- `` - Name or alias of a project, as defined in [`projects`](../config/workspace#projects).

### Options

- `--json` - Print the project and its configuration as JSON.

## Example output

The following output is an example of what this command prints, using our very own
`@moonrepo/runtime` package.

```
RUNTIME

Project: runtime
Alias: @moonrepo/runtime
Source: packages/runtime
Root: ~/Projects/moon/packages/runtime
Platform: node
Language: typescript
Stack: unknown
Type: library

DEPENDS ON

  - types (implicit, production)

INHERITS FROM

  - .moon/tasks/node.yml

TASKS

build:
  › packemon build --addFiles --addExports --declaration
format:
  › prettier --check --config ../../prettier.config.js --ignore-path ../../.prettierignore --no-error-on-unmatched-pattern .
lint:
  › eslint --cache --cache-location ./.eslintcache --color --ext .js,.ts,.tsx --ignore-path ../../.eslintignore --exit-on-fatal-error --no-error-on-unmatched-pattern --report-unused-disable-directives .
lint-fix:
  › eslint --cache --cache-location ./.eslintcache --color --ext .js,.ts,.tsx --ignore-path ../../.eslintignore --exit-on-fatal-error --no-error-on-unmatched-pattern --report-unused-disable-directives . --fix
test:
  › jest --cache --color --preset jest-preset-moon --passWithNoTests
typecheck:
  › tsc --build

FILE GROUPS

configs:
  - packages/runtime/*.{js,json}
sources:
  - packages/runtime/src/**/*
  - packages/runtime/types/**/*
tests:
  - packages/runtime/tests/**/*
```

### Configuration

- [`projects`](../config/workspace#projects) in `.moon/workspace.yml`
- [`project`](../config/project#project) in `moon.yml`

---

## query hash-diff

Use the `moon query hash-diff` sub-command to query the content and source differences between 2
generated hashes. This is extremely useful in debugging task inputs.

```shell
# Diff between 2 hashes
$ moon query hash-diff 0b55b234f1018581c45b00241d7340dc648c63e639fbafdaf85a4cd7e718fdde 2388552fee5a02062d0ef402bdc7232f0a447458b058c80ce9c3d0d4d7cfe171

# Diff between 2 hashes using short form
$ moon query hash-diff 0b55b234 2388552f
```

By default, this will output the contents of a hash file (which is JSON), highlighting the
differences between the left and right hashes. Lines that match will be printed in white, while the
left differences printed in green, and right differences printed in red. If you use `git diff`, this
will feel familiar to you.

```diff
Left:  0b55b234f1018581c45b00241d7340dc648c63e639fbafdaf85a4cd7e718fdde
Right: 2388552fee5a02062d0ef402bdc7232f0a447458b058c80ce9c3d0d4d7cfe171

{
	"command": "build",
	"args": [
+		"./dist"
-		"./build"
	],
	...
}
```

The differences can also be output in JSON by passing the `--json` flag. The output has the
following structure:

```ts
{
	left: string,
	left_hash: string,
	left_diffs: string[],
	right: string,
	right_hash: string,
	right_diffs: string[],
}
```

### Options

- `--json` - Display the manifest in JSON format.

### Configuration

- [`hasher`](../../config/workspace#hasher) in `.moon/workspace.yml`

---

## query hash

Use the `moon query hash` sub-command to inspect the contents and sources of a generated hash, also
known as the hash manifest. This is extremely useful in debugging task inputs.

```shell
$ moon query hash 0b55b234f1018581c45b00241d7340dc648c63e639fbafdaf85a4cd7e718fdde

# Query hash using short form
$ moon query hash 0b55b234
```

By default, this will output the contents of the hash manifest (which is JSON), and the fully
qualified resolved hash.

```json
Hash: 0b55b234f1018581c45b00241d7340dc648c63e639fbafdaf85a4cd7e718fdde

{
  "command": "build",
  "args": ["./build"]
  // ...
}
```

The command can also be output raw JSON by passing the `--json` flag.

### Options

- `--json` - Display the diff in JSON format.

### Configuration

- [`hasher`](../../config/workspace#hasher) in `.moon/workspace.yml`

---

## query projects

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Use the `moon query projects` sub-command to query information about all projects in the project
graph. The project list can be filtered by passing a [query statement](../../concepts/query-lang) as
an argument, or by using [options](#options) arguments.

```shell
# Find all projects
$ moon query projects

# Find all projects with an id that matches "react"
$ moon query projects --id react
$ moon query projects "project~react"

# Find all projects with a `lint` or `build` task
$ moon query projects --tasks "lint|build"
$ moon query projects "task=[lint,build]"
```

By default, this will output a list of projects in the format of
` |  |  |  |  | `, separated by new lines. If no
description is defined, "..." will be displayed instead.

```
web | apps/web | frontend | application | typescript | ...
```

The projects can also be output in JSON by passing the `--json` flag. The output has the following
structure:

```ts
{
	projects: Project[],
	options: QueryOptions,
}
```

### Affected projects

This command can also be used to query for affected projects, based on the state of the VCS working
tree. For advanced control, you can also pass the results of `moon query touched-files` to stdin.

```shell
# Find all affected projects
$ moon query projects --affected

# Find all affected projects using the results of another query
$ moon query touched-files | moon query projects --affected
```

### Arguments

- `[query]` - An optional [query statement](../../concepts/query-lang) to filter projects with. When
  provided, all [filter options](#filters) are ignored. 

### Options

- `--json` - Display the projects in JSON format.

#### Affected

- `--affected` - Filter projects that have been affected by touched files.
- `--downstream` - Include downstream dependents of queried projects. Supports "none" (default),
  "direct", "deep".
  
- `--upstream` - Include upstream dependencies of queried projects. Supports "none", "direct",
  "deep" (default).
  

#### Filters

All option values are case-insensitive regex patterns.

- `--alias ` - Filter projects that match this alias.
- `--id ` - Filter projects that match this ID/name.
- `--language ` - Filter projects of this programming language.
- `--layer ` - Filter project of this layer.
- `--source ` - Filter projects that match this source path.
- `--stack ` - Filter projects of the tech stack.
- `--tags ` - Filter projects that have the following tags.
- `--tasks ` - Filter projects that have the following tasks.

### Configuration

- [`projects`](../../config/workspace#projects) in `.moon/workspace.yml`

---

## query tasks

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Use the `moon query tasks` sub-command to query task information for all projects in the project
graph. The tasks list can be filtered by passing a [query statement](../../concepts/query-lang) as
an argument, or by using [options](#options) arguments.

```shell
# Find all tasks grouped by project
$ moon query tasks

# Find all tasks from projects with an id that matches "react"
$ moon query tasks --id react
$ moon query tasks "task~react"
```

By default, this will output a list of projects, and tasks within the project being indented (with a
tab) on their own line, in the format of ` |  |  |  | `.
If no description is defined, "..." will be displayed instead.

```
web
	lint | eslint | test | node | ...
	test | jest | test | node | ...
app
	format | prettier | test | node | ...
```

The tasks can also be output in JSON by passing the `--json` flag. The output has the following
structure:

```ts
{
	tasks: Record>,
	options: QueryOptions,
}
```

### Arguments

- `[query]` - An optional [query statement](../../concepts/query-lang) to filter projects with. When
  provided, all [filter options](#filters) are ignored. 

### Options

- `--json` - Display the projects in JSON format.

#### Affected

- `--affected` - Filter tasks that have been affected by touched files.
- `--downstream` - Include downstream dependents of queried tasks. Supports "none" (default),
  "direct", "deep".
  
- `--upstream` - Include upstream dependencies of queried tasks. Supports "none", "direct", "deep"
  (default).
  

#### Filters

All option values are case-insensitive regex patterns.

- `--command ` - Filter tasks that match this command.
- `--id ` - Filter tasks that match this ID.
- `--project ` - Filter tasks that belong to this project.
- `--script ` - Filter tasks that match this script.
- `--toolchain ` - Filter tasks of this toolchain. 
- `--type ` - Filter tasks of this type.

### Configuration

- [`projects`](../../config/workspace#projects) in `.moon/workspace.yml`
- [`tasks`](../../config/project#tasks) in `moon.yml`

---

## query touched-files

Use the `moon query touched-files` sub-command to query for a list of touched files (added,
modified, deleted, etc) using the current VCS state. These are the same queries that
[`moon ci`](../ci) and [`moon run`](../run) use under the hood.

Touches files are determined using the following logic:

- If `--defaultBranch` is provided, and the current branch is the
  [`vcs.defaultBranch`](../../config/workspace#defaultbranch), then compare against the previous
  revision of the default branch (`HEAD~1`). This is what [continuous integration](../../guides/ci)
  uses.
- If `--local` is provided, touched files are based on your local index only (`git status`).
- Otherwise, then compare the defined base (`--base`) against head (`--head`).

```shell
# Return all files
$ moon query touched-files

# Return deleted files
$ moon query touched-files --status deleted

# Return all files between 2 revisions
$ moon query touched-files --base  --head 
```

By default, this will output a list of absolute file paths, separated by new lines.

```
/absolute/file/one.ts
/absolute/file/two.ts
```

The files can also be output in JSON by passing the `--json` flag. The output has the following
structure:

```ts
{
	files: string[],
	options: QueryOptions,
}
```

### Options

- `--defaultBranch` - When on the default branch, compare against the previous revision.
- `--base ` - Base branch, commit, or revision to compare against. Defaults to
  [`vcs.defaultBranch`](../../config/workspace#defaultbranch).
- `--head ` - Current branch, commit, or revision to compare with. Defaults to `HEAD`.
- `--json` - Display the files in JSON format.
- `--local` - Gather files from you local state instead of remote.
- `--status ` - Filter files based on a touched status. Can be passed multiple times.
  - Types: `all` (default), `added`, `deleted`, `modified`, `staged`, `unstaged`, `untracked`

### Configuration

- [`vcs`](../../config/workspace#vcs) in `.moon/workspace.yml`

---

## run

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon run` (or `moon r`, or `moonx`) command will run one or many [targets](../concepts/target)
and all of its dependencies in topological order. Each run will incrementally cache each task,
improving speed and development times... over time. View the official [Run a task](../run-task) and
[Cheat sheet](../cheat-sheet#tasks) articles for more information!

```shell
# Run `lint` in project `app`
$ moon run app:lint
$ moonx app:lint

# Run `dev` in project `client` and `server`
$ moon run client:dev server:dev
$ moonx client:dev server:dev

# Run `test` in all projects
$ moon run :test
$ moonx :test

# Run `test` in all projects with tag `frontend`
$ moon run '#frontend:test'
$ moonx '#frontend:test'

# Run `format` in closest project (`client`)
$ cd apps/client
$ moon run format
$ moonx format

# Run `build` in projects matching the query
$ moon run :build --query "language=javascript && projectType=library"
```

:::info

How affected status is determined is highly dependent on whether the command is running locally, in
CI, and what options are provided. The following scenarios are possible:

- When `--affected` is provided, will explicitly use `--remote` to determine CI or local.
- When not provided, will use `git diff` in CI, or `git status` for local.
- To bypass affected logic entirely, use `--force`.

:::

:::info

The default behavior for `moon run` is to "fail fast", meaning that any failed task will immediately
abort execution of the entire action graph. Pass `--no-bail` to execute as many tasks as safely
possible (tasks with upstream failures will be skipped to avoid side effects). This is the default
behavior for `moon ci`, and is also useful for pre-commit hooks.

:::

### Arguments

- `...` - [Targets](../concepts/target) or project relative tasks to run.
- `[-- ]` - Additional arguments to
  [pass to the underlying command](../run-task#passing-arguments-to-the-underlying-command).

### Options

- `-f`, `--force` - Force run and ignore touched files and affected status. Will not query VCS.
- `--dependents` - Run downstream dependent targets (of the same task name) as well.
- `-i`, `--interactive` - Run the target in an interactive mode.
- `--profile ` - Record and [generate a profile](../guides/profile) for ran tasks.
  - Types: `cpu`, `heap`
- `--query` - Filter projects to run targets against using
  [a query statement](../concepts/query-lang). 
- `--summary` - Display a summary and stats of the current run. 
- `-u`, `--updateCache` - Bypass cache and force update any existing items.
- `--no-actions` - Run the task without running [other actions](../how-it-works/action-graph) in the
  pipeline.
  
- `-n`, `--no-bail` - When a task fails, continue executing other tasks instead of aborting
  immediately

#### Affected

- `--affected` - Only run target if affected by changed files, _otherwise_ will always run.
- `--remote` - Determine affected against remote by comparing `HEAD` against a base revision
  (default branch), _otherwise_ uses local changes.
  - Can control revisions with `MOON_BASE` and `MOON_HEAD`.
- `--status ` - Filter affected based on a change status. Can be passed multiple times.
  - Types: `all` (default), `added`, `deleted`, `modified`, `staged`, `unstaged`, `untracked`
- `--stdin` - Accept touched files from stdin for affected checks. 

### Configuration

- [`projects`](../config/workspace#projects) in `.moon/workspace.yml`
- [`tasks`](../config/tasks#tasks) in `.moon/tasks.yml`
- [`tasks`](../config/project#tasks) in `moon.yml`

---

## setup

The `moon setup` command can be used to setup the developer and pipeline environments. It achieves
this by downloading and installing all configured tools into the toolchain.

```shell
$ moon setup
```

:::info

This command should rarely be used, as the environment is automatically setup when running other
commands, like detecting affected projects, running a task, or generating a build artifact.

:::

### Configuration

- [`*`](../config/toolchain) in `.moon/toolchain.yml`

---

## sync codeowners

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon sync codeowners` command will manually sync code owners, by aggregating all owners from
projects, and generating a single `CODEOWNERS` file. Refer to the official
[code owners](../../guides/codeowners) guide for more information.

```shell
$ moon sync codeowners
```

### Options

- `--clean` - Clean and remove previously generated file.
- `--force` - Bypass cache and force create file.

### Configuration

- [`codeowners`](../../config/workspace#codeowners) in `.moon/workspace.yml`
- [`owners`](../../config/project#owners) in `moon.yml`

---

## sync config-schemas

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon sync config-schemas` command will manually generate JSON schemas to `.moon/cache/schemas`
for all our different configuration files.

```shell
$ moon sync config-schemas
```

### Options

- `--force` - Bypass cache and force create files.

---

## sync hooks

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon sync hooks` command will manually sync hooks for the configured
[VCS](../../config/workspace#vcs), by generating and referencing hook scripts from the
[`vcs.hooks`](../../config/workspace#hooks) setting. Refer to the official
[VCS hooks](../../guides/vcs-hooks) guide for more information.

```shell
$ moon sync hooks
```

### Options

- `--clean` - Clean and remove previously generated hooks.
- `--force` - Bypass cache and force create hooks.

### Configuration

- [`vcs.hooks`](../../config/workspace#hooks) in `.moon/workspace.yml`

---

## sync projects

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon sync projects` command will force sync _all_ projects in the workspace to help achieve a
[healthy repository state](../../faq#what-should-be-considered-the-source-of-truth). This applies
the following:

- Ensures cross-project dependencies are linked based on
  [`dependsOn`](../../config/project#dependson).
- Ensures language specific configuration files are present and accurate (`package.json`,
  `tsconfig.json`, etc).
- Ensures root configuration and project configuration are in sync.
- Any additional language specific semantics that may be required.

```shell
$ moon sync projects
```

> This command should rarely be ran, as [`moon run`](../run) will sync affected projects
> automatically! However, when migrating or refactoring, manual syncing may be necessary.

### Configuration

- [`projects`](../../config/workspace#projects) in `.moon/workspace.yml`

---

## task-graph

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon task-graph [target]` (or `moon tg`) command will generate and serve a visual graph of all
configured tasks as nodes, with dependencies between as edges, and can also output the graph in
[Graphviz DOT format](https://graphviz.org/doc/info/lang.html).

```shell
# Run the visualizer locally
$ moon task-graph

# Export to DOT format
$ moon task-graph --dot > graph.dot
```

> A task target can be passed to focus the graph to only that task and its dependencies. For
> example, `moon task-graph app:build`.

### Arguments

- `[target]` - Optional target of task to focus.

### Options

- `--dependents` - Include direct dependents of the focused task.
- `--dot` - Print the graph in DOT format.
- `--host` - The host address. Defaults to `127.0.0.1`. 
- `--json` - Print the graph in JSON format.
- `--port` - The port to bind to. Defaults to a random port. 

## Example output

The following output is an example of the graph in DOT format.

```dot
digraph {
    0 [ label="types:build" style=filled, shape=oval, fillcolor=gray, fontcolor=black]
    1 [ label="runtime:build" style=filled, shape=oval, fillcolor=gray, fontcolor=black]
    2 [ label="website:build" style=filled, shape=oval, fillcolor=gray, fontcolor=black]
    1 -> 0 [ label="required" arrowhead=box, arrowtail=box]
    2 -> 1 [ label="required" arrowhead=box, arrowtail=box]
    2 -> 0 [ label="required" arrowhead=box, arrowtail=box]
}
```

---

## task

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon task ` (or `moon t`) command will display information about a task that has been
configured and exists within a project. If a task does not exist, the program will return with a 1
exit code.

```shell
$ moon task web:build
```

### Arguments

- `` - Fully qualified project + task target.

### Options

- `--json` - Print the task and its configuration as JSON.

## Example output

The following output is an example of what this command prints, using our very own
`@moonrepo/runtime` package.

```
RUNTIME:BUILD

Task: build
Project: runtime
Platform: node
Type: build

PROCESS

Command: packemon build --addFiles --addExports --declaration
Environment variables:
  - NODE_ENV = production
Working directory: ~/Projects/moon/packages/runtime
Runs dependencies: Concurrently
Runs in CI: Yes

DEPENDS ON

  - types:build

INHERITS FROM

  - .moon/tasks/node.yml

INPUTS

  - .moon/*.yml
  - .moon/tasks/node.yml
  - packages/runtime/package.json
  - packages/runtime/src/**/*
  - packages/runtime/tsconfig.*.json
  - packages/runtime/tsconfig.json
  - packages/runtime/types/**/*
  - tsconfig.options.json

OUTPUTS

  - packages/runtime/cjs
```

### Configuration

- [`tasks`](../config/tasks#tasks) in `.moon/tasks.yml`
- [`tasks`](../config/project#tasks) in `moon.yml`

---

## teardown

The `moon teardown` command, as its name infers, will teardown and clean the current environment,
opposite the [`setup`](./setup) command. It achieves this by doing the following:

- Uninstalling all configured tools in the toolchain.
- Removing any download or temporary files/folders.

```shell
$ moon teardown
```

### Configuration

- [`*`](../config/toolchain) in `.moon/toolchain.yml`

---

## templates

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon templates` command will list all templates available for [code generation](./generate).
This list will include the template title, description, default destination, where it's source files
are located, and more.

```shell
$ moon templates
```

### Options

- `--json` - Print templates in JSON format.

### Configuration

- [`generator`](../config/workspace#generator) in `.moon/workspace.yml`

---

## toolchain add

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon toolchain add  [plugin]` command will add a toolchain to the workspace by injecting a
configuration block into `.moon/toolchain.yml`. To do this, the command will download the WASM
plugin, extract information, and call initialize functions.

For built-in toolchains, the [plugin locator][locator] argument is optional, and will be derived
from the identifier.

```shell
$ moon toolchain add typescript
```

For third-party toolchains, the [plugin locator][locator] argument is required, and must point to
the WASM plugin.

```shell
$ moon toolchain add custom https://example.com/path/to/plugin.wasm
```

### Arguments

- `` - ID of the toolchain to use.
- `[plugin]` - Optional [plugin locator][locator] for third-party toolchains.

### Options

- `--minimal` - Generate minimal configurations and sane defaults.
- `--yes` - Skip all prompts and enables tools based on file detection.

[locator]: ../../guides/wasm-plugins#configuring-plugin-locations

---

## toolchain info

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon toolchain info  [plugin]` command will display detailed information about a toolchain,
like what files are scanned, what configuration settings are available, and what tier APIs are
supported. To do this, the command will download the WASM plugin, extract information, and call
specific functions.

For built-in toolchains, the [plugin locator][locator] argument is optional, and will be derived
from the identifier.

```shell
$ moon toolchain info typescript
```

For third-party toolchains, the [plugin locator][locator] argument is required, and must point to
the WASM plugin.

```shell
$ moon toolchain info custom https://example.com/path/to/plugin.wasm
```

### Arguments

- `` - ID of the toolchain to view.
- `[plugin]` - Optional [plugin locator][locator] for third-party toolchains.

## Example output

```
Toolchain ─────────────────────────────────────────────────────────────────

  Provides sync operations that keep tsconfig.json's in a healthy state.

  ID: typescript
  Name: TypeScript
  Version: 0.2.0

Configuration ─────────────────────────────────────────────────────────────

  createMissingConfig: bool
  When `syncProjectReferences` is enabled, will create a `tsconfig.json`
  in referenced projects if it does not exist.

  includeProjectReferenceSources: bool
  Appends sources of project reference to `include` in `tsconfig.json`,
  for each project.

  includeSharedTypes: bool
  Appends shared types to `include` in `tsconfig.json`, for each project.

  projectConfigFileName: string
  Name of the `tsconfig.json` file within each project.

  root: string
  The relative root to the TypeScript root. Primarily used for
  resolving project references.

  rootConfigFileName: string
  Name of the `tsconfig.json` file at the workspace root.

  rootOptionsConfigFileName: string
  Name of the shared compiler options `tsconfig.json` file
  at the workspace root.

  routeOutDirToCache: bool
  Updates and routes `outDir` in `tsconfig.json` to moon's cache,
  for each project.

  syncProjectReferences: bool
  Syncs all project dependencies as `references` in `tsconfig.json`,
  for each project.

  syncProjectReferencesToPaths: bool
  Syncs all project dependencies as `paths` in `tsconfig.json`,
  for each project.

Tier 1 - Usage detection ──────────────────────────────────────────────────

  Config files: tsconfig.json, tsconfig.*.json, *.tsconfig.json, .tsbuildinfo, *.tsbuildinfo
  Executable names: tsc, tsserver
  APIs:
    🟢 register_toolchain (required)
    🟢 define_toolchain_config
    🟢 initialize_toolchain
    ⚫️ detect_version_files
    ⚫️ parse_version_file
    🟢 define_docker_metadata
    ⚫️ scaffold_docker
    ⚫️ prune_docker
    🟢 sync_project
    ⚫️ sync_workspace

Tier 2 - Platform integration ─────────────────────────────────────────────

  APIs:
    ⚫️ extend_project_graph
    ⚫️ extend_task_command
    ⚫️ extend_task_script
    ⚫️ locate_dependencies_root
    ⚫️ install_dependencies
    🟢 hash_task_contents
    ⚫️ parse_lock
    ⚫️ parse_manifest
    ⚫️ setup_environment

Tier 3 - Tool management ──────────────────────────────────────────────────

  APIs:
    ⚫️ register_tool (required)
    ⚫️ load_versions
    ⚫️ resolve_version
    ⚫️ download_prebuilt (required)
    ⚫️ unpack_archive
    ⚫️ locate_executables (required)
    ⚫️ setup_toolchain
    ⚫️ teardown_toolchain
```

---

## upgrade

The `moon upgrade` command can be used to upgrade your current moon binary (if installed globally)
to the latest version.

```shell
$ moon upgrade
```

:::caution

This command will only work if moon was installed in the `~/.moon` directory, using our official
[installation script](../install). If installed through Node.js, you'll need to upgrade manually.

:::

---

## Feature comparison

import {
  DockerTable,
  GeneratorTable,
  JavaScriptTable,
  OtherSystemsTable,
  ProjectsTable,
  TasksTable,
  TaskRunnerTable,
  ToolchainTable,
  WorkspaceTable,
} from '@site/src/components/ComparisonTable';
import ComparisonColumn from '@site/src/components/ComparisonColumn';

The following comparisons are _not_ an exhaustive list of features, and may be inaccurate or out of
date, but represent a good starting point for investigation. If something is not correct, please
[create an issue](https://github.com/moonrepo/moon/issues) or
[submit a patch](https://github.com/moonrepo/moon/blob/master/website/src/components/ComparisonTable.tsx).

Before diving into our comparisons below, we highly suggest reading
[monorepo.tools](https://monorepo.tools/) for a deeper insight into monorepos and available tooling.
It's a great resource for learning about the current state of things and the ecosystem.

:::info

Looking to migrate from Nx or Turborepo to moon? Use our
[`moon ext migrate-nx`](./guides/extensions#migrate-nx) or
[`moon ext migrate-turborepo`](./guides/extensions#migrate-turborepo) commands for a (somewhat)
seamless migration!

:::

## Unique features

Although moon is still in its infancy, we provide an array of powerful features that other frontend
centric task runners do not, such as...

- **[Integrated toolchain](./concepts/toolchain)** - moon manages its own version of programming
  languages and dependency managers behind the scenes, so that every task is executed with the
  _exact same version_, across _all machines_.
- **[Task inheritance](./concepts/task-inheritance)** - Instead of defining the same tasks (lint,
  test, etc) over and over again for _every_ project in the monorepo, moon supports a task
  inheritance model where it only needs to be defined once at the top-level. Projects can then merge
  with, exclude, or override if need be.
- **[Continuous integration](./guides/ci)** - By default, all moon tasks will run in CI, as we want
  to encourage every facet of a project or repository to be continually tested and verified. This
  can be turned off on a per-task basis.

Curious to learn more? Check out the "[Why use moon?](.)" or "[Features](.)" sections for more
information, or these wonderful articles provided by the community:

- [A review of moon + Packemon](https://azu.github.io/slide/2022/moa/moon-packemon.html) by
  [azu](https://twitter.com/azu_re)
- [Improve repo management with moon](https://blog.logrocket.com/improve-repo-management-moon/) by
  [James Sinkala](https://jamesinkala.com/)

## Comparison

### Turborepo

At a high-level, Turborepo and moon seem very similar as they both claim to be task runners. They
both support incremental builds, content/smart hashing, local and remote caching1,
parallel execution, and everything else you'd expect from a task runner. But that's where the
similarities stop, because in the end, Turborepo is nothing more than a `package.json` scripts
orchestrator with a caching layer. While moon also supports this, it
[aims to be far more](#unique-features) with a heavy focus on the developer experience.

In the next section, we'll be talking about a few key areas that we deem important to consumers. If
you'd prefer a more granular comparison, jump down to the [comparison tables](#comparison-tables).

#### Configuration

Turborepo only supports the Node.js ecosystem, so implicitly uses a conventions based approach. It
provides very little to no configuration for customizing Turborepo to your needs.

  
}
right={
  

moon is language agnostic, with initial support for Node.js and its ecosystem. Because of this, moon
provides a ton of configuration for customizing moon to your needs. It prefers a configuration over
conventions approach, as every repository is different.

  
}
/>

#### Projects

Turborepo infers projects from `package.json` workspaces, and does not support non-JavaScript based
projects.

  
}
right={
  

moon requires projects to be defined in `.moon/workspace.yml`, and supports any programming
language2.

  
}
/>

#### Tasks

Turborepo requires `package.json` scripts to be defined for every project. This results in the same
scripts being repeated constantly.

  
}
right={
  

moon avoids this overhead by using [task inheritance](#unique-features). No more repetition.

  
}
/>

#### CI

Each pipeline in `turbo.json` must be individually ran as a step in CI. Scripts not configured as
pipeline tasks are never ran.

  
}
right={
  

moon runs every task automatically using `moon ci`, which also supports parallelism/sharding.

  
}
/>

#### Long-term

Turborepo is in the process of being rewritten in Rust, with its codebase being shared and coupled
with the new Turbopack library, a Rust based bundler.

Outside of this, there are no publicly available plans for Turborepo's future.

  
}
right={
  

moon plans to be so much more than a task runner, with one such facet being a repository management
tool. This includes code ownership, dependency management and auditing, repository linting, in-repo
secrets, and anything else we deem viable.

We also plan to support additional languages as first-class citizens within our toolchain.

  
}
/>

1. Turborepo remote caching is powered by Vercel. moon provides its own paid service.

2. moon projects may run commands for any language, but not all languages are supported in the
   toolchain.

### Lerna

Lerna was a fantastic tool that helped the JavaScript ecosystem grow and excelled at package
versioning and publishing (and still does), but it offered a very rudimentary task runner. While
Lerna was able to run scripts in parallel, it wasn't the most efficient, as it did not support
caching, hashing, or performant scheduling.

However, the reason Lerna is not compared in-depth, is that Lerna was unowned and unmaintained for
quite some time, and has recently fallen under the Nx umbrella. Lerna is basically Nx lite now.

## Comparison tables

  
    🟩 Supported
    🟨 Partially supported
    🟦 Similarly supported
    🟥 Not supported
  

### Workspace

### Toolchain

### Projects

### Tasks

### Task runner

### Generator

### Other systems

### JavaScript ecosystem

### Docker integration

---

## Cache

moon's able to achieve high performance and blazing speeds by implementing a cache that's powered by
our own unique smart hashing layer. All cache is stored in `.moon/cache`, relative from the
workspace root (be sure to git ignore this folder).

## Hashing

Incremental builds are possible through a concept known as hashing, where in multiple sources are
aggregated to generate a unique hash. In the context of moon, each time a target is ran we generate
a hash, and if this hash already exists we abort early (cache hit), otherwise we continue the run
(cache miss).

The tiniest change may trigger a different hash, for example, changing a line of code (when an
input), or updating a package version, so don't worry if you see _a lot_ of hashes.

Our smart hashing currently takes the following sources into account:

- Command (`command`) being ran and its arguments (`args`).
- Input sources (`inputs`).
- Output targets (`outputs`).
- Environment variables (`env`).
- Dependencies between projects (`dependsOn`) and tasks (`deps`).
- **For Deno tasks**:
  - Deno version.
  - `deno.json`/`deps.ts` imports, import maps, and scopes.
  - `tsconfig.json` compiler options (when applicable).
- **For Bun and Node.js tasks**:
  - Bun/Node.js version.
  - `package.json` dependencies (including development and peer).
  - `tsconfig.json` compiler options (when applicable).

:::caution

Be aware that greedy inputs (`**/*`, the default) will include _everything_ in the target directory
as a source. We do our best to filter out VCS ignored files, and `outputs` for the current task, but
files may slip through that you don't expect. We suggest using explicit `inputs` and routinely
auditing the hash files for accuracy!

:::

## Archiving & hydration

On top of our hashing layer, we have another concept known as archiving, where in we create a
tarball archive of a task's outputs and store it in `.moon/cache/outputs`. These are akin to build
artifacts.

When we encounter a cache hit on a hash, we trigger a mechanism known as hydration, where we
efficiently unpack an existing tarball archive into a task's outputs. This can be understood as a
timeline, where every point in time will have its own hash + archive that moon can play back.

Furthermore, if we receive a cache hit on the hash, and the hash is the same as the last run, and
outputs exist, we exit early without hydrating and assume the project is already hydrated. In the
terminal, you'll see a message for "cached".

## File structure

The following diagram outlines our cache folder structure and why each piece exists.

```shell
.moon/cache/
	# Stores hash manifests of every ran task. Exists purely for debugging purposes.
	hashes/
		# Contents includes all sources used to generate the hash.
		.json

	# Stores `tar.gz` archives of a task's outputs based on its generated hash.
	outputs/
		.tar.gz

	# State information about anything and everything within moon. Toolchain,
	# dependencies, projects, running targets, etc.
	states/
		# Files at the root pertain to the entire workspace.
		.json

		# Files for a project are nested within a folder by the project name.
		/
			# Informational snapshot of the project, its tasks, and its configs.
			# Can be used at runtime by tasks that require this information.
			snapshot.json

			/
				# Contents of the child process, including the exit code and
				# unique hash that is referenced above.
				lastRun.json

				# Outputs of last run target.
				stderr.log
				stdout.log
```

---

## File groups

File groups are a mechanism for grouping similar types of files and environment variables within a
project using [file glob patterns or literal file paths](./file-pattern). These groups are then used
by [tasks](./task) to calculate functionality like cache computation, affected files since last
change, deterministic builds, and more.

## Configuration

File groups can be configured per project through [`moon.yml`](../config/project), or for many
projects through [`.moon/tasks.yml`](../config/tasks).

### Token functions

File groups can be referenced in [tasks](./task) using [token functions](./token). For example, the
`@group(name)` token will expand to all paths configured in the `sources` file group.

```yaml title="moon.yml"
tasks:
  build:
    command: 'vite build'
    inputs:
      - '@group(sources)'
```

## Inheritance and merging

When a file group of the same name exists in both [configuration files](#configuration), the
project-level group will override the workspace-level group, and all other workspace-level groups
will be inherited as-is.

A primary scenario in which to define file groups at the project-level is when you want to
_override_ file groups defined at the workspace-level. For example, say we want to override the
`sources` file group because our source folder is named "lib" and not "src", we would define our
file groups as followed.

```yaml title=".moon/tasks.yml"
fileGroups:
  sources:
    - 'src/**/*'
    - 'types/**/*'
  tests:
    - 'tests/**/*.test.*'
    - '**/__tests__/**/*'
```

```yaml title="moon.yml"
fileGroups:
  # Overrides global
  sources:
    - 'lib/**/*'
    - 'types/**/*'
  # Inherited as-is
  tests:
    - 'tests/**/*.test.*'
    - '**/__tests__/**/*'
```

---

## File patterns

## Globs

Globs in moon are [Rust-based globs](https://github.com/olson-sean-k/wax), _not_ JavaScript-based.
This may result in different or unexpected results. The following guidelines must be met when using
globs:

- Must use forward slashes (`/`) for path separators, even on Windows.
- Must _not_ start with or use any relative path parts, `.` or `..`.

### Supported syntax

- `*` - Matches zero or more characters, but does not match the `/` character. Will attempt to match
  the longest possible text (eager).
- `$` - Like `*`, but will attempt to match the shortest possible text (lazy).
- `**` - Matches zero or more directories.
- `?` - Matches exactly one character, but not `/`.
- `[abc]` - Matches one case-sensitive character listed in the brackets.
- `[!xyz]` - Like the above, but will match any character _not_ listed.
- `[a-z]` - Matches one case-sensitive character in range in the brackets.
- `[!x-z]` - Like the above, but will match any character _not_ in range.
- `{glob,glob}` - Matches one or more comma separated list of sub-glob patterns.
- `` - Matches a sub-glob within a defined bounds.
- `!` - At the start of a pattern, will negate previous positive patterns.

### Examples

```bash
README.{md,mdx,txt}
src/**/*
tests/**/*.?js
!**/__tests__/**/*
logs/--.log
```

## Project relative

When configuring [`fileGroups`](../config/project#filegroups), [`inputs`](../config/project#inputs),
and [`outputs`](../config/project#outputs), all listed file paths and globs are relative from the
project root they will be ran in. They _must not_ traverse upwards with `..`.

```bash
# Valid
src/**/*
./src/**/*
package.json

# Invalid
../utils
```

## Workspace relative

When configuring [`fileGroups`](../config/project#filegroups), [`inputs`](../config/project#inputs),
and [`outputs`](../config/project#outputs), a listed file path or glob can be prefixed with `/` to
resolve relative from the workspace root, and _not_ the project root.

```bash
# In project
package.json

# In workspace
/package.json
```

---

## Projects

A project is a library, application, package, binary, tool, etc, that contains source files, test
files, assets, resources, and more. A project must exist and be configured within a
[workspace](./workspace).

## IDs

A project identifier (or name) is a unique resource for locating a project. The ID is explicitly
configured within [`.moon/workspace.yml`](../config/workspace), as a key within the
[`projects`](../config/workspace#projects) setting, and can be written in camel/kebab/snake case.
IDs support alphabetic unicode characters, `0-9`, `_`, `-`, `/`, `.`, and must start with a
character.

IDs are used heavily by configuration and the command line to link and reference everything. They're
also a much easier concept for remembering projects than file system paths, and they typically can
be written with less key strokes.

Lastly, a project ID can be paired with a task ID to create a [target](./target).

## Aliases

Aliases are a secondary approach for naming projects, and can be used as a drop-in replacement for
standard names. What this means is that an alias can also be used when configuring dependencies, or
defining [targets](./target).

However, the difference between aliases and names is that aliases _can not_ be explicit configured
in moon. Instead, they are specific to a project's primary programming language, and are inferred
based on that context (when enabled in settings). For example, a JavaScript or TypeScript project
will use the `name` field from its `package.json` as the alias.

Because of this, a project can either be referenced by its name or alias, or both. Choose the
pattern that makes the most sense for your company or team!

## Dependencies

Projects can depend on other projects within the [workspace](./workspace) to build a
[project graph](../how-it-works/action-graph), and in turn, an action graph for executing
[tasks](./task). Project dependencies are divided into 2 categories:

- **Explicit dependencies** - These are dependencies that are explicitly defined in a project's
  [`moon.yml`](../config/project) config file, using the [`dependsOn`](../config/project#dependson)
  setting.
- **Implicit dependencies** - These are dependencies that are implicitly discovered by moon when
  scanning the repository. How an implicit dependency is discovered is based on the project's
  [`language`](../config/project#language) setting, and how that language's ecosystem functions.

## Configuration

Projects can be configured with an optional [`moon.yml`](../config/project) in the project root, or
through the optional workspace-level [`.moon/tasks.yml`](../config/tasks).

---

## Query language

import VersionLabel from '@site/src/components/Docs/VersionLabel';

moon supports an integrated query language, known as MQL, that can be used to filter and select
projects from the project graph, using an SQL-like syntax. MQL is primarily used by
[`moon run`](../commands/run) with the `--query` option.

## Syntax

### Comparisons

A comparison (also known as an assignment) is an expression that defines a piece of criteria, and is
a building block of a query. This criteria maps a [field](#fields) to a value, with an explicit
comparison operator.

#### Equals, Not equals

The equals (`=`) and not equals (`!=`) comparison operators can be used for _exact_ value matching.

```
projectType=library && language!=javascript
```

You can also define a list of values using square bracket syntax, that will match against one of the
values.

```
language=[javascript, typescript]
```

#### Like, Not like

The like (`~`) and not like (`!~`) comparison operators can be used for _wildcard_ value matching,
using [glob syntax](./file-pattern#globs).

```
projectSource~packages/* && tag!~*-app
```

> Like comparisons can only be used on non-enum fields.

### Conditions

The `&&` and `||` logical operators can be used to combine multiple comparisons into a condition.
The `&&` operator is used to combine comparisons into a logical AND, and the `||` operator is used
for logical OR.

```
taskToolchain=system || taskToolchain=node
```

For readability concerns, you can also use `AND` or `OR`.

```
taskToolchain=system OR taskToolchain=node
```

> Mixing both operators in the same condition is not supported.

### Grouping

For advanced queries and complex conditions, you can group comparisons using parentheses to create
logical groupings. Groups can also be nested within other groups.

```
language=javascript && (taskType=test || taskType=build)
```

## Fields

The following fields can be used as criteria, and are related to [task tokens](./token#variables).

### `language`

Programming language the project is written in, as defined in
[`moon.yml`](../config/project#language).

```
language=rust
```

### `project`

Name OR alias of the project.

```
project=server
```

### `projectAlias`

Alias of the project. For example, the `package.json` name.

```
projectAlias~@scope/*
```

### `projectLayer`

The project layer, as defined in [`moon.yml`](../config/project#layer).

```
projectLayer=application
```

### `projectName`

Name of the project, as defined in [`.moon/workspace.yml`](../config/workspace), or `id` in
[`moon.yml`](../config/project#id).

```
project=server
```

### `projectSource`

Relative file path from the workspace root to the project root, as defined in
[`.moon/workspace.yml`](../config/workspace).

```
projectSource~packages/*
```

### `projectStack`

The project stack, as defined in [`moon.yml`](../config/project#stack).

```
projectStack=frontend
```

### `projectType`

> This field is deprecated, use `projectLayer` instead.

The type of project, as defined in [`moon.yml`](../config/project#layer).

```
projectType=application
```

### `tag`

A tag within the project, as defined in [`moon.yml`](../config/project#tags).

```
tag~react-*
```

### `task`

ID/name of a task within the project.

```
task=[build,test]
```

### `taskToolchain`

The toolchain a task will run against, as defined in [`moon.yml`](../config/project).

```
taskToolchain=node
```

### `taskType`

The [type of task](./task#types), based on its configured settings.

```
taskType=build
```

---

## Targets

import VersionLabel from '@site/src/components/Docs/VersionLabel';

A target is a compound identifier that pairs a [scope](#common-scopes) to a [task](./task),
separated by a `:`, in the format of `scope:task`.

Targets are used by terminal commands...

```shell
$ moon run designSystem:build
```

And configurations for declaring cross-project or cross-task dependencies.

```yaml
tasks:
  build:
    command: 'webpack'
    deps:
      - 'designSystem:build'
```

## Common scopes

These scopes are available for both running targets and configuring them.

### By project

The most common scope is the project scope, which requires the name of a project, as defined in
[`.moon/workspace.yml`](../config/workspace). When paired with a task name, it will run a specific
task from that project.

```shell
# Run `lint` in project `app`
$ moon run app:lint
```

### By tag

Another way to target projects is with the tag scope, which requires the name of a tag prefixed with
`#`, and will run a specific task in all projects with that tag.

```shell
# Run `lint` in projects with the tag `frontend`
$ moon run '#frontend:lint'
```

:::caution

Because `#` is a special character in the terminal (is considered a comment), you'll need to wrap
the target in quotes, or escape it like so `\#`.

:::

## Run scopes

These scopes are only available on the command line when running tasks with `moon run` or `moon ci`.

### All projects

For situations where you want to run a specific target in _all_ projects, for example `lint`ing, you
can utilize the all projects scope by omitting the project name from the target: `:lint`.

```shell
# Run `lint` in all projects
$ moon run :lint
```

### Closest project `~`

If you are within a project folder, or an arbitrarily nested folder, and want to run a task in the
closest project (traversing upwards), the `~` scope can be used.

```shell
# Run `lint` in the closest project
$ moon run ~:lint
```

## Config scopes

These scopes are only available when configuring a task.

### Dependencies `^`

When you want to include a reference for each project [that's depended on](./project#dependencies),
you can utilize the `^` scope. This will be expanded to _all_ depended on projects. If you do not
want all projects, then you'll need to explicitly define them.

```yaml title="moon.yml"
dependsOn:
  - 'apiClients'
  - 'designSystem'

# Configured as
tasks:
  build:
    command: 'webpack'
    deps:
      - '^:build'

# Resolves to
tasks:
  build:
    command: 'webpack'
    deps:
      - 'apiClients:build'
      - 'designSystem:build'
```

### Self `~`

When referring to another task within the current project, you can utilize the `~` scope, or emit
the `~:` prefix altogether, which will be expanded to the current project's name. This is useful for
situations where the name is unknown, for example, when configuring
[`.moon/tasks.yml`](../config/tasks), or if you just want a shortcut!

```yaml title=".moon/tasks.yml"
# Configured as
tasks:
  lint:
    command: 'eslint'
    deps:
      - '~:typecheck'
      # OR
      - 'typecheck'
  typecheck:
    command: 'tsc'

# Resolves to (assuming project is "foo")
tasks:
  lint:
    command: 'eslint'
    deps:
      - 'foo:typecheck'
  typecheck:
    command: 'tsc'
```

---

## Task inheritance

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Unlike other task runners that require the same tasks to be repeatedly defined for _every_ project,
moon uses an inheritance model where tasks can be defined once at the workspace-level, and are then
inherited by _many or all_ projects.

Workspace-level tasks (also known as global tasks) are defined in [`.moon/tasks.yml`][tasks] or
[`.moon/tasks/**/*.yml`][tasks], and are inherited by default. However, projects are able to
include, exclude, or rename inherited tasks using the
[`workspace.inheritedTasks`](../config/project#inheritedtasks) in [`moon.yml`](../config/project).

## Scope by project metadata

By default tasks defined in [`.moon/tasks.yml`][tasks] will be inherited by _all_ projects. This
approach works well when a monorepo is comprised of a single programming language, but breaks down
quickly in multi-language setups.

To support these complex repositories, we support scoped tasks with [`.moon/tasks/**/*.yml`][tasks],
where `*.yml` maps to a project based on a combination of its [language][language], [stack][stack],
[layer][layer], or [tags][tags]. This enables you to easily declare tasks for "JavaScript projects",
"Go applications", "Ruby libraries", so on and so forth.

When resolving configuration files, moon will locate and _shallow_ merge files in the following
order, from widest scope to narrowest scope:

- `.moon/tasks.yml` - All projects.
- `.moon/tasks/.yml` - Projects with a matching [`language`][language] setting.
- `.moon/tasks/.yml` - Projects with a matching [`stack`][stack] setting.
  
- `.moon/tasks/-.yml` - Projects with a matching [`language`][language] and
  [`stack`][stack] settings. 
- `.moon/tasks/-.yml` - Projects with matching [`stack`][stack] and [`layer`][layer]
  settings. 
- `.moon/tasks/-.yml` - Projects with matching [`language`][language] and
  [`layer`][layer] settings.
- `.moon/tasks/--.yml` - Projects with matching [`language`][language],
  [`stack`][stack], and [`layer`][layer] settings. 
- `.moon/tasks/tag-.yml` - Projects with a matching [`tag`][tags].
  

As mentioned above, all of these files are shallow merged into a single "global tasks" configuration
that is unique per-project. Merging **does not** utilize the [merge strategies](#merge-strategies)
below, as those strategies are only utilized when merging global and local tasks.

> Tags are resolved in the order they are defined in `moon.yml` `tags` setting.

### JavaScript runtimes

Unlike most languages that have 1 runtime, JavaScript has 3 (Node.js, Deno, Bun), and we must
support repositories that are comprised of any combination of these 3. As such, JavaScript (and
TypeScript) based projects have the following additional lookups using
[`toolchain`](../config/project#toolchain) to account for this:

- `.moon/tasks/.yml`
- `.moon/tasks/-.yml`
- `.moon/tasks/-.yml`
- `.moon/tasks/--.yml`

For example, `node.yml` would be inherited for Node.js projects, `bun-library.yml` for Bun
libraries, and `deno-application.yml` for Deno applications. While `javascript.yml`,
`typescript-library.yml`, etc, will be inherited for all toolchains.

## Merge strategies

When a [global task](../config/tasks#tasks) and [local task](../config/project#tasks) of the same
name exist, they are merged into a single task. To accomplish this, one of many
[merge strategies](../config/project#options) can be used.

Merging is applied to the parameters [`args`](../config/project#args),
[`deps`](../config/project#deps), [`env`](../config/project#env-1),
[`inputs`](../config/project#inputs), and [`outputs`](../config/project#outputs), using the
[`merge`](../config/project#merge), [`mergeArgs`](../config/project#mergeargs),
[`mergeDeps`](../config/project#mergedeps), [`mergeEnv`](../config/project#mergeenv),
[`mergeInputs`](../config/project#mergeinputs) and [`mergeOutputs`](../config/project#mergeoutputs)
options respectively. Each of these options support one of the following strategy values.

- `append` (default) - Values found in the local task are merged _after_ the values found in the
  global task. For example, this strategy is useful for toggling flag arguments.
- `prepend` - Values found in the local task are merged _before_ the values found in the global
  task. For example, this strategy is useful for applying option arguments that must come before
  positional arguments.
- `preserve` - Preserve the original global task values. This should rarely be used, but exists for
  situations where an inheritance chain is super long and complex, but we simply want to the base
  values. 
- `replace` - Values found in the local task entirely _replaces_ the values in the global task. This
  strategy is useful when you need full control.

All 3 of these strategies are demonstrated below, with a somewhat contrived example, but you get the
point.

```yaml
# Global
tasks:
  build:
    command:
      - 'webpack'
      - '--mode'
      - 'production'
      - '--color'
    deps:
      - 'designSystem:build'
    inputs:
      - '/webpack.config.js'
    outputs:
      - 'build/'

# Local
tasks:
  build:
    args: '--no-color --no-stats'
    deps:
      - 'reactHooks:build'
    inputs:
      - 'webpack.config.js'
    options:
      mergeArgs: 'append'
      mergeDeps: 'prepend'
      mergeInputs: 'replace'

# Merged result
tasks:
  build:
    command:
      - 'webpack'
      - '--mode'
      - 'production'
      - '--color'
      - '--no-color'
      - '--no-stats'
    deps:
      - 'reactHooks:build'
      - 'designSystem:build'
    inputs:
      - 'webpack.config.js'
    outputs:
      - 'build/'
    options:
      mergeArgs: 'append'
      mergeDeps: 'prepend'
      mergeInputs: 'replace'
```

[tags]: ../config/project#tags
[tasks]: ../config/tasks
[language]: ../config/project#language
[stack]: ../config/project#stack
[layer]: ../config/project#layer

---

## Tasks

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Tasks are commands that are ran in the context of a [project](./project). Underneath the hood, a
task is simply a binary or system command that is ran as a child process.

## IDs

A task identifier (or name) is a unique resource for locating a task _within_ a project. The ID is
explicitly configured as a key within the [`tasks`](../config/project#tasks) setting, and can be
written in camel/kebab/snake case. IDs support alphabetic unicode characters, `0-9`, `_`, `-`, `/`,
`.`, and must start with a character.

A task ID can be paired with a scope to create a [target](./target).

## Types

Tasks are grouped into 1 of the following types based on their configured parameters.

- **Build** - Task generates one or many artifacts, and is derived from the
  [`outputs`](../config/project#outputs) setting.
- **Run** - Task runs a one-off, long-running, or never-ending process, and is derived from the
  [`local`](../config/project#local) setting.
- **Test** - Task asserts code is correct and behaves as expected. This includes linting,
  typechecking, unit tests, and any other form of testing. Is the default.

## Modes

Alongside types, tasks can also grouped into a special mode that provides unique handling within the
action graph and pipelines.

### Local only

Tasks either run locally, in CI (continuous integration pipelines), or both. For tasks that should
_only_ be ran locally, for example, development servers and watchers, we provide a mechanism for
marking a task as local only. When enabled, caching is turned off, the task will not run in CI,
terminal output is not captured, and the task is marked as [persistent](#persistent).

To mark a task as local only, enable the [`local`](../config/project#local) setting.

```yaml title="moon.yml"
tasks:
  dev:
    command: 'start-dev-server'
    local: true
```

### Internal only

Internal tasks are tasks that are not meant to be ran explicitly by the user (via
[`moon check`](../commands/check) or [`moon run`](../commands/run)), but are used internally as
dependencies of other tasks. Additionally, internal tasks are not displayed in a project's tasks
list, but can be inspected with [`moon task`](../commands/task).

To mark a task as internal, enable the [`options.internal`](../config/project#internal) setting.

```yaml title="moon.yml"
tasks:
  prepare:
    command: 'intermediate-step'
    options:
      internal: true
```

### Interactive

Tasks that need to interact with the user via terminal prompts are known as interactive tasks.
Because interactive tasks require stdin, and it's not possible to have multiple parallel running
tasks interact with stdin, we isolate interactive tasks from other tasks in the action graph. This
ensures that only 1 interactive task is ran at a time.

To mark a task as interactive, enable the [`options.interactive`](../config/project#interactive)
setting.

```yaml title="moon.yml"
tasks:
  init:
    command: 'init-app'
    options:
      interactive: true
```

### Persistent

Tasks that never complete, like servers and watchers, are known as persistent tasks. Persistent
tasks are typically problematic when it comes to dependency graphs, because if they run in the
middle of the graph, subsequent tasks will never run because the persistent task never completes!

However in moon, this is a non-issue, as we collect all persistent tasks within the action graph and
run them _last as a batch_. This is perfect for a few reasons:

- All persistent tasks are ran in parallel, so they don't block each other.
- Running both the backend API and frontend webapp in parallel is a breeze.
- Dependencies of persistent tasks are guaranteed to have ran and completed.

To mark a task as persistent, enable the [`local`](../config/project#local) or
[`options.persistent`](../config/project#persistent) settings.

```yaml title="moon.yml"
tasks:
  dev:
    command: 'start-dev-server'
    local: true
    # OR
    options:
      persistent: true
```

## Configuration

Tasks can be configured per project through [`moon.yml`](../config/project), or for many projects
through [`.moon/tasks.yml`](../config/tasks).

### Commands vs Scripts

A task is either a command or script, but not both. So what's the difference exactly? In the context
of a moon task, a command is a single binary execution with optional arguments, configured with the
[`command`](../config/project#command) and [`args`](../config/project#args) settings (which both
support a string or array). While a script is one or many binary executions, with support for pipes
and redirects, and configured with the [`script`](../config/project#script) setting (which is only a
string).

A command also supports merging during task inheritance, while a script does not and will always
replace values. Refer to the table below for more differences between the 2.

|                                          | Command                   | Script             |
| :--------------------------------------- | :------------------------ | :----------------- |
| Configured as                            | string, array             | string             |
| Inheritance merging                      | ✅ via `mergeArgs` option | ⚠️ always replaces |
| Additional args                          | ✅ via `args` setting     | ❌                 |
| Passthrough args (from CLI)              | ✅                        | ❌                 |
| Multiple commands (with `&&` or `;`)     | ❌                        | ✅                 |
| Pipes, redirects, etc                    | ❌                        | ✅                 |
| Always ran in a shell                    | ❌                        | ✅                 |
| Custom platform/toolchain                | ✅                        | ✅                 |
| [Token](./token) functions and variables | ✅                        | ✅                 |

### Inheritance

View the official documentation on [task inheritance](./task-inheritance).

---

## Tokens

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Tokens are variables and functions that can be used by [`command`](../config/project#command),
[`args`](../config/project#args), [`env`](../config/project#env) (>= v1.12),
[`inputs`](../config/project#inputs), and [`outputs`](../config/project#outputs) when configuring a
task. They provide a way of accessing file group paths, referencing values from other task fields,
and referencing metadata about the project and task itself.

## Functions

A token function is labeled as such as it takes a single argument, starts with an `@`, and is
formatted as `@name(arg)`. The following token functions are available, grouped by their
functionality.

:::caution

Token functions _must_ be the only content within a value, as they expand to multiple files. When
used in an `env` value, multiple files are joined with a comma (`,`).

:::

### File groups

These functions reference file groups by name, where the name is passed as the argument.

### `@group`

> Usable in `args`, `env`, `inputs`, and `outputs`.

The `@group(file_group)` token is a standard token that will be replaced with the file group items
as-is, for both file paths and globs. This token merely exists for reusability purposes.

```yaml
fileGroups:
  storybook:
    - '.storybook/**/*'
    - 'src/**/*'
    - '**/*.stories.*'

# Configured as
tasks:
  build:
    command: 'build-storybook'
    inputs:
      - '@group(storybook)'
  start:
    command: 'start-storybook'
    inputs:
      - '@group(storybook)'

# Resolves to
tasks:
  build:
    command: 'build-storybook'
    inputs:
      - '/path/to/project/.storybook/**/*'
      - '/path/to/project/src/**/*'
  start:
    command: 'start-storybook'
    inputs:
      - '/path/to/project/.storybook/**/*'
      - '/path/to/project/src/**/*'
```

### `@dirs`

> Usable in `args`, `env`, `inputs`, and `outputs`.

The `@dirs(file_group)` token will be replaced with an expanded list of directory paths, derived
from the file group of the same name. If a glob pattern is detected within the file group, it will
aggregate all directories found.

:::warning

This token walks the file system to verify each directory exists, and filters out those that don't.
If using within `outputs`, you're better off using [`@group`](#group) instead.

:::

```yaml
fileGroups:
  lintable:
    - 'src'
    - 'tests'
    - 'scripts'
    - '*.config.js'

# Configured as
tasks:
  lint:
    command: 'eslint @dirs(lintable) --color'
    inputs:
      - '@dirs(lintable)'

# Resolves to
tasks:
  lint:
    command:
      - 'eslint'
      - 'src'
      - 'tests'
      - 'scripts'
      - '--color'
    inputs:
      - '/path/to/project/src'
      - '/path/to/project/tests'
      - '/path/to/project/scripts'
```

### `@files`

> Usable in `args`, `env`, `inputs`, and `outputs`.

The `@files(file_group)` token will be replaced with an expanded list of file paths, derived from
the file group of the same name. If a glob pattern is detected within the file group, it will
aggregate all files found.

:::warning

This token walks the file system to verify each file exists, and filters out those that don't. If
using within `outputs`, you're better off using [`@group`](#group) instead.

:::

```yaml
fileGroups:
  config:
    - '*.config.js'
    - 'package.json'

# Configured as
tasks:
  build:
    command: 'webpack build @files(config)'
    inputs:
      - '@files(config)'

# Resolves to
tasks:
  build:
    command:
      - 'webpack'
      - 'build'
      - 'babel.config.js'
      - 'webpack.config.js'
      - 'package.json'
    inputs:
      - '/path/to/project/babel.config.js'
      - '/path/to/project/webpack.config.js'
      - '/path/to/project/package.json'
```

### `@globs`

> Usable in `args`, `env`, `inputs`, and `outputs`.

The `@globs(file_group)` token will be replaced with the list of glob patterns as-is, derived from
the file group of the same name. If a non-glob pattern is detected within the file group, it will be
ignored.

```yaml
fileGroups:
  tests:
    - 'tests/**/*'
    - '**/__tests__/**/*'

# Configured as
tasks:
  test:
    command: 'jest --testMatch @globs(tests)'
    inputs:
      - '@globs(tests)'

# Resolves to
tasks:
  test:
    command:
      - 'jest'
      - '--testMatch'
      - 'tests/**/*'
      - '**/__tests__/**/*'
    inputs:
      - '/path/to/project/tests/**/*'
      - '/path/to/project/**/__tests__/**/*'
```

### `@root`

> Usable in `args`, `env`, `inputs`, and `outputs`.

The `@root(file_group)` token will be replaced with the lowest common directory, derived from the
file group of the same name. If a glob pattern is detected within the file group, it will walk the
file system and aggregate all directories found before reducing.

```yaml
fileGroups:
  sources:
    - 'src/app'
    - 'src/packages'
    - 'src/scripts'

# Configured as
tasks:
  format:
    command: 'prettier --write @root(sources)'
    inputs:
      - '@root(sources)'

# Resolves to
tasks:
  format:
    command:
      - 'prettier'
      - '--write'
      - 'src'
    inputs:
      - '/path/to/project/src'
```

> When there's no directies, or too many directories, this function will return the project root
> using `.`.

### `@envs`

> Usable in `inputs`.

The `@envs(file_group)` token will be replaced with all environment variables that have been
configured in the group of the provided name.

```yaml
fileGroups:
  sources:
    - 'src/**/*'
    - '$NODE_ENV'

# Configured as
tasks:
  build:
    command: 'vite build'
    inputs:
      - '@envs(sources)'

# Resolves to
tasks:
  build:
    command: 'vite build'
    inputs:
      - '$NODE_ENV'
```

### Inputs & outputs

### `@in`

> Usable in `script` and `args` only.

The `@in(index)` token will be replaced with a single path, derived from
[`inputs`](../config/project#inputs) by numerical index. If a glob pattern is referenced by index,
the glob will be used as-is, instead of returning the expanded list of files.

```yaml
# Configured as
tasks:
  build:
    command:
      - 'babel'
      - '--copy-files'
      - '--config-file'
      - '@in(1)'
      - '@in(0)'
    inputs:
      - 'src'
      - 'babel.config.js'

# Resolves to
tasks:
  build:
    command:
      - 'babel'
      - '--copy-files'
      - '--config-file'
      - 'babel.config.js'
      - 'src'
    inputs:
      - '/path/to/project/src'
      - '/path/to/project/babel.config.js'
```

### `@out`

> Usable in `script` and `args` only.

The `@out(index)` token will be replaced with a single path, derived from
[`outputs`](../config/project#outputs) by numerical index.

```yaml
# Configured as
tasks:
  build:
    command:
      - 'babel'
      - '.'
      - '--out-dir'
      - '@out(0)'
    outputs:
      - 'lib'

# Resolves to
tasks:
  build:
    command:
      - 'babel'
      - '.'
      - '--out-dir'
      - 'lib'
    outputs:
      - '/path/to/project/lib'
```

### Miscellaneous

### `@meta`

> Usable in `command`, `script`, `args`, `env`, `inputs`, and `outputs` only.

The `@meta(key)` token can be used to access project metadata and will be replaced with a value
derived from [`project`](../config/project#project) in [`moon.yml`](../config/project).

The top-level fields (like `name` and `description`) will be used as-is (no quotes). If the setting
is not defined, it will default to nothing or an empty string. For lists of values, they will be
joined with `,`.

Custom metadata defined in [`project.metadata`](../config/project#metadata-1) can also be accessed
by key, but will return a JSON stringified value. For example, a custom string value of `example`
will be stringified to `"example"` (with quotes).

```yaml
project:
  name: 'example'
  metadata:
    index: 123

# Configured as
tasks:
  build:
    script: 'build --name @meta(name) --index @meta(index)'

# Resolves to
tasks:
  build:
    script: 'build --name example --index 123'
```

## Variables

A token variable is a value that starts with `$` and is substituted to a value derived from the
current workspace, project, and task. And unlike token functions, token variables can be placed
_within_ content when necessary, and supports multiple variables within the same content.

### Environment

- `$arch` - The current host architecture, derived from the Rust
  [`ARCH` constant](https://doc.rust-lang.org/std/env/consts/constant.ARCH.html).
- `$os` - The current operating system, derived from the Rust
  [`OS` constant](https://doc.rust-lang.org/std/env/consts/constant.OS.html).
- `$osFamily` - The current operating system family, either `unix` or `windows`.

```yaml
# Configured as
tasks:
  build:
    command: 'example --arch $arch'

# Resolves to
tasks:
  build:
    command:
      - 'example'
      - '--arch'
      - 'aarch64'
```

### Workspace

- `$workingDir` - The current working directory.
- `$workspaceRoot` - Absolute file path to the workspace root.

```yaml
# Configured as
tasks:
  build:
    command:
      - 'example'
      - '--cwd'
      - '$workspaceRoot'

# Resolves to
tasks:
  build:
    command:
      - 'example'
      - '--cwd'
      - '/path/to/repo'
```

### Project

Most values are derived from settings in [`moon.yml`](../config/project). When a setting is not
defined, or does not have a config, the variable defaults to "unknown" (for enums) or an empty
string.

- `$language` Programming language the project is written in, as defined with
  [`language`](../config/project#language).
- `$project` - ID of the project that owns the currently running task, as defined in
  [`.moon/workspace.yml`](../config/workspace).
- `$projectAlias` - Alias of the project that owns the currently running task.
- `$projectChannel` - The discussion channel for the project, as defined with
  [`project.channel`](../config/project#channel).
  
- `$projectLayer` - The project layer, as defined with [`layer`](../config/project#layer).
  
- `$projectName` - The human-readable name of the project, as defined with
  [`project.name`](../config/project#name).
  
- `$projectOwner` - The owner of the project, as defined with
  [`project.owner`](../config/project#name).
  
- `$projectRoot` - Absolute file path to the project root.
- `$projectSource` - Relative file path from the workspace root to the project root, as defined in
  [`.moon/workspace.yml`](../config/workspace).
- `$projectStack` - The stack of the project, as defined with [`stack`](../config/project#stack).
  
- `$projectType` - The type of project, as defined with [`type`](../config/project#layer).
  Deprecated, use `$projectLayer` instead.

```yaml
# Configured as
tasks:
  build:
    command: 'example debug $language'

# Resolves to
tasks:
  build:
    command:
      - 'example'
      - 'debug'
      - 'node'
```

### Task

- `$target` - Fully-qualified target that is currently running.
- `$task` - ID of the task that is currently running. Does not include the project ID.
- `$taskToolchain` - The toolchain that task will run against, as defined in
  [`moon.yml`](../config/project). 
- `$taskType` - The [type of task](./task#types), based on its configured settings.

```yaml
# Configured as
tasks:
  build:
    command: 'example $target'

# Resolves to
tasks:
  build:
    command:
      - 'example'
      - 'web:build'
```

### Date/Time

- `$date` - The current date in the format of `YYYY-MM-DD`.
- `$datetime` - The current date and time in the format of `YYYY-MM-DD_HH:MM:SS`.
- `$time` - The current time in the format of `HH:MM:SS`.
- `$timestamp` - The current date and time as a UNIX timestamp in seconds.

```yaml
# Configured as
tasks:
  build:
    command: 'example --date $date'

# Resolves to
tasks:
  build:
    command:
      - 'example'
      - '--date'
      - '2023-03-17'
```

### VCS

- `$vcsBranch` - The current branch.
- `$vcsRepository` - The repository slug, in the format of `owner/repo`.
- `$vcsRevision` - The current revision (commit, etc).

```yaml
# Configured as
tasks:
  build:
    command: 'example --branch $vcsBranch'

# Resolves to
tasks:
  build:
    command:
      - 'example'
      - '--branch'
      - 'master'
```

---

## Toolchain

The toolchain is an internal layer for downloading, installing, and managing tools (languages,
dependency managers, libraries, and binaries) that are required at runtime. We embrace this approach
over relying on these tools "existing" in the current environment, as it ensures the following
across any environment or machine:

- The version and enabled features of a tool are identical.
- Tools are isolated and unaffected by external sources.
- Builds are consistent, reproducible, and _hopefully_ deterministic.

Furthermore, this avoids a developer, pipeline, machine, etc, having to pre-install all the
necessary tools, _and_ to keep them in sync as time passes.

## How it works

The toolchain is built around [proto](/proto), our stand-alone multi-language version manager. moon
will piggyback of proto's toolchain found at `~/.proto` and reuse any tools available, or download
and install them if they're missing.

### Force disabling

The `MOON_TOOLCHAIN_FORCE_GLOBALS` environment variable can be set to `true` to force moon to use
tool binaries available on `PATH`, instead of downloading and installing them. This is useful for
pre-configured environments, like CI and Docker.

```shell
MOON_TOOLCHAIN_FORCE_GLOBALS=true
```

Additionally, the name of one or many tools can be passed to this variable to only force globals for
those tools, and use the toolchain for the remaining tools.

```shell
MOON_TOOLCHAIN_FORCE_GLOBALS=node,yarn
```

## Configuration

The tools that are managed by the toolchain are configured through the
[`.moon/toolchain.yml`](../config/toolchain) file, but can be overridden in each project with
[`moon.yml`](../config/project#toolchain).

### Version specification

As mentioned above, tools within the toolchain are managed _by version_ for consistency across
machines. These versions are configured on a per-tool basis in
[`.moon/toolchain.yml`](../config/toolchain). So what kinds of versions are allowed?

- **Full versions** - A full version is a semantic version that is fully specified, such as `1.2.3`
  or `2.0.0-rc.1`. This is the most common way to specify a version, and is preferred to avoid
  subtle deviations.
- **Partial versions** - A partial version is a version that is either missing a patch number, minor
  number, or both, such as `1.2` or `1`. These can also be represented with requirement syntax, such
  as `^1.2` or `~1`. If using partials, we suggest having a major and minor number to reduce the
  deviation of versions across machines.
- **Aliases** - An alias is a human-readable word that maps to a specific version. For example,
  `latest` or `stable` maps to the latest version of a tool, or `canary` which maps to applicable
  canary release, or even a completely custom alias like `berry`. Aliases are language specific, are
  not managed by moon, and are not suggested for use since they can change at any time (or even
  daily!).

This sounds great, but how exactly does this work? For full versions and aliases, it's straight
forward, as the resolved version is used as-is (assuming it's a legitimate version), and can be
found at `~/.proto/tools//`.

For partial versions, we first check locally installed versions for a match, by scanning
`~/.proto/tools/`. For example, if the requested version is `1.2` and we have `1.2.10`
installed locally, we'll use that version instead of downloading the latest `1.2.*` version.
Otherwise, we'll download the latest version that matches the partial version, and install it
locally.

## Supported tools

The following tools are currently managed by the toolchain.

### Bun

- View the [Bun handbook](../guides/javascript/bun-handbook)
- Configured with: [`bun`](../config/toolchain#bun)
- Installed to: `~/.proto/tools/bun/x.x.x`

### Deno

- View the [Deno handbook](../guides/javascript/deno-handbook)
- Configured with: [`deno`](../config/toolchain#deno)
- Installed to: `~/.proto/tools/deno/x.x.x`

### Go

- Configured with: [`unstable_go`](../config/toolchain#unstable_go)
- Installed to: `~/.proto/tools/go/x.x.x`

### Node.js

- View the [Node.js handbook](../guides/javascript/node-handbook)
- Configured with: [`node`](../config/toolchain#node)
- Installed to: `~/.proto/tools/node/x.x.x`
- Dependency managers: [`npm`][pm], [`pnpm`][pm], [`yarn`][pm], [`bun`][pm]

### Rust

- View the [Rust handbook](../guides/rust/handbook)
- Configured with: [`unstable_rust`](../config/toolchain#unstable_rust)
- Installed to: `~/.rustup/toolchains/x.x.x`

[pm]: ../config/toolchain#npm-pnpm-yarn-bun

---

## Workspace

A workspace is a directory that contains [projects](./project), manages a [toolchain](./toolchain),
runs [tasks](./task), and is coupled with a VCS repository. The root of a workspace is denoted by a
`.moon` folder.

By default moon has been designed for monorepos, but can also be used for polyrepos.

## Configuration

Configuration that's applied to the entire workspace is defined in
[`.moon/workspace.yml`](../config/workspace).

---

## moon.{pkl,yml}

import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';
import RequiredLabel from '@site/src/components/Docs/RequiredLabel';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `moon.yml` configuration file _is not required_ but can be used to define additional metadata
for a project, override inherited tasks, and more at the project-level. When used, this file must
exist in a project's root, as configured in [`projects`](./workspace#projects).

```yaml title="moon.yml"
$schema: 'https://moonrepo.dev/schemas/project.json'
```

:::info

Project configuration can also be written in [Pkl](../guides/pkl-config) instead of YAML.

:::

## `dependsOn`

Explicitly defines _other_ projects that _this_ project depends on, primarily when generating the
project and task graphs. The most common use case for this is building those projects _before_
building this one. When defined, this setting requires an array of project names, which are the keys
found in the [`projects`](./workspace#projects) map.

```yaml title="moon.yml"
dependsOn:
  - 'apiClients'
  - 'designSystem'
```

A dependency object can also be defined, where a specific `scope` can be assigned, which accepts
"production" (default), "development", "build", or "peer".

```yaml title="moon.yml"
dependsOn:
  - id: 'apiClients'
    scope: 'production'
  - id: 'designSystem'
    scope: 'peer'
```

> Learn more about [implicit and explicit dependencies](../concepts/project#dependencies).

## Metadata

## `id`

Overrides the name (identifier) of the project, which was configured in or derived from the
[`projects`](./workspace#projects) setting in [`.moon/workspace.yml`](./workspace). This setting is
useful when using glob based project location, and want to avoid using the folder name as the
project name.

```yaml title="moon.yml"
id: 'custom-id'
```

:::info

All references to the project must use the new identifier, including project and task dependencies.

:::

## `language`

The primary programming language the project is written in. This setting is required for
[task inheritance](./tasks), editor extensions, and more. Supports the following values:

- `bash` - A [Bash]() based project (Unix only).
- `batch` - A [Batch](https://en.wikibooks.org/wiki/Windows_Batch_Scripting)/PowerShell based
  project (Windows only).
- `go` - A [Go](https://go.dev/) based project.
- `javascript` - A [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) based
  project.
- `php` - A [PHP](https://www.php.net) based project.
- `python` - A [Python](https://www.python.org/) based project.
- `ruby` - A [Ruby](https://www.ruby-lang.org/en/) based project.
- `rust` - A [Rust](https://www.rust-lang.org/) based project.
- `typescript` - A [TypeScript](https://www.typescriptlang.org/) based project.
- `unknown` (default) - When not configured or inferred.
- `*` - A custom language. Values will be converted to kebab-case.

```yaml title="moon.yml"
language: 'javascript'

# Custom
language: 'kotlin'
```

> For convenience, when this setting is not defined, moon will attempt to detect the language based
> on configuration files found in the project root. This only applies to non-custom languages!

## `owners`

Defines ownership of source code within the current project, by mapping file system paths to owners.
An owner is either a user, team, or group.

Currently supports
[GitHub](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners),
[GitLab](https://docs.gitlab.com/ee/user/project/codeowners/reference.html), and
[Bitbucket](https://marketplace.atlassian.com/apps/1218598/code-owners-for-bitbucket?tab=overview&hosting=cloud)
(via app).

### `customGroups`

When using the
[Code Owners for Bitbucket](https://marketplace.atlassian.com/apps/1218598/code-owners-for-bitbucket?tab=overview&hosting=cloud)
app, this setting provides a way to define custom groups that will be injected at the top of the
`CODEOWNERS` file. These groups _must_ be unique across all projects.

```yaml title="moon.yml" {2,3}
owners:
  customGroups:
    '@@@backend': ['@"user name"', '@@team']
```

### `defaultOwner`

The default owner for all [`paths`](#paths). This setting is optional in some cases but helps to
avoid unnecessary repetition.

```yaml title="moon.yml" {2}
owners:
  defaultOwner: '@frontend'
```

### `optional`

For GitLab, marks the project's
[code owners section](https://docs.gitlab.com/ee/user/project/codeowners/reference.html#optional-sections)
as optional. Defaults to `false`.

```yaml title="moon.yml" {2}
owners:
  optional: true
```

### `paths`

The primary setting for defining ownership of source code within the current project. This setting
supports 2 formats, the first being a list of file paths relative from the current project. This
format requires [`defaultOwner`](#defaultowner) to be defined, and only supports 1 owner for every
path (the default owner).

```yaml title="moon.yml" {3-6}
owners:
  defaultOwner: '@frontend'
  paths:
    - '**/*.ts'
    - '**/*.tsx'
    - '*.config.js'
```

The second format provides far more granularity, allowing for multiple owners per path. This format
requires a map, where the key is a file path relative from the current project, and the value is a
list of owners. Paths with an empty list of owners will fallback to [`defaultOwner`](#defaultowner).

```yaml title="moon.yml" {3-6}
owners:
  defaultOwner: '@frontend'
  paths:
    '**/*.rs': ['@backend']
    '**/*.js': []
    '*.config.js': ['@frontend', '@frontend-infra']
```

> The syntax for owners is dependent on the provider you are using for version control (GitHub,
> GitLab, Bitbucket). moon provides no validation or guarantees that these are correct.

### `requiredApprovals`

Requires a specific number of approvals for a pull/merge request to be satisfied. Defaults to `1`.

- For Bitbucket, defines the
  [`Check()` condition](https://docs.mibexsoftware.com/codeowners/merge-checks#MergeChecks-2.MergeChecks:HowmanyoftheseCodeOwnersneedtoapprovebeforeapullrequestcanbemerged?)
  when using a [`defaultOwner`](#defaultowner).
- For GitLab, defines a requirement on the
  [code owners section](https://docs.gitlab.com/ee/user/project/codeowners/reference.html#sections-requiring-multiple-approvals).

```yaml title="moon.yml" {2}
owners:
  requiredApprovals: 2
```

## `layer`

> This was previously known as `type` and was renamed to `layer` in v1.39.

The layer within a [stack](#stack). Supports the following values:

- `application` - An application of any kind.
- `automation` - An automated testing suite, like E2E, integration, or visual tests.
  
- `configuration` - Configuration files or infrastructure.
  
- `library` - A self-contained, shareable, and publishable set of code.
- `scaffolding` - Templates or generators for scaffolding.
  
- `tool` - An internal tool, CLI, one-off script, etc.
- `unknown` (default) - When not configured.

```yaml title="moon.yml"
layer: 'application'
```

:::info

The project layer is used in [task inheritance](../concepts/task-inheritance),
[constraints and boundaries](./workspace#constraints), editor extensions, and more!

:::

## `project`

The `project` setting defines metadata about the project itself.

```yaml title="moon.yml"
project:
  name: 'moon'
  description: 'A monorepo management tool.'
  channel: '#moon'
  owner: 'infra.platform'
  maintainers: ['miles.johnson']
```

The information listed within `project` is purely informational and primarily displayed within the
CLI. However, this setting exists for you, your team, and your company, as a means to identify and
organize all projects. Feel free to build your own tooling around these settings!

### `channel`

The Slack, Discord, Teams, IRC, etc channel name (with leading #) in which to discuss the project.

### `description`

A description of what the project does and aims to achieve. Be as descriptive as possible, as this
is the kind of information search engines would index on.

### `maintainers`

A list of people/developers that maintain the project, review code changes, and can provide support.
Can be a name, email, LDAP name, GitHub username, etc, the choice is yours.

### `metadata`

A map of custom metadata to associate to this project. Supports all value types that are valid JSON.

```yaml title="moon.yml"
project:
  # ...
  metadata:
    deprecated: true
```

### `name`

A human readable name of the project. This is _different_ from the unique project name configured in
[`projects`](./workspace#projects).

### `owner`

The team or organization that owns the project. Can be a title, LDAP name, GitHub team, etc. We
suggest _not_ listing people/developers as the owner, use [maintainers](#maintainers) instead.

## `stack`

The technology stack this project belongs to, primarily for categorization. Supports the following
values:

- `frontend` - Client-side user interfaces, etc.
- `backend` - Server-side APIs, database layers, etc.
- `infrastructure` - Cloud/server infrastructure, Docker, etc.
- `systems` - Low-level systems programming.
- `unknown` (default) - When not configured.

```yaml title="moon.yml"
stack: 'frontend'
```

:::info

The project stack is also used in [constraints and boundaries](./workspace#constraints)!

:::

## `tags`

Tags are a simple mechanism for categorizing projects. They can be used to group projects together
for [easier querying](../commands/query/projects), enforcing of
[project boundaries and constraints](./workspace#constraints),
[task inheritance](../concepts/task-inheritance), and more.

```yaml title="moon.yml"
tags:
  - 'react'
  - 'prisma'
```

## Integrations

## `docker`

Configures Docker integration for the current project.

### `file`

Configures the `Dockerfile` generation process when [`moon docker file`](../commands/docker/file) is
executed.

#### `buildTask`

The name of a task within the current project that will be used for building the project before
running it. If not defined, does nothing.

```yaml title="moon.yml" {3}
docker:
  file:
    buildTask: 'build'
```

#### `image`

The Docker image to use in the base stage. Defaults to an image based on the project's toolchain, as
outlined below.

- `oven/bun:latest` for Bun
- `denoland/deno:latest` for Deno
- `node:latest` for Node.js
- `python:latest` for Python
- `rust:latest` for Rust
- `scratch` for everything else

```yaml title="moon.yml" {3}
docker:
  file:
    image: 'node:latest'
```

#### `startTask`

The name of a task within the current project that will run the project after it has been built (if
required). This task will be used as `CMD` within the `Dockerfile`.

```yaml title="moon.yml" {3}
docker:
  file:
    startTask: 'start'
```

### `scaffold`

Configures aspects of the Docker scaffolding process when
[`moon docker scaffold`](../commands/docker/scaffold) is executed. Only applies to the
[sources skeleton](../commands/docker/scaffold#sources).

#### `include`

List of globs in which to copy project-relative files into the `.moon/docker/sources` skeleton. When
not defined, defaults to `**/*`.

```yaml title="moon.yml" {3,4}
docker:
  scaffold:
    include:
      - 'src/**/*'
```

## Tasks

## `env`

The `env` field is map of strings that are passed as environment variables to _all tasks_ within the
current project. Project-level variables will not override task-level variables of the same name.

```yaml title="moon.yml"
env:
  NODE_ENV: 'production'
```

> View the task [`env`](#env-1) setting for more usage examples and information.

## `fileGroups`

Defines [file groups](../concepts/file-group) to be used by local tasks. By default, this setting
_is not required_ for the following reasons:

- File groups are an optional feature, and are designed for advanced use cases.
- File groups defined in [`.moon/tasks.yml`](./tasks) will be inherited by all projects.

When defined this setting requires a map, where the key is the file group name, and the value is a
list of [globs or file paths](../concepts/file-pattern), or environment variables. Globs and paths
are [relative to a project](../concepts/file-pattern#project-relative) (even when defined
[globally](./tasks)).

```yaml title="moon.yml"
# Example groups
fileGroups:
  configs:
    - '*.config.{js,cjs,mjs}'
    - '*.json'
  sources:
    - 'src/**/*'
    - 'types/**/*'
  tests:
    - 'tests/**/*'
    - '**/__tests__/**/*'
  assets:
    - 'assets/**/*'
    - 'images/**/*'
    - 'static/**/*'
    - '**/*.{scss,css}'
```

Once your groups have been defined, you can reference them within [`args`](#args),
[`inputs`](#inputs), [`outputs`](#outputs), and more, using
[token functions and variables](../concepts/token).

```yaml title="moon.yml"
tasks:
  build:
    command: 'vite build'
    inputs:
      - '@group(configs)'
      - '@group(sources)'
```

## `platform`

:::warning

This setting is deprecated, use [`toolchain.default`](#toolchain-1) instead.

:::

The default [`platform`](#platform-1) for all task's within the current project. When a task's
`platform` has _not been_ explicitly configured, the platform will fallback to this configured
value, otherwise the platform will be detected from the project's environment.

```yaml title="moon.yml"
platform: 'node'
```

## `tasks`

Tasks are actions that are ran within the context of a [project](../concepts/project), and commonly
wrap an npm binary or system command. This setting requires a map, where the key is a unique name
for the task, and the value is an object of task parameters.

```yaml title="moon.yml"
tasks:
  format:
    command: 'prettier'
  lint:
    command: 'eslint'
  test:
    command: 'jest'
  typecheck:
    command: 'tsc'
```

### `extends`

The `extends` field can be used to extend the settings from a sibling task within the same project,
or [inherited from the global scope](../concepts/task-inheritance). This is useful for composing
similar tasks with different arguments or options.

When extending another task, the same
[merge strategies](../concepts/task-inheritance#merge-strategies) used for inheritance are applied.

```yaml title="moon.yml" {8}
tasks:
  lint:
    command: 'eslint .'
    inputs:
      - 'src/**/*'

  lint-fix:
    extends: 'lint'
    args: '--fix'
    local: true
```

### `description`

A human-readable description of what the task does. This information is displayed within the
[`moon project`](../commands/project) and [`moon task`](../commands/task) commands.

```yaml title="moon.yml" {3}
tasks:
  build:
    description: 'Builds the project using Vite'
    command: 'vite build'
```

### `command`

The `command` field is a _single_ command to execute for the task, including the command binary/name
(must be first) and any optional [arguments](#args). This field supports task inheritance and
merging of arguments.

This setting can be defined using a string, or an array of strings. We suggest using arrays when
dealing with many args, or the args string cannot be parsed easily.

```yaml title="moon.yml" {4,6-9}
tasks:
  format:
    # Using a string
    command: 'prettier --check .'
    # Using an array
    command:
      - 'prettier'
      - '--check'
      - '.'
```

:::info

If you need to support pipes, redirects, or multiple commands, use [`script`](#script) instead.
Learn more about [commands vs scripts](../concepts/task#commands-vs-scripts).

:::

#### Special commands

For interoperability reasons, the following command names have special handling.

- `noop`, `no-op`, `nop` - Marks the task as a "no operation". Will not execute a command in the
  action pipeline but can define dependencies.
- When `toolchain` is "bun":
  - `bun`, `bunx` - Uses the binaries from the toolchain.
- When `toolchain` is "deno":
  - Will execute with `deno` binary.
- When `toolchain` is "node":
  - `node`, `npm`, `pnpm`, `yarn` - Uses the binaries from the toolchain.
- When `toolchain` is "rust":
  - Will execute with `cargo` binary.

### `args`

The `args` field is a collection of _additional_ arguments to append to the [`command`](#command)
when executing the task. This field exists purely to provide arguments for
[inherited tasks](./tasks#tasks).

This setting can be defined using a string, or an array of strings. We suggest using arrays when
dealing with many args, or the args string cannot be parsed easily.

```yaml title="moon.yml" {5,7-10}
tasks:
  test:
    command: 'jest'
    # Using a string
    args: '--color --maxWorkers 3'
    # Using an array
    args:
      - '--color'
      - '--maxWorkers'
      - '3'
```

However, for the array approach to work correctly, each argument _must_ be its own distinct item,
including argument values. For example:

```yaml title="moon.yml"
tasks:
  test:
    command: 'jest'
    args:
      # Valid
      - '--maxWorkers'
      - '3'
      # Also valid
      - '--maxWorkers=3'
      # Invalid
      - '--maxWorkers 3'
```

### `deps`

The `deps` field is a list of other tasks (known as [targets](../concepts/target)), either within
this project or found in another project, that will be executed _before_ this task. It achieves this
by generating a directed task graph based on the project graph.

```yaml title="moon.yml" {4-8}
tasks:
  build:
    command: 'webpack'
    deps:
      - 'apiClients:build'
      - 'designSystem:build'
      # A task within the current project
      - 'codegen'
```

#### Args & env

Furthermore, for each dependency target, you can configure additional command line arguments and
environment variables that'll be passed to the dependent task when it is ran. The `args` field
supports a string or a list of strings, while `env` is an object of key-value pairs.

```yaml title="moon.yml" {4-8}
tasks:
  build:
    command: 'webpack'
    deps:
      - target: 'apiClients:build'
        args: '--env production'
        env:
          NODE_ENV: 'production'
```

> Dependencies of inherited tasks will be excluded and renamed according to the
> [`workspace.inheritedTasks`](#inheritedtasks) setting. This process _only_ uses filters from the
> current project, and not filters from dependent projects. Furthermore, `args` and `env` are not
> deeply merged.

#### Optional

By default, all dependencies are required to exist when tasks are being built and expanded, but this
isn't always true when dealing with composition and inheritance. For dependencies that may not exist
based on what's inherited, you can mark it as `optional`.

```yaml title="moon.yml" {4-6}
tasks:
  build:
    command: 'webpack'
    deps:
      - target: 'apiClients:build'
        optional: true
```

### `env`

The `env` field is map of strings that are passed as environment variables when running the command.
Variables defined here will take precedence over those loaded with [`envFile`](#envfile).

```yaml title="moon.yml" {4,5}
tasks:
  build:
    command: 'webpack'
    env:
      NODE_ENV: 'production'
```

Variables also support substitution using the syntax `${VAR_NAME}`. When using substitution, only
variables in the current process can be referenced, and not those currently defined in `env`.

```yaml title="moon.yml" {4,5}
tasks:
  build:
    command: 'webpack'
    env:
      APP_TARGET: '${REGION}-${ENVIRONMENT}'
```

### `inputs`

The `inputs` field is a list of sources that calculate whether to execute this task based on the
environment and files that have been touched since the last time the task has been ran. If _not_
defined or inherited, then all files within a project are considered an input (`**/*`), excluding
root-level tasks.

Inputs support the following source types:

- Environment variables
- Environment variable wildcards
  
- Files, folders, and globs
- [Token functions and variables](../concepts/token)

```yaml title="moon.yml" {4-12}
tasks:
  lint:
    command: 'eslint'
    inputs:
      # Config files anywhere within the project
      - '**/.eslintignore'
      - '**/.eslintrc.js'
      # Config files at the workspace root
      - '/.eslintignore'
      - '/.eslintrc.js'
      # Tokens
      - '$projectRoot'
      - '@group(sources)'
```

#### Environment variables

Environment variables can be used as inputs and must start with a `$`. Wildcard variables can use
`*` to match any character.

```yaml title="moon.yml"
tasks:
  example:
    inputs:
      - '$FOO_CACHE'
      - '$FOO_*'
```

:::caution

When using an environment variable, we assume _it's not defined_ by default, and will trigger an
affected state when it _is_ defined. If the environment variable always exists, then the task will
always run and bypass the cache.

:::

#### File paths

File paths support
[project and workspace relative file/folder patterns](../concepts/file-pattern#project-relative).
They can be defined as a literal path, or a `file://` URI ,
or as an object with a `file` property . Additionally, the
following parameters are supported as a URI query or as object fields:

- `content` (`string`) - When determining affected state, will match against the file's content
  using the defined regex pattern, instead of relying on file existence.
- `optional` (`boolean`) - When hashing and set to `true` and the file is missing, will not log a
  warning. When set to `false` and the file is missing, will fail with an error. Defaults to logging
  a warning.

```yaml title="moon.yml"
tasks:
  example:
    inputs:
      # Literal paths
      - 'project/relative/file.js'
      - '/workspace/relative/file.js'
      # Using file protocol
      - 'file://project/relative/file.js?optional'
      - 'file:///workspace/relative/file.js?content=a|b|c'
      # Using an object
      - file: 'project/relative/file.js'
        optional: true
      - file: '/workspace/relative/file.js'
        content: 'a|b|c'
```

#### Glob patterns

Glob patterns support
[project and workspace relative file/folder patterns](../concepts/file-pattern#project-relative).
They can be defined as a literal path, or a `glob://` URI ,
or as an object with a `glob` property . Additionally, the
following parameters are supported as a URI query or as object fields:

- `cache` (`boolean`) - When gathering inputs for hashing, defines whether the glob results should
  be cached for the duration of the moon process. Defaults to `true`.

```yaml title="moon.yml"
tasks:
  example:
    inputs:
      # Literal paths
      - 'project/relative/file.*'
      - '/workspace/relative/**/*'
      # Using glob protocol
      - 'glob://project/relative/file.*?cache=false'
      - 'glob:///workspace/relative/**/*?cache'
      # Using an object
      - glob: 'project/relative/file.*'
        cache: false
      - glob: '/workspace/relative/**/*'
```

Globs can also be negated by prefixing the path with `!`, which will exclude all files that match
the glob.

```yaml title="moon.yml"
tasks:
  example:
    inputs:
      - '!**/*.md'
      - 'glob://!/workspace/relative/**/*'
      - glob: '!/workspace/relative/**/*'
```

:::warning

Glob patterns that contain `?`, for example `*.tsx?`, cannot be used in URI format, as it conflicts
with the query string syntax. Use the path or object format instead.

:::

:::danger

Be aware that files that match the glob, but are ignored via `.gitignore` (or similar), will _not_
be considered an input. To work around this, use explicit file inputs.

:::

### `local`

:::info

This setting is deprecated and will be removed in v2. We suggest using [`preset`](#preset) instead.

:::

Marks the task as local only. This should primarily be enabled for long-running or never-ending
tasks, like development servers and watch mode. Defaults to `true` if the task name is "dev",
"start", or "serve", and `false` otherwise.

This is a convenience setting for local development that sets the following task options:

- [`cache`](#cache) -> Turned off
- [`outputStyle`](#outputstyle) -> Set to "stream"
- [`persistent`](#persistent) -> Turned on
- [`runInCI`](#runinci) -> Turned off

```yaml title="moon.yml" {5}
tasks:
  dev:
    command: 'webpack server'
    local: true
```

### `outputs`

The `outputs` field is a list of [files and folders](../concepts/file-pattern#project-relative) that
are _created_ as a result of executing this task, typically from a build or compilation related
task. Outputs are necessary for [incremental caching and hydration](../concepts/cache). If you'd
prefer to avoid that functionality, omit this field.

```yaml title="moon.yml" {4-6}
tasks:
  build:
    command: 'webpack'
    outputs:
      # Relative from project root
      - 'build/'
```

Globs can also be used if you'd like to restrict which files are cached. For example, when building
a JavaScript project, you may want to include `.js` files, but exclude `.map` and other files.

```yaml title="moon.yml" {4-6}
tasks:
  build:
    command: 'webpack'
    outputs:
      - 'build/**/*.js'
      - '!build/internal.js'
```

:::caution

When using globs and moon hydrates an output (a cache hit), all files not matching the glob will be
**deleted**. Ensure that all files critical for the build to function correctly are included.

:::

### `platform`

:::warning

This setting is deprecated, use [`toolchain`](#toolchain) instead.

:::

The `platform` field defines the platform (language runtime) the command runs on, where to locate
its executable, and which tool to execute it with. By default moon will set to a value based on the
project's [`language`](#language) or default [`platform`](#platform).

- `bun` - Command is a binary within `node_modules` and will be executed with Bun.
  
- `deno` - Command is executed with Deno, or is a Deno binary located in `~/.deno/bin`.
- `node` - Command is a binary within `node_modules` and will be executed with Node.js.
- `rust` - Command is executed with Cargo, or is a Cargo binary located in `~/.cargo/bin`.
- `system` - Command is expected to exist within the system's environment / user's shell.
- `unknown` - When not configured or inferred.

```yaml title="moon.yml" {4}
tasks:
  env:
    command: 'printenv'
    platform: 'system'
```

> This field exists because of our [toolchain](../concepts/toolchain), and moon ensuring the correct
> command is ran.

### `preset`

Applies the chosen preset to the task. A preset defines a collection of task options that will be
inherited as the default, and can then be overridden within the task itself. The following presets
are available:

- `server`
  - [`cache`](#cache) -> Turned off
  - [`outputStyle`](#outputstyle) -> Set to "stream"
  - [`persistent`](#persistent) -> Turned on
  - [`runInCI`](#runinci) -> Turned off
- `watcher`
  - Inherits `server` options
  - [`interactive`](#interactive) -> Turned on

Tasks named "dev", "start", or "serve" are marked as `server` automatically.

```yaml title="moon.yml" {5}
tasks:
  dev:
    command: 'webpack server'
    preset: 'server'
```

### `script`

The `script` field is _one or many_ commands to execute for the task, with support for pipes,
redirects, and more. This field does _not_ support task inheritance merging, and can only be defined
with a string.

If defined, will supersede [`command`](#command) and [`args`](#args).

```yaml title="moon.yml" {4,6,8,10}
tasks:
  exec:
    # Single command
    script: 'cp ./in ./out'
    # Multiple commands
    script: 'rm -rf ./out && cp ./in ./out'
    # Pipes
    script: 'ps aux | grep 3000'
    # Redirects
    script: './gen.sh > out.json'
```

:::info

If you need to support merging during task inheritance, use [`command`](#command) instead. Learn
more about [commands vs scripts](../concepts/task#commands-vs-scripts).

:::

### `toolchain`

The `toolchain` field defines the [toolchain (language runtime)](../concepts/toolchain) the command
runs on, where to locate its executable, and which tool to execute it with. By default, moon will
set to a value based on the project's [`language`](#language) or default
[`toolchain.default`](#toolchain-1).

- `bun` - Command is a binary within `node_modules` and will be executed with Bun.
  
- `deno` - Command is executed with Deno, or is a Deno binary located in `~/.deno/bin`.
- `node` - Command is a binary within `node_modules` and will be executed with Node.js.
- `rust` - Command is executed with Cargo, or is a Cargo binary located in `~/.cargo/bin`.
- `system` - Command is expected to exist within the system's environment / user's shell.

```yaml title="moon.yml" {4}
tasks:
  env:
    command: 'printenv'
    toolchain: 'system'
```

### `options`

The `options` field is an object of configurable options that can be used to modify the task and its
execution. The following fields can be provided, with merge related fields supporting all
[merge strategies](../concepts/task-inheritance#merge-strategies).

```yaml title="moon.yml"
tasks:
  typecheck:
    command: 'tsc --noEmit'
    options:
      mergeArgs: 'replace'
      runFromWorkspaceRoot: true
```

#### `affectedFiles`

When enabled and the [`--affected` option](../run-task#running-based-on-affected-files-only) is
provided, all affected files that match this task's [`inputs`](#inputs) will be passed as relative
file paths as command line arguments, and as a `MOON_AFFECTED_FILES` environment variable.

If there are no affected files, `.` (current directory) will be passed instead for arguments, and an
empty value for the environment variable. This functionality can be changed with the
[`affectedPassInputs`](#affectedpassinputs) setting.

```yaml title="moon.yml" {5,7,9}
tasks:
  lint:
    command: 'eslint'
    options:
      affectedFiles: true
      # Only pass args
      affectedFiles: 'args'
      # Only set env var
      affectedFiles: 'env'
```

:::caution

When using this option, ensure that explicit files or `.` _are not present_ in the [`args`](#args)
list. Furthermore, this functionality will only work if the task's command supports an arbitrary
list of files being passed as arguments.

:::

#### `affectedPassInputs`

When [`affectedFiles`](#affectedfiles) is enabled, and no affected files are found, moon will pass
`.` as an argument. For the most part, this works, but if you'd like to _not_ pass the entire
directory (and everything in it), and only pass the configured [`inputs`](#inputs) instead, then you
can enable this setting.

When enabled, moon will resolve all input globs to literal file paths, and pass them as relative
arguments.

```yaml title="moon.yml" {5,6}
tasks:
  lint:
    command: 'eslint'
    options:
      affectedFiles: true
      affectedPassInputs: true
```

#### `allowFailure`

Allows a task to fail without failing the entire pipeline. When enabled, the following changes
occur:

- Other tasks _cannot_ depend on this task, as we can't ensure it's side-effect free.
- For [`moon run`](../commands/run), the process will not bail early and will run to completion.
- For [`moon ci`](../commands/ci), the process will not exit with a non-zero exit code, if the only
  failing tasks are allowed to fail.

```yaml title="moon.yml" {5}
tasks:
  lint:
    command: 'eslint'
    options:
      allowFailure: true
```

#### `cache`

Whether to cache the task's execution result using our [smart hashing](../concepts/cache#hashing)
system. If disabled, _will not_ create a cache hash, and _will not_ persist a task's
[outputs](#outputs). Defaults to `true`.

We suggest disabling caching when defining cleanup tasks, one-off scripts, or file system heavy
operations.

```yaml title="moon.yml" {5}
tasks:
  clean:
    command: 'rm -rf ./temp'
    options:
      cache: false
```

#### `cacheKey`

A custom key to include in the cache and task hashing process. Can be used to invalidate local and
remote caches.

```yaml title="moon.yml" {5}
tasks:
  build:
    command: 'some-costly-build'
    options:
      cacheKey: 'v1'
```

#### `cacheLifetime`

The lifetime in which a [cached task](#cache) will live before being marked as stale and re-running.
This applies to a task even if it does not produce [outputs](#outputs).

The lifetime can be configured in a human-readable string format, for example, `1 day`, `3 hr`,
`1m`, etc. If the lifetime is not defined, the cache will live forever, or until the task inputs are
touched.

```yaml title="moon.yml" {5}
tasks:
  build:
    command: 'some-costly-build'
    options:
      cacheLifetime: '1 day'
```

> String formats are powered by the
> [humantime](https://docs.rs/humantime/2.1.0/humantime/fn.parse_duration.html) crate.

#### `envFile`

A boolean or path to a `.env` file (also know as dotenv file) that defines a collection of
[environment variables](#env-1) for the current task. Variables will be loaded on project creation,
but will _not_ override those defined in [`env`](#env-1).

Variables defined in the file support value substitution/expansion by wrapping the variable name in
curly brackets, such as `${VAR_NAME}`.

```yaml title="moon.yml" {6,8,10}
tasks:
  build:
    command: 'webpack'
    options:
      # Defaults to .env
      envFile: true
      # Or
      envFile: '.env.production'
      # Or from the workspace root
      envFile: '/.env.shared'
```

Additionally, a list of file paths can also be provided. When using a list, the order of the files
is important, as environment variables from all files will be aggregated into a single map, with
subsequent files taking precedence over previous ones. Once aggregated, the variables will be passed
to the task, but will _not_ override those defined in [`env`](#env-1).

```yaml title="moon.yml" {5-7}
tasks:
  build:
    command: 'webpack'
    options:
      envFile:
        - '.env'
        - '.env.production'
```

:::caution

File parsing is done using the Rust [`dotenvy`](https://crates.io/crates/dotenvy) crate, which is
_different_ than the Node.js [`dotenv`](https://www.npmjs.com/package/dotenv) package. The biggest
differences are around quote handling and variable substitution, so be aware of this!

:::

#### `inferInputs`

Automatically infer [inputs](#inputs) based on the following parameters configured within the task's
`command`, `script`, `args`, or `env`. Defaults to `true`.

- File/glob paths derived from [file group based token functions](../concepts/token#file-groups).
- Environment variables being substituted within a command or script.

```yaml title="moon.yml" {5}
tasks:
  build:
    # ...
    options:
      inferInputs: false
```

#### `internal`

Marks the task as internal only. [Internal tasks](../concepts/task#internal-only) can not be
explicitly ran on the command line, but can be depended on by other tasks.

```yaml title="moon.yml" {5}
tasks:
  prepare:
    # ...
    options:
      internal: true
```

#### `interactive`

Marks the task as interactive. [Interactive tasks](../concepts/task#interactive) run in isolation so
that they can interact with stdin.

This setting also disables caching, turns of CI, and other functionality, similar to the
[`local`](#local) setting.

```yaml title="moon.yml" {5}
tasks:
  init:
    # ...
    options:
      interactive: true
```

#### `merge`

The [strategy](../concepts/task-inheritance#merge-strategies) to use when merging [`args`](#args),
[`deps`](#deps), [`env`](#env-1), [`inputs`](#inputs), and [`outputs`](#outputs) with an inherited
task. This option can be overridden with the field specific merge options below.

#### `mergeArgs`

The [strategy](../concepts/task-inheritance#merge-strategies) to use when merging the
[`args`](#args) list with an inherited task. Defaults to "append".

#### `mergeDeps`

The [strategy](../concepts/task-inheritance#merge-strategies) to use when merging the
[`deps`](#deps) list with an inherited task. Defaults to "append".

#### `mergeEnv`

The [strategy](../concepts/task-inheritance#merge-strategies) to use when merging the
[`env`](#env-1) map with an inherited task. Defaults to "append".

#### `mergeInputs`

The [strategy](../concepts/task-inheritance#merge-strategies) to use when merging the
[`inputs`](#inputs) list with an inherited task. Defaults to "append".

#### `mergeOutputs`

The [strategy](../concepts/task-inheritance#merge-strategies) to use when merging the
[`outputs`](#outputs) list with an inherited task. Defaults to "append".

#### `mutex`

Creates an exclusive lock on a "virtual resource", preventing other tasks using the same "virtual
resource" from running concurrently.

If you have many tasks that require exclusive access to a resource that can't be tracked by moon
(like a database, an ignored file, a file that's not part of the project, or a remote resource) you
can use the `mutex` option to prevent them from running at the same time.

```yaml title="moon.yml" {5,10}
tasks:
  a:
    # ...
    options:
      mutex: 'virtual_resource_name'

  # b doesn't necessarily have to be in the same project
  b:
    # ...
    options:
      mutex: 'virtual_resource_name'
```

#### `os`

When defined, the task will _only_ run on the configured operating system. For other operating
systems, the task becomes a no-operation. Supports the values `linux`, `macos`, and `windows`.

Can be defined as a single value, or a list of values.

```yaml title="moon.yml" {5,10}
tasks:
  build-unix:
    # ...
    options:
      os: ['linux', 'macos']

  build-windows:
    # ...
    options:
      os: 'windows'
```

#### `outputStyle`

Controls how stdout/stderr is displayed when the task is ran as a _transitive target_. By default,
this setting is not defined and defers to the action pipeline, but can be overridden with one of the
following values:

- `buffer` - Buffers output and displays after the task has exited (either success or failure).
- `buffer-only-failure` - Like `buffer`, but only displays on failures.
- `hash` - Ignores output and only displays the generated [hash](../concepts/cache#hashing).
- `none` - Ignores output.
- `stream` - Streams output directly to the terminal. Will prefix each line of output with the
  target.

```yaml title="moon.yml" {5}
tasks:
  test:
    # ...
    options:
      outputStyle: 'stream'
```

#### `persistent`

Marks the task as persistent (continuously running). [Persistent tasks](../concepts/task#persistent)
are handled differently than non-persistent tasks in the action graph. When running a target, all
persistent tasks are _ran last_ and _in parallel_, after all their dependencies have completed.

This is extremely useful for running a server (or a watcher) in the background while other tasks are
running.

```yaml title="moon.yml" {5}
tasks:
  dev:
    # ...
    options:
      persistent: true
```

> We suggest using the [`local`](#local) setting instead, which enables this setting, amongst other
> useful settings.

#### `priority`

The priority level determines the position of the task within the action pipeline queue. A task with
a higher priority will run sooner rather than later, while still respecting the topological order.
Supports the following levels:

- `critical`
- `high`
- `normal` (default)
- `low`

```yaml title="moon.yml" {5}
tasks:
  build:
    # ...
    options:
      priority: 'high'
```

#### `retryCount`

The number of attempts the task will retry execution before returning a failure. This is especially
useful for flaky tasks. Defaults to `0`.

```yaml title="moon.yml" {5}
tasks:
  test:
    # ...
    options:
      retryCount: 3
```

#### `runDepsInParallel`

Whether to run the task's direct [`deps`](#deps) in parallel or serial (in order). Defaults to
`true`.

When disabled, this _does not_ run dependencies of dependencies in serial, only direct dependencies.

```yaml title="moon.yml" {8}
tasks:
  start:
    # ...
    deps:
      - '~:clean'
      - '~:build'
    options:
      runDepsInParallel: false
```

#### `runInCI`

Whether to run the task automatically in a CI (continuous integration) environment when affected by
touched files, typically through the [`moon ci`](../commands/ci) command. Supports the following
values:

- `always` - Always run in CI, regardless if affected or not. 
- `true`, `affected` - Only run if affected by touched files.
- `false` - Never run in CI.

Defaults to `true` unless the [`local`](#local) setting is enabled.

```yaml title="moon.yml" {5}
tasks:
  build:
    # ...
    options:
      runInCI: false
```

#### `runFromWorkspaceRoot`

Whether to use the workspace root as the working directory when executing a task. Defaults to
`false` and runs from the task's project root.

```yaml title="moon.yml" {5}
tasks:
  typecheck:
    # ...
    options:
      runFromWorkspaceRoot: true
```

#### `shell`

Whether to run the command within a shell or not. Defaults to `true` for system toolchain or
Windows, and `false` otherwise. The shell to run is determined by the [`unixShell`](#unixshell) and
[`windowsShell`](#windowsshell) options respectively.

```yaml title="moon.yml" {5}
tasks:
  native:
    command: 'echo $SHELL'
    options:
      shell: true
```

However, if you'd like to use a different shell, or customize the shell's arguments, or have
granular control, you can set `shell` to false and configure a fully qualified command.

```yaml title="moon.yml" {5}
tasks:
  native:
    command: '/bin/zsh -c "echo $SHELL"'
    options:
      shell: false
```

#### `timeout`

The maximum time in seconds that the task is allowed to run, before it is force cancelled. If not
defined, will run indefinitely.

```yaml title="moon.yml" {5}
tasks:
  build:
    # ...
    options:
      timeout: 120
```

#### `unixShell`

Customize the shell to run with when on a Unix operating system. Accepts `bash`, `elvish`, `fish`,
`ion`, `murex`, `nu`, `pwsh`, `xonsh`, or `zsh`. If not defined, will derive the shell from the
`SHELL` environment variable, or defaults to `sh`.

```yaml title="moon.yml" {5}
tasks:
  native:
    command: 'echo $SHELL'
    options:
      unixShell: 'fish'
```

#### `windowsShell`

Customize the shell to run with when on a Windows operating system. Accepts `bash` (typically via
Git), `elvish`, `fish`, `murex`, `nu`, `pwsh`, or `xonsh`. If not defined, defaults to `pwsh`.

```yaml title="moon.yml" {5}
tasks:
  native:
    command: 'echo $SHELL'
    options:
      windowsShell: 'bash'
```

## Overrides

Dictates how a project interacts with settings defined at the top-level.

## `toolchain`

### `default`

The default [`toolchain`](#toolchain-1) for all task's within the current project. When a task's
`toolchain` has _not been_ explicitly configured, the toolchain will fallback to this configured
value, otherwise the toolchain will be detected from the project's environment.

```yaml title="moon.yml"
toolchain:
  default: 'node'
```

### `bun`

Configures Bun for this project and overrides the top-level [`bun`](./toolchain#bun) setting.

#### `version`

Defines the explicit Bun [version specification](../concepts/toolchain#version-specification) to use
when _running tasks_ for this project.

```yaml title="moon.yml" {2,3}
toolchain:
  bun:
    version: '1.0.0'
```

### `deno`

Configures Deno for this project and overrides the top-level [`deno`](./toolchain#deno) setting.

#### `version`

Defines the explicit Deno [version specification](../concepts/toolchain#version-specification) to
use when _running tasks_ for this project.

```yaml title="moon.yml" {2,3}
toolchain:
  deno:
    version: '1.40.0'
```

### `node`

Configures Node.js for this project and overrides the top-level [`node`](./toolchain#node) setting.
Currently, only the Node.js version can be overridden per-project, not the package manager.

#### `version`

Defines the explicit Node.js [version specification](../concepts/toolchain#version-specification) to
use when _running tasks_ for this project.

```yaml title="moon.yml" {2,3}
toolchain:
  node:
    version: '12.12.0'
```

### `python`

Configures Python for this project and overrides the top-level [`python`](./toolchain#python)
setting.

#### `version`

Defines the explicit Python
[version/channel specification](../concepts/toolchain#version-specification) to use when _running
tasks_ for this project.

```yaml title="moon.yml" {2,3}
toolchain:
  python:
    version: '3.12.0'
```

### `rust`

Configures Rust for this project and overrides the top-level [`rust`](./toolchain#rust) setting.

#### `version`

Defines the explicit Rust
[version/channel specification](../concepts/toolchain#version-specification) to use when _running
tasks_ for this project.

```yaml title="moon.yml" {2,3}
toolchain:
  rust:
    version: '1.68.0'
```

### `typescript`

#### `disabled`

Disables [TypeScript support](./toolchain#typescript) entirely for this project. Defaults to
`false`.

```yaml title="moon.yml" {3}
toolchain:
  typescript:
    disabled: true
```

#### `includeProjectReferenceSources`

Overrides the workspace-level
[`includeProjectReferenceSources`](./toolchain#includeprojectreferencesources) setting. Defaults to
undefined.

```yaml title="moon.yml" {3}
toolchain:
  typescript:
    includeProjectReferenceSources: false
```

#### `includeSharedTypes`

Overrides the workspace-level [`includeSharedTypes`](./toolchain#includesharedtypes) setting.
Defaults to undefined.

```yaml title="moon.yml" {3}
toolchain:
  typescript:
    includeSharedTypes: false
```

#### `routeOutDirToCache`

Overrides the workspace-level [`routeOutDirToCache`](./toolchain#routeoutdirtocache) setting.
Defaults to undefined.

```yaml title="moon.yml" {3}
toolchain:
  typescript:
    routeOutDirToCache: false
```

#### `syncProjectReferences`

Overrides the workspace-level [`syncProjectReferences`](./toolchain#syncprojectreferences) setting.
Defaults to undefined.

```yaml title="moon.yml" {3}
toolchain:
  typescript:
    syncProjectReferences: false
```

#### `syncProjectReferencesToPaths`

Overrides the workspace-level
[`syncProjectReferencesToPaths`](./toolchain#syncprojectreferencestopaths) setting. Defaults to
undefined.

```yaml title="moon.yml" {3}
toolchain:
  typescript:
    syncProjectReferencesToPaths: false
```

## `workspace`

### `inheritedTasks`

Provides a layer of control when inheriting tasks from [`.moon/tasks.yml`](./tasks).

#### `exclude`

The optional `exclude` setting permits a project to exclude specific tasks from being inherited. It
accepts a list of strings, where each string is the name of a global task to exclude.

```yaml title="moon.yml" {4}
workspace:
  inheritedTasks:
    # Exclude the inherited `test` task for this project
    exclude: ['test']
```

> Exclusion is applied after inclusion and before renaming.

#### `include`

The optional `include` setting permits a project to _only_ include specific inherited tasks (works
like an allow/white list). It accepts a list of strings, where each string is the name of a global
task to include.

When this field is not defined, the project will inherit all tasks from the global project config.

```yaml title="moon.yml" {4,7-9}
workspace:
  inheritedTasks:
    # Include *no* tasks (works like a full exclude)
    include: []

    # Only include the `lint` and `test` tasks for this project
    include:
      - 'lint'
      - 'test'
```

> Inclusion is applied before exclusion and renaming.

#### `rename`

The optional `rename` setting permits a project to rename the inherited task within the current
project. It accepts a map of strings, where the key is the original name (found in the global
project config), and the value is the new name to use.

For example, say we have 2 tasks in the global project config called `buildPackage` and
`buildApplication`, but we only need 1, and since we're an application, we should omit and rename.

```yaml title="moon.yml" {4,5}
workspace:
  inheritedTasks:
    exclude: ['buildPackage']
    rename:
      buildApplication: 'build'
```

> Renaming occurs after inclusion and exclusion.

---

## .moon/tasks[/**/*].{pkl,yml}

import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `.moon/tasks.yml` file configures file groups and tasks that are inherited by _every_ project in
the workspace, while `.moon/tasks/**/*.yml` configures for projects based on their language or type.
[Learn more about task inheritance!](../concepts/task-inheritance)

Projects can override or merge with these settings within their respective [`moon.yml`](./project).

```yaml title=".moon/tasks.yml"
$schema: 'https://moonrepo.dev/schemas/tasks.json'
```

:::info

Inherited tasks configuration can also be written in [Pkl](../guides/pkl-config) instead of YAML.

:::

## `extends`

Defines one or many external `.moon/tasks.yml`'s to extend and inherit settings from. Perfect for
reusability and sharing configuration across repositories and projects. When defined, this setting
must be an HTTPS URL _or_ relative file system path that points to a valid YAML document!

```yaml title=".moon/tasks.yml" {1}
extends: 'https://raw.githubusercontent.com/organization/repository/master/.moon/tasks.yml'
```

:::caution

For map-based settings, `fileGroups` and `tasks`, entries from both the extended configuration and
local configuration are merged into a new map, with the values of the local taking precedence. Map
values _are not_ deep merged!

:::

## `fileGroups`

> For more information on file group configuration, refer to the
> [`fileGroups`](./project#filegroups) section in the [`moon.yml`](./project) doc.

Defines [file groups](../concepts/file-group) that will be inherited by projects, and also enables
enforcement of organizational patterns and file locations. For example, encourage projects to place
source files in a `src` folder, and all test files in `tests`.

```yaml title=".moon/tasks.yml"
fileGroups:
  configs:
    - '*.config.{js,cjs,mjs}'
    - '*.json'
  sources:
    - 'src/**/*'
    - 'types/**/*'
  tests:
    - 'tests/**/*'
    - '**/__tests__/**/*'
  assets:
    - 'assets/**/*'
    - 'images/**/*'
    - 'static/**/*'
    - '**/*.{scss,css}'
```

:::info

File paths and globs used within a file group are relative from the inherited project's root, and
not the workspace root.

:::

## `implicitDeps`

Defines task [`deps`](./project#deps) that are implicitly inserted into _all_ inherited tasks within
a project. This is extremely useful for pre-building projects that are used extensively throughout
the repo, or always building project dependencies. Defaults to an empty list.

```yaml title=".moon/tasks.yml" {1-2}
implicitDeps:
  - '^:build'
```

:::info

Implicit dependencies are _always_ inherited, regardless of the [`mergeDeps`](./project#mergedeps)
option.

:::

## `implicitInputs`

Defines task [`inputs`](./project#inputs) that are implicitly inserted into _all_ inherited tasks
within a project. This is extremely useful for the "changes to these files should always trigger a
task" scenario.

Like `inputs`, file paths/globs defined here are relative from the inheriting project.
[Project and workspace relative file patterns](../concepts/file-pattern#project-relative) are
supported and encouraged.

```yaml title=".moon/tasks/node.yml" {1-2}
implicitInputs:
  - 'package.json'
```

:::info

Implicit inputs are _always_ inherited, regardless of the [`mergeInputs`](./project#mergeinputs)
option.

:::

## `tasks`

> For more information on task configuration, refer to the [`tasks`](./project#tasks) section in the
> [`moon.yml`](./project) doc.

As mentioned in the link above, [tasks](../concepts/task) are actions that are ran within the
context of a project, and commonly wrap a command. For most workspaces, every project _should_ have
linting, typechecking, testing, code formatting, so on and so forth. To reduce the amount of
boilerplate that _every_ project would require, this setting offers the ability to define tasks that
are inherited by many projects within the workspace, but can also be overridden per project.

```yaml title=".moon/tasks.yml"
tasks:
  format:
    command: 'prettier --check .'

  lint:
    command: 'eslint --no-error-on-unmatched-pattern .'

  test:
    command: 'jest --passWithNoTests'

  typecheck:
    command: 'tsc --build'
```

:::info

Relative file paths and globs used within a task are relative from the inherited project's root, and
not the workspace root.

:::

## `taskOptions`

> For more information on task options, refer to the [`options`](./project#options) section in the
> [`moon.yml`](./project) doc.

Like [tasks](#tasks), this setting allows you to define task options that will be inherited by _all
tasks_ within the configured file, and by all project-level inherited tasks. This setting is the 1st
link in the inheritance chain, and can be overridden within each task.

```yaml title=".moon/tasks.yml"
taskOptions:
  # Never cache builds
  cache: false
  # Always re-run flaky tests
  retryCount: 2

tasks:
  build:
    # ...
    options:
      # Override the default cache setting
      cache: true
```

---

## template.{pkl,yml}

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';
import RequiredLabel from '@site/src/components/Docs/RequiredLabel';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `template.yml` file configures metadata and variables for a template,
[used by the generator](../guides/codegen), and must exist at the root of a named template folder.

```yaml title="template.yml"
$schema: 'https://moonrepo.dev/schemas/template.json'
```

:::info

Template configuration can also be written in [Pkl](../guides/pkl-config) instead of YAML.

:::

## `id`

Overrides the name (identifier) of the template, instead of inferring the name from the template
folder. Be aware that template names must be unique across the workspace, and across all template
locations that have been configured in [`generator.templates`](./workspace#templates).

```yaml title="template.yml"
id: 'npm-package'
```

## `title`

A human readable title that will be displayed during the [`moon generate`](../commands/generate)
process.

```yaml title="template.yml"
title: 'npm package'
```

## `description`

A description of why the template exists, what its purpose is, and any other relevant information.

```yaml title="template.yml"
description: |
  Scaffolds the initial structure for an npm package,
  including source and test folders, a package.json, and more.
```

## `destination`

An optional file path in which this template should be generated into. This provides a mechanism for
standardizing a destination location, and avoids having to manually pass a destination to
[`moon generate`](../commands/generate).

If the destination is prefixed with `/`, it will be relative from the workspace root, otherwise it
is relative from the current working directory.

```yaml title="template.yml"
destination: 'packages/[name]'
```

> This setting supports [template variables](#variables) through `[varName]` syntax. Learn more in
> the [code generation documentation](../guides/codegen#interpolation).

## `extends`

One or many other templates that this template should extend. Will deeply inherit all template files
and variables.

```yaml title="template.yml"
extends: ['base', 'configs']
```

## `variables`

A mapping of variables that will be interpolated into all template files and file system paths when
[rendering with Tera](https://tera.netlify.app/docs/#variables). The map key is the variable name
(in camelCase or snake_case), while the value is a configuration object, as described with the
settings below.

```yaml title="template.yml"
variables:
  name:
    type: 'string'
    default: ''
    required: true
    prompt: 'Package name?'
```

### `type`

The type of value for the variable. Accepts `array`, `boolean`, `string`, `object`, `number`, or
`enum`. Floats _are not supported_, use strings instead.

For arrays and objects, the value of each member must be a JSON compatible type.

### `internal`

Marks a variable as internal only, which avoids the variable value being overwritten by command line
arguments.

### `order`

The order in which the variable will be prompted to the user. By default, variables are prompted in
the order they are defined in the `template.yml` file.

### Primitives & collections

Your basic primitives: boolean, numbers, strings, and collections: arrays, objects.

```yaml title="template.yml"
variables:
  type:
    type: 'array'
    prompt: 'Type?'
    default: ['app', 'lib']
```

```yaml title="template.yml"
variables:
  private:
    type: 'boolean'
    prompt: 'Private?'
    default: false
```

```yaml title="template.yml"
variables:
  age:
    type: 'number'
    prompt: 'Age?'
    default: 0
    required: true
```

```yaml title="template.yml"
variables:
  metadata:
    type: 'object'
    prompt: 'Metadata?'
    default:
      type: 'lib'
      dev: true
```

```yaml title="template.yml"
variables:
  name:
    type: 'string'
    prompt: 'Name?'
    required: true
```

### `default`

The default value of the variable. When `--defaults` is passed to
[`moon generate`](../commands/generate) or [`prompt`](#prompt) is not defined, the default value
will be used, otherwise the user will be prompted to enter a custom value.

### `prompt`

When defined, will prompt the user with a message in the terminal to input a custom value, otherwise
[`default`](#default) will be used.

For arrays and objects, a valid JSON string must be provided as the value.

### `required`

Marks the variable as required during _prompting only_. For arrays, strings, and objects, will error
for empty values (`''`). For numbers, will error for zero's (`0`).

### Enums

An enum is an explicit list of string values that a user can choose from.

```yaml title="template.yml"
variables:
  color:
    type: 'enum'
    values: ['red', 'green', 'blue', 'purple']
    default: 'purple'
    prompt: 'Favorite color?'
```

### `default`

The default value of the variable. When `--defaults` is passed to
[`moon generate`](../commands/generate) or [`prompt`](#prompt) is not defined, the default value
will be used, otherwise the user will be prompted to enter a custom value.

For enums, the default value can be a string when [`multiple`](#multiple) is false, or a string or
an array of strings when `multiple` is true. Furthermore, each default value must exist in the
[`values`](#values) list.

```yaml title="template.yml"
# Single
variables:
  color:
    type: 'enum'
    values: ['red', 'green', 'blue', 'purple']
    default: 'purple'
    prompt: 'Favorite color?'

# Multiple
variables:
  color:
    type: 'enum'
    values: ['red', 'green', 'blue', 'purple']
    default: ['red', 'purple']
    multiple: true
    prompt: 'Favorite color?'
```

### `prompt`

When defined, will prompt the user with a message in the terminal to input a custom value, otherwise
[`default`](#default) will be used.

### `multiple`

Allows multiple values to be chosen during prompting. In the template, an array or strings will be
rendered, otherwise when not-multiple, a single string will be.

### `values`

List of explicit values to choose from. Can either be defined with a string, which acts as a value
and label, or as an object, which defines an explicit value and label.

```yaml title="template.yml"
variables:
  color:
    type: 'enum'
    values:
      - 'red'
      # OR
      - value: 'red'
        label: 'Red 🔴'
    # ...
```

## Frontmatter

The following settings _are not_ available in `template.yml`, but can be defined as frontmatter at
the top of a template file. View the [code generation guide](../guides/codegen#frontmatter) for more
information.

### `force`

When enabled, will always overwrite a file of the same name at the destination path, and will bypass
any prompting in the terminal.

```twig
---
force: true
---

Some template content!
```

### `to`

Defines a custom file path, relative from the destination root, in which to create the file. This
will override the file path within the template folder, and allow for conditional rendering and
engine filters to be used.

```twig
{% set component_name = name | pascal_case %}

---
to: components/{{ component_name }}.tsx
---

export function {{ component_name }}() {
  return ;
}
```

### `skip`

When enabled, the template file will be skipped while writing to the destination path. This setting
can be used to conditionally render a file.

```twig
---
skip: {{ name == "someCondition" }}
---

Some template content!
```

---

## .moon/toolchain.{pkl,yml}

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';
import RequiredLabel from '@site/src/components/Docs/RequiredLabel';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `.moon/toolchain.yml` file configures the toolchain and the workspace development environment.
This file is _optional_.

Managing tool version's within the toolchain ensures a deterministic environment across any machine
(whether a developer, CI, or production machine).

```yaml title=".moon/toolchain.yml"
$schema: 'https://moonrepo.dev/schemas/toolchain.json'
```

:::info

Toolchain configuration can also be written in [Pkl](../guides/pkl-config) instead of YAML.

:::

## `extends`

Defines one or many external `.moon/toolchain.yml`'s to extend and inherit settings from. Perfect
for reusability and sharing configuration across repositories and projects. When defined, this
setting must be an HTTPS URL _or_ relative file system path that points to a valid YAML document!

```yaml title=".moon/toolchain.yml" {1}
extends: 'https://raw.githubusercontent.com/organization/repository/master/.moon/toolchain.yml'
```

:::caution

Settings will be merged recursively for blocks, with values defined in the local configuration
taking precedence over those defined in the extended configuration.

:::

## `moon`

Configures how moon will receive information about latest releases and download locations.

### `manifestUrl`

Defines an HTTPS URL in which to fetch the current version information from.

```yaml title=".moon/toolchain.yml" {2}
moon:
  manifestUrl: 'https://proxy.corp.net/moon/version'
```

### `downloadUrl`

Defines an HTTPS URL in which the moon binary can be downloaded from. The download file name is
hard-coded and will be appended to the provided URL.

Defaults to downloading from GitHub: https://github.com/moonrepo/moon/releases

```yaml title=".moon/toolchain.yml" {2}
moon:
  downloadUrl: 'https://github.com/moonrepo/moon/releases/latest/download'
```

## `proto`

Configures how moon integrates with and utilizes [proto](/proto).

### `version`

The version of proto to install and run toolchains with. If proto or this version of proto has not
been installed yet, it will be installed automatically when running a task.

```yaml title=".moon/toolchain.yml" {2}
proto:
  version: '0.51.0'
```

## Go

## `unstable_go`

Enables and configures Go. This setting enables the new WASM powered Go toolchain.

### `version`

Defines the explicit Go toolchain
[version specification](../concepts/toolchain#version-specification) to use. If this field is _not
defined_, the global `go` binary will be used.

```yaml title=".moon/toolchain.yml" {2}
unstable_go:
  version: '1.24.0'
```

> Version can also be defined with [`.prototools`](../proto/config).

### `bins`

A list of binaries to install globally into Go (`~/go/bin`) using `go install`. This setting
requires a list of URLs or binary configuration objects with the following fields:

- `bin` (required) - URL of the binary.
- `local` - Only install the binary locally, and not in CI.

```yaml title=".moon/toolchain.yml" {2-5}
unstable_go:
  bins:
    - 'golang.org/x/tools/gopls'
    - bin: 'github.com/revel/cmd/revel@1'
      local: true
```

### `tidyOnChange`

Tidy modules when dependencies or `go.sum` changes by running `go mod tidy`. This setting is ignored
when using Go workspaces. Defaults to `false`.

```yaml title=".moon/toolchain.yml" {2}
unstable_go:
  tidyOnChange: true
```

### `vendorDir`

A relative path to the vendor directory from the dependencies root, as generated with
`go mod vendor`. If vendored with the default name of "vendor", this setting can be omitted.

```yaml title=".moon/toolchain.yml" {2}
unstable_go:
  vendorDir: 'custom/vendor/path'
```

### `workspaces`

Enables support for [Go workspaces](https://go.dev/ref/mod#workspaces) and will attempt to locate
the dependencies root by locating the `go.work` file, and parsing `go.work.sum` files. This
functionality will take precedence over `go.sum` files. Defaults to `true`.

```yaml title=".moon/toolchain.yml" {2}
unstable_go:
  workspaces: true
```

## JavaScript

## `bun`

Enables and configures [Bun](../guides/javascript/bun-handbook).

### `version`

Defines the explicit Bun toolchain
[version specification](../concepts/toolchain#version-specification) to use. If this field is _not
defined_, the global `bun` binary will be used.

```yaml title=".moon/toolchain.yml" {2}
bun:
  version: '1.0.0'
```

> Version can also be defined with [`.prototools`](../proto/config).

### `installArgs`

Customize the arguments that will be passed to the `bun install` command, when the `InstallDeps`
action is triggered in the pipeline. These arguments are used both locally and in CI.

```yaml title=".moon/toolchain.yml" {2}
bun:
  installArgs: ['--frozen-lockfile']
```

### Inherited from `node`

Since Bun and Node.js have a lot of overlap in functionality, the following [`node`](#node) settings
can also be configured within `bun`:

- [`dependencyVersionFormat`](#dependencyversionformat)
- [`inferTasksFromScripts`](#infertasksfromscripts)
- [`rootPackageOnly`](#rootpackageonly)
- [`syncProjectWorkspaceDependencies`](#syncprojectworkspacedependencies)

```yaml title=".moon/toolchain.yml" {2-4}
bun:
  dependencyVersionFormat: 'workspace'
  inferTasksFromScripts: true
  rootPackageOnly: true
  syncProjectWorkspaceDependencies: true
```

## `deno`

Enables and configures [Deno](../guides/javascript/deno-handbook).

### `version`

Defines the explicit Deno toolchain
[version specification](../concepts/toolchain#version-specification) to use. If this field is _not
defined_, the global `deno` binary will be used.

```yaml title=".moon/toolchain.yml" {2}
deno:
  version: '1.40.0'
```

### `bins`

A list of binaries to install globally into Deno (`~/.deno/bin`). This setting requires a list of
URLs or binary configuration objects with the following fields:

- `bin` (required) - URL of the binary.
- `name` - Provide a custom name for the binary.
- `local` - Only install the binary locally, and not in CI.
- `force` - Force install the binary. This _should_ be toggled for one-offs.

```yaml title=".moon/toolchain.yml" {2-5}
deno:
  bins:
    - 'https://deno.land/std@0.192.0/http/file_server.ts'
    - bin: 'https://deno.land/std@0.192.0/http/file_server.ts'
      name: 'fs'
```

### `depsFile`

Path to the
[dependencies file](https://deno.land/manual/basics/modules#it-seems-unwieldy-to-import-urls-everywhere)
that's used for re-exporting external libraries. This file is heavily used in hashing and caching
related scenarios. Defaults to `deps.ts`.

```yaml title=".moon/toolchain.yml" {2}
deno:
  depsFile: 'src/deps.ts'
```

### `installArgs`

Customize the arguments that will be passed to the `deno install` command (Deno >= v2), when the
`InstallDeps` action is triggered in the pipeline. These arguments are used both locally and in CI.

```yaml title=".moon/toolchain.yml" {2}
deno:
  installArgs: ['--frozen']
```

### `lockfile`

Enables lockfile (`deno.lock`) support for Deno dependencies. When enabled, will run `deno cache`
(v1) or `deno install` (v2+) as part of the dependency installation action. Defaults to `false`.

```yaml title=".moon/toolchain.yml" {2}
deno:
  lockfile: true
```

## `node`

Enables and configures [Node.js](../guides/javascript/node-handbook).

### `version`

Defines the explicit Node.js [version specification](../concepts/toolchain#version-specification) to
use. If this field is _not defined_, the global `node` binary will be used.

```yaml title=".moon/toolchain.yml" {2}
node:
  version: '16.13'
```

> Version can also be defined with [`.prototools`](../proto/config) or with the `MOON_NODE_VERSION`
> environment variable.

### `packageManager`

Defines which package manager to utilize. Supports `npm` (default), `pnpm`, `yarn`, or `bun`.

```yaml title=".moon/toolchain.yml" {2}
node:
  packageManager: 'yarn'
```

### `npm`, `pnpm`, `yarn`, `bun`

Optional fields for defining package manager specific configuration. The chosen setting is dependent
on the value of [`node.packageManager`](#packagemanager). If these settings _are not defined_, the
latest version of the active package manager will be used (when applicable).

#### `version`

The `version` setting defines the explicit package manager
[version specification](../concepts/toolchain#version-specification) to use. If this field is _not
defined_, the global `npm`, `pnpm`, `yarn`, and `bun` binaries will be used.

```yaml title=".moon/toolchain.yml" {4}
node:
  packageManager: 'yarn'
  yarn:
    version: '3.1.0'
```

> Version can also be defined with [`.prototools`](../proto/config) or with the `MOON_NPM_VERSION`,
> `MOON_PNPM_VERSION`, `MOON_YARN_VERSION`, or `MOON_BUN_VERSION` environment variables.

#### `installArgs`

Customize the arguments that will be passed to the package manager's install command, when the
`InstallDeps` action is triggered in the pipeline. These arguments are used both locally and in CI.

```yaml title=".moon/toolchain.yml" {4}
node:
  packageManager: 'yarn'
  yarn:
    installArgs: ['--immutable']
```

### `yarn`

#### `plugins`

A list of plugins that will automatically be imported using `yarn plugin import` (Yarn 2+ only). For
performance reasons, plugins will only be imported when the Yarn version changes.

```yaml title=".moon/toolchain.yml" {4}
node:
  packageManager: 'yarn'
  yarn:
    version: '3.1.0'
    plugins:
      - 'interactive-tools'
      - 'workspace-tools'
```

### `addEnginesConstraint`

Injects the currently configured [Node.js version](#version) as an `engines` constraint to the root
`package.json` field. Defaults to `true`.

```yaml
node:
  addEnginesConstraint: true
```

For example, say our Node.js version is "16.15.0", and when we execute a run process through the
`moon` binary, it will update the root `package.json` with the below. We pin a fixed version to
ensure other Node.js processes outside of our toolchain are utilizing the same version.

```json title="package.json"
{
  // ...
  "engines": {
    "node": "16.15.0"
  }
}
```

### `binExecArgs`

Additional [command line arguments](https://nodejs.org/api/cli.html) to pass to the `node` binary
when it's being executed by running a target. This will apply arguments to _all Node.js based_
targets, and cannot be changed on a per target basis.

```yaml title=".moon/toolchain.yml" {2-5}
node:
  binExecArgs:
    - '--preserve-symlinks'
    - '--loader'
    - '@boost/module/loader'
```

### `dedupeOnLockfileChange`

Will dedupe dependencies after they have been installed, added, removing, or changed in any way, in
an effort to keep the workspace tree as clean and lean as possible. Defaults to `true`.

```yaml title=".moon/toolchain.yml" {2}
node:
  dedupeOnLockfileChange: true
```

### `dependencyVersionFormat`

When [syncing project dependencies](#syncprojectworkspacedependencies), customize the format that
will be used for the dependency version range. The following formats are supported (but use the one
most applicable to your chosen package manager):

- `file` (npm default) - Uses `file:../relative/path` and copies package contents.
- `link` - Uses `link:../relative/path` and symlinks package contents.
- `star` - Uses an explicit `*`.
- `version` - Uses the explicit version from the dependent project's `package.json`, e.g., "1.2.3".
- `version-caret` - Uses the version from the dependent project's `package.json` as a caret range,
  e.g., "^1.2.3".
- `version-tilde` - Uses the version from the dependent project's `package.json` as a tilde range,
  e.g., "~1.2.3".
- `workspace` (bun/pnpm/yarn default) - Uses `workspace:*`, which resolves to "1.2.3". Requires
  package workspaces.
- `workspace-caret` - Uses `workspace:^`, which resolves to "^1.2.3". Requires package workspaces.
- `workspace-tilde` - Uses `workspace:~`, which resolves to "~1.2.3". Requires package workspaces.

```yaml title=".moon/toolchain.yml" {2}
node:
  dependencyVersionFormat: 'link'
```

> This setting does not apply to peer dependencies, as they will always use a format of
> `^.0.0`. Furthermore, if a package manager does not support a chosen format, it will
> fallback to another format!

### `inferTasksFromScripts`

Will infer and automatically create [tasks](../concepts/task) from `package.json` scripts. Defaults
to `false`.

This requires the [project's language](./project#language) to be "javascript" or "typescript", a
`package.json` to exist in the project, and will take the following into account:

- Script names will be converted to kebab-case, and will become the task ID.
- Pre, post, and life cycle hooks are ignored.
- Tasks defined in `.moon/tasks.yml` or `moon.yml` take precedence over scripts of the same name.

To verify inferred tasks, run [`moon project `](../commands/project) (pass `--json` to view raw
config and options). Tasks that are inferred will run through the configured package manager.

```yaml title=".moon/toolchain.yml" {2}
node:
  inferTasksFromScripts: true
```

:::caution

This implementation shares functionality with
[`moon migrate from-package-json`](../commands/migrate/from-package-json), and will attempt to
determine environment variables, outputs, CI options, and more! Be aware of these when utilizing
this feature, especially in regards to `runInCI`, as it may be inaccurate!

:::

### `rootPackageOnly`

Supports the "single version policy" or "one version rule" patterns by only allowing dependencies in
the root `package.json`, and only installing dependencies in the workspace root, and not within
individual projects. It also bypasses all `workspaces` checks to determine package locations.
Defaults to `false`.

```yaml title=".moon/toolchain.yml" {2}
node:
  rootPackageOnly: true
```

:::info

This setting _does not_ verify that other `package.json`s _do not_ have dependencies, it merely runs
"install dependency" commands in the root. It's up to you to ensure that other `package.json`s do
not have dependencies.

:::

### `syncPackageManagerField`

Will sync the currently configured [package manager](#packagemanager) and its version to the
`packageManager` field in the root `package.json`. This setting does nothing if the package manager
or version is not defined. Defaults to `true`.

```yaml title=".moon/toolchain.yml" {2}
node:
  syncPackageManagerField: true
  packageManager: pnpm
  pnpm:
    version: '9.0.0'
```

A quick example on how this works. Given the above, the following field will be injected:

```json title="package.json"
{
  // ...
  "packageManager": "pnpm@9.0.0"
}
```

### `syncProjectWorkspaceDependencies`

Will sync a project's [dependencies](../concepts/project#dependencies) as normal dependencies within
the project's `package.json`. If a dependent project does not have a `package.json`, or if a
dependency of the same name has an explicit version already defined, the sync will be skipped.
Defaults to `true`.

```yaml title=".moon/toolchain.yml" {2}
node:
  syncProjectWorkspaceDependencies: true
```

A quick example on how this works. Given the following `dependsOn`:

```yaml title="moon.yml"
dependsOn:
  - 'designSystem'
  - 'reactHooks'
```

Would result in the following `dependencies` within a project's `package.json`. The version format
can be customized with [`node.dependencyVersionFormat`](#dependencyversionformat).

```json title="package.json"
{
  // ...
  "dependencies": {
    "@company/design-system": "workspace:*",
    "@company/react-hooks": "workspace:*"
    // ...
  }
}
```

### `syncVersionManagerConfig`

Will sync the currently configured [Node.js version](#version) to a 3rd-party version manager's
config/rc file. Supports "nodenv" (syncs to `.node-version`), "nvm" (syncs to `.nvmrc`), or none
(default).

```yaml title=".moon/toolchain.yml" {2}
node:
  syncVersionManagerConfig: 'nvm'
```

This is a special setting that ensure other Node.js processes outside of our toolchain are utilizing
the same version, which is a very common practice when managing dependencies.

## `typescript`

Dictates how moon interacts with and utilizes TypeScript within the workspace. This field is
optional and is undefined by default. Define it to enable TypeScript support.

### `createMissingConfig`

When [syncing project references](#syncprojectreferences) and a depended on project _does not_ have
a `tsconfig.json`, automatically create one. Defaults to `true`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  createMissingConfig: true
```

### `includeProjectReferenceSources`

When enabled and [syncing project references](#syncprojectreferences), will inject each project
reference as an entry in the `include` field of the respective project's `tsconfig.json`. These
includes are sometimes required by editors for auto-completion, intellisense, and automatic imports.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  includeProjectReferenceSources: true
```

To demonstrate this, we'll use the example from [`syncProjectReferences`](#syncprojectreferences).
When this setting is enabled, the `include` field will also be populated.

```json title="tsconfig.json"
{
  // ...
  "include": ["../../design-system/**/*", "../../react-hooks/**/*"],
  "references": [
    // ...
    { "path": "../../design-system" },
    { "path": "../../react-hooks" }
  ]
}
```

### `includeSharedTypes`

When enabled, will automatically inject shared types (`types/**/*`) into the `include` field of each
project's `tsconfig.json`. The shared types folder _must_ be named `types` and must exist relative
to the [`root`](#root) setting. Defaults to `false`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  includeSharedTypes: true
```

As a demonstration, if we had a package located at "packages/components", the `include` setting will
be appended with:

```json title="/tsconfig.json"
{
  // ...
  "include": ["../../types/**/*"]
}
```

### `projectConfigFileName`

Defines the file name of the `tsconfig.json` found in the project root. We utilize this setting when
syncing project references between projects. Defaults to `tsconfig.json`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  projectConfigFileName: 'tsconfig.build.json'
```

### `root`

Defines the TypeScript root (relative from moon's workspace root), where project reference
composition, common compiler options, and shared types will be located. Defaults to `.`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  root: './types'
```

### `rootConfigFileName`

Defines the file name of the `tsconfig.json` found in the root of all projects. We utilize this
setting when syncing projects as references. Defaults to `tsconfig.json`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  rootConfigFileName: 'tsconfig.projects.json'
```

### `rootOptionsConfigFileName`

Defines the file name of the config file found in the root that houses shared compiler options.
Defaults to `tsconfig.options.json`. This setting is used in the following scenarios:

- When [creating a `tsconfig.json` for a project](#), sets the `extends` field to this value.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  rootOptionsConfigFileName: 'tsconfig.base.json'
```

### `routeOutDirToCache`

Updates the `outDir` compiler option in each project's [`tsconfig.json`](#projectconfigfilename) to
route to moon's cache folder. This is useful when using project references and wanting to keep all
the compiled `.d.ts` files _out_ of the project folder. Defaults to `false`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  routeOutDirToCache: true
```

As a demonstration, if we had a package located at "packages/components", the `outDir` compiler
option will be re-routed to the following when syncing.

```json title="/tsconfig.json"
{
  // ...
  "compilerOptions": {
    // ...
    "outDir": "../../.moon/cache/types/packages/components"
  }
}
```

### `syncProjectReferences`

Will sync a project's [dependencies](../concepts/project#dependencies) (when applicable) as project
references within that project's `tsconfig.json`, and the root `tsconfig.json`. Defaults to `true`
when the parent `typescript` setting is defined, otherwise `false`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  syncProjectReferences: true
```

A quick example on how this works. Given the following dependencies:

```yaml title="moon.yml"
dependsOn:
  - 'designSystem'
  - 'reactHooks'
```

Would result in the following `references` within both `tsconfig.json`s.

```json title="tsconfig.json"
{
  // ...
  "references": [
    // ...
    { "path": "../../design-system" },
    { "path": "../../react-hooks" }
  ]
}
```

:::info

This setting assumes you're using the file organization as defined in our official
[TypeScript project references](../guides/javascript/typescript-project-refs) in-depth guide.

:::

### `syncProjectReferencesToPaths`

Will sync a project's [`tsconfig.json`](#projectconfigfilename) project references to the `paths`
compiler option, using the referenced project's `package.json` name. This is useful for mapping
aliases to their source code. Defaults to `false`.

```yaml title=".moon/toolchain.yml" {2}
typescript:
  syncProjectReferencesToPaths: true
```

As a demonstration, if we had a reference to a shared package with the name `@brand/components`, the
`paths` compiler option would be updated to the following when syncing.

If an index file exists, we'll map a default import. Otherwise, we'll always map a wildcard import.
Both imports can optionally be nested within a `src` directory.

```json title="/tsconfig.json"
{
  // ...
  "compilerOptions": {
    // ...
    "paths": {
      "@brand/components": ["../shared/components/src/index.ts"],
      "@brand/components/*": ["../shared/components/src/*"]
    }
  },
  "references": [
    {
      "path": "../shared/components"
    }
  ]
}
```

> This setting runs _after_ [`syncProjectReferences`](#syncprojectreferences) and will inherit any
> synced references from that setting.

## Python

## `python`

Enables and configures [Python](https://www.python.org/).

### `version`

Defines the explicit Python toolchain
[version specification](../concepts/toolchain#version-specification) to use. If this field is _not
defined_, the global `python` binary will be used.

```yaml title=".moon/toolchain.yml" {2}
python:
  version: '3.11.10'
```

:::info

Python installation's are based on pre-built binaries provided by
[indygreg/python-build-standalone](https://github.com/indygreg/python-build-standalone).

:::

> Version can also be defined with [`.prototools`](../proto/config).

### `packageManager`

Defines which package manager to utilize. Supports `pip` (default) or `uv`.

```yaml title=".moon/toolchain.yml" {2}
python:
  packageManager: 'uv'
```

### `rootVenvOnly`

Supports the "single version policy" or "one version rule" patterns by only allowing dependencies in
the root `requirements.txt` (pip) or `uv.lock` (uv), and only installing dependencies in the
workspace root, and not within individual projects. It also bypasses all `workspaces` checks to
determine package locations.

```yaml title=".moon/toolchain.yml" {2}
python:
  rootVenvOnly: true
```

### `venvName`

Defines the virtual environment name, which will be created in the workspace or project root when a
`requirements.txt` exists, and where dependencies will be installed into. Defaults to `.venv`

```yaml title=".moon/toolchain.yml" {2}
python:
  venvName: '.my-custom-venv'
```

### `pip`

Optional fields for defining pip specific configuration.

#### `installArgs`

Customize the arguments that will be passed to the pip install command, when the `InstallDeps`
action is triggered in the pipeline. These arguments are used both locally and in CI.

```yaml title=".moon/toolchain.yml" {3}
python:
  pip:
    installArgs: ['--trusted-host company.repo.com', '-i https://company.repo.com/simple']
```

### `uv`

Optional fields for defining uv specific configuration.

#### `syncArgs`

Customize the arguments that will be passed to the uv sync command, when the `InstallDeps` action is
triggered in the pipeline. These arguments are used both locally and in CI.

```yaml title=".moon/toolchain.yml" {4}
python:
  packageManager: 'uv'
  uv:
    syncArgs: ['--all-packages']
```

#### `version`

Defines the explicit uv toolchain
[version specification](../concepts/toolchain#version-specification) to use. If this field is _not
defined_, the global `uv` binary will be used.

```yaml title=".moon/toolchain.yml" {4}
python:
  packageManager: 'uv'
  uv:
    version: '0.5.26'
```

## Rust

## `rust`

Enables and configures [Rust](../guides/rust/handbook).

### `version`

Defines the explicit Rust toolchain
[version/channel specification](../concepts/toolchain#version-specification) to use. If this field
is _not defined_, the global `cargo`, `rustc`, and other binaries will be used.

```yaml title=".moon/toolchain.yml" {2}
rust:
  version: '1.69.0'
```

> Version can also be defined with [`.prototools`](../proto/config).

### `bins`

A list of binaries (with optional versions) to install into Cargo (`~/.cargo/bin`), and make them
available to the `cargo` command. Binaries will be installed with
[`cargo-binstall`](https://crates.io/crates/cargo-binstall) in an effort to reduce build and
compilation times.

This setting requires a list of package names or binary configuration objects with the following
fields:

- `bin` (required) - Name of the binary.
- `local` - Only install the binary locally, and not in CI.
- `force` - Force install the binary. This _should_ be toggled for one-offs.

```yaml title=".moon/toolchain.yml" {2-5}
rust:
  bins:
    - 'cargo-nextest@0.9.52'
    - bin: 'cargo-nextest'
      local: true
```

Binaries that have been installed into Cargo can be referenced from task commands:

```yaml title="/moon.yml"
tasks:
  test:
    command: 'nextest run --workspace'
```

### `binstallVersion`

The version of [`cargo-binstall`](https://crates.io/crates/cargo-binstall) to install if it does not
already exist. Defaults to "latest" if not configured.

```yaml title=".moon/toolchain.yml" {2}
rust:
  binstallVersion: '1.10.12'
```

### `components`

A list of additional [components](https://rust-lang.github.io/rustup/concepts/components.html) to
automatically install with `rustup` for the current toolchain. Will be installed when the pipeline
is first ran, and subsequently when configuration changes.

```yaml title=".moon/toolchain.yml" {2-4}
rust:
  components:
    - 'rust-docs'
    - 'rust-analyzer'
```

### `syncToolchainConfig`

Will automatically sync the currently configured [Rust `version`](#version-2) to the
`toolchain.channel` field in `rust-toolchain.toml`, relative to the root `Cargo.lock`. If the file
does not exist, it will be created.

This is a special setting that ensures other Rust/Cargo processes outside of our toolchain are
utilizing the same version, which is a very common practice.

```yaml title=".moon/toolchain.yml" {2,3}
rust:
  version: '1.69.0'
  syncToolchainConfig: true
```

To demonstrate this, the settings above would sync the following file:

```toml title="rust-toolchain.toml"
[toolchain]
channel = "1.69.0"
```

### `targets`

A list of additional [targets](https://rust-lang.github.io/rustup/cross-compilation.html) to
automatically install with `rustup` for the current toolchain. Will be installed when the pipeline
is first ran, and subsequently when configuration changes.

```yaml title=".moon/toolchain.yml" {2-4}
rust:
  targets:
    - 'aarch64-unknown-linux-gnu'
    - 'wasm32-wasi'
```

> Targets are currently _not scoped_ based on operating system, and will be installed for all
> machines.

## `unstable_rust`

Enables and configures [Rust](../guides/rust/handbook). This setting enables the new WASM powered
Rust toolchain, which is far more accurate and efficient, but still unstable.

Supports all the same settings as [`rust`](#rust), with the addition of:

### `addMsrvConstraint`

When `version` is defined, syncs the version as a constraint to `Cargo.toml` under the
`workspace.package.rust-version` or `package.rust-version` fields.

```yaml title=".moon/toolchain.yml" {2}
unstable_rust:
  addMsrvConstraint: true
```

---

## .moon/workspace.{pkl,yml}

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';
import RequiredLabel from '@site/src/components/Docs/RequiredLabel';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `.moon/workspace.yml` file configures projects and services in the workspace. This file is
_required_.

```yaml title=".moon/workspace.yml"
$schema: 'https://moonrepo.dev/schemas/workspace.json'
```

:::info

Workspace configuration can also be written in [Pkl](../guides/pkl-config) instead of YAML.

:::

## `extends`

Defines one or many external `.moon/workspace.yml`'s to extend and inherit settings from. Perfect
for reusability and sharing configuration across repositories and projects. When defined, this
setting must be an HTTPS URL _or_ relative file system path that points to a valid YAML document!

```yaml title=".moon/workspace.yml" {1}
extends: 'https://raw.githubusercontent.com/organization/repository/master/.moon/workspace.yml'
```

:::info

Settings will be merged recursively for blocks, with values defined in the local configuration
taking precedence over those defined in the extended configuration. However, the `projects` setting
_does not merge_!

:::

## `projects`

Defines the location of all [projects](../concepts/project) within the workspace. Supports either a
manual map of projects (default), a list of globs in which to automatically locate projects, _or_
both.

:::caution

Projects that depend on each other and form a cycle must be avoided! While we do our best to avoid
an infinite loop and disconnect nodes from each other, there's no guarantee that tasks will run in
the correct order.

:::

### Using a map

When using a map, each project must be _manually_ configured and requires a unique
[name](../concepts/project#names) as the map key, where this name is used heavily on the command
line and within the project graph for uniquely identifying the project amongst all projects. The map
value (known as the project source) is a file system path to the project folder, relative from the
workspace root, and must be contained within the workspace boundary.

```yaml title=".moon/workspace.yml"
projects:
  admin: 'apps/admin'
  apiClients: 'packages/api-clients'
  designSystem: 'packages/design-system'
  web: 'apps/web'
```

### Using globs

If manually mapping projects is too tedious or cumbersome, you may provide a list of
[globs](../concepts/file-pattern#globs) to automatically locate all project folders, relative from
the workspace root.

When using this approach, the project name is derived from the project folder name, and is cleaned
to our [supported characters](../concepts/project#names), but can be customized with the
[`id`](./project#id) setting in [`moon.yml`](./project). Furthermore, globbing **does risk the
chance of collision**, and when that happens, we log a warning and skip the conflicting project from
being configured in the project graph.

```yaml title=".moon/workspace.yml"
projects:
  - 'apps/*'
  - 'packages/*'
  # Only shared folders with a moon configuration
  - 'shared/*/moon.yml'
```

### Using a map _and_ globs

For those situations where you want to use _both_ patterns, you can! The list of globs can be
defined under a `globs` field, while the map of projects under a `sources` field.

```yaml title=".moon/workspace.yml"
projects:
  globs:
    - 'apps/*'
    - 'packages/*'
  sources:
    www: 'www'
```

## `codeowners`

Configures code owners (`CODEOWNERS`) integration across the entire workspace.

### `globalPaths`

This setting defines file patterns and their owners at the workspace-level, and are applied to any
matching path, at any depth, within the entire workspace. This is useful for defining global or
fallback owners when a granular [project-level path](./project#paths) does not match or exist.

```yaml title=".moon/workspace.yml" {2-5}
codeowners:
  globalPaths:
    '*': ['@admins']
    'config/': ['@infra']
    '/.github/': ['@infra']
```

### `orderBy`

The order in which code owners, grouped by project, are listed in the `CODEOWNERS` file. Accepts
"file-source" (default) or "project-name".

```yaml title=".moon/workspace.yml" {2}
codeowners:
  orderBy: 'project-name'
```

### `syncOnRun`

Will automatically generate a `CODEOWNERS` file by aggregating and syncing all project
[`owners`](./project#owners) in the workspace when a [target is run](../concepts/target). The format
and location of the `CODEOWNERS` file is based on the [`vcs.provider`](#provider) setting. Defaults
to `false`.

```yaml title=".moon/workspace.yml" {2}
codeowners:
  syncOnRun: true
```

## `constraints`

Configures constraints between projects that are enforced during project graph generation. This is
also known as project boundaries.

### `enforceLayerRelationships`

> This was previously known as `enforceProjectTypeRelationships` and was renamed to
> `enforceLayerRelationships` in v1.39.

Enforces allowed relationships between a project and its dependencies based on the project's
[`layer`](./project#layer) and [`stack`](./project#stack) settings. When a project depends on
another project of an invalid layer, a layering violation error will be thrown when attempting to
run a task.

Layers are allowed to depend on lower layers in the same stack, but not higher layers. Additionally,
layers may depend on itself, excluding automations and applications. The following layers are
stacked as such:

| Layer           | Description                                                         |
| --------------- | ------------------------------------------------------------------- |
| `automation`    | An automated testing suite, like E2E, integration, or visual tests. |
| `application`   | An application of any kind.                                         |
| `tool`          | An internal tool, CLI, one-off script, etc.                         |
| `library`       | A self-contained, shareable, and publishable set of code.           |
| `scaffolding`   | Templates or generators for scaffolding.                            |
| `configuration` | Configuration files or infrastructure.                              |
| `unknown`       | When not configured.                                                |

When the project `stack` setting is defined, it alters these rules to allow these kinds of
relationships. For example, a frontend application can depend on a backend application, but not
another frontend application.

```yaml title=".moon/workspace.yml" {2}
constraints:
  enforceLayerRelationships: false
```

> Projects with an unconfigured or unknown layer are ignored during enforcement.

### `tagRelationships`

Enforces allowed relationships between a project and its dependencies based on the project's
[`tags`](./project#tags) setting. This works in a similar fashion to `enforceLayerRelationships`,
but gives you far more control over what these relationships look like.

For example, let's enforce that Next.js projects using the `next` tag can only depend on React
projects using the `react` tag. If a dependency does not have one of the configured required tags,
in this case `react`, an error will occur.

```yaml title=".moon/workspace.yml" {2,3}
constraints:
  tagRelationships:
    next: ['react']
```

On the project side, we would configure [`moon.yml`](./project#tags) like so:

```yaml title="app/moon.yml"
tags: ['next']
dependsOn: ['components']
```

```yaml title="packages/components/moon.yml"
tags: ['react']
```

## `docker`

Configures Docker integration for the entire workspace.

### `prune`

Configures aspects of the Docker pruning process when
[`moon docker prune`](../commands/docker/prune) is executed.

#### `deleteVendorDirectories`

Automatically delete vendor directories (package manager dependencies, build targets, etc) while
pruning. For example, `node_modules` for JavaScript, or `target` for Rust. Defaults to `true`.

```yaml title=".moon/workspace.yml" {3}
docker:
  prune:
    deleteVendorDirectories: false
```

> This process happens before toolchain dependencies are installed.

#### `installToolchainDeps`

Automatically install production dependencies for all required toolchain's of the focused projects
within the Docker build. For example, `node_modules` for JavaScript. Defaults to `true`.

```yaml title=".moon/workspace.yml" {3}
docker:
  prune:
    installToolchainDeps: false
```

> This process happens after vendor directories are deleted.

### `scaffold`

Configures aspects of the Docker scaffolding process when
[`moon docker scaffold`](../commands/docker/scaffold) is executed. Only applies to the
[workspace skeleton](../commands/docker/scaffold#workspace).

#### `copyToolchainFiles`

Copy all toolchain specific configs, manifests, and related files in the entire repository into the
`.moon/docker/workspace` skeleton. This is required for certain tools, like package managers, to
work correctly. Defaults to `true`.

```yaml title=".moon/workspace.yml" {3}
docker:
  scaffold:
    copyToolchainFiles: false
```

> If you disable this feature, you'll most likely need to manually `COPY` all necessary files in
> your `Dockerfile`.

#### `include`

List of globs in which to copy additional workspace-relative files into the `.moon/docker/workspace`
skeleton. When not defined, does nothing.

```yaml title=".moon/workspace.yml" {3,4}
docker:
  scaffold:
    include:
      - '**/package.json'
```

## `experiments`

Enable or disable experiments that alter core functionality.

:::warning

Experiments are a work in progress and may be buggy. Please report any issues you encounter!

:::

### `fasterGlobWalk`

Utilizes a new concurrent glob walking implementation that is on average, 1.5-2x faster than the
current implementation. Additionally, common globs are now cached for the duration of the process.
Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
experiments:
  fasterGlobWalk: true
```

### `gitV2`

Utilizes a Git implementation, that has better support for submodules, subtrees, and workspaces.
Additionally, processes are parallized when applicable. Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
experiments:
  gitV2: true
```

## `extensions`

A mapping of extensions that can be downloaded and executed with the [`moon ext`](../commands/ext)
command. An extension is a WASM plugin, and the location of the WASM file must be defined with the
`plugin` field, which requires a
[plugin locator string](../guides/wasm-plugins#configuring-plugin-locations).

```yaml title=".moon/workspace.yml" {2-5}
extensions:
  example:
    plugin: 'file://./path/to/example.wasm'
    # or
    plugin: 'https://example.com/path/to/example.wasm'
```

Additionally, extensions support custom configuration that is passed to the WASM runtime when the
plugin is instantiated. This configuration is defined by inserting additional fields under the
extension name, relative to the `plugin` field. Each extension may have its own settings, so refer
to their documentation for more information.

```yaml title=".moon/workspace.yml" {2-5}
extensions:
  example:
    plugin: 'file://./path/to/example.wasm'
    setting1: true
    setting2: 'abc'
```

:::info

View our official [extensions guide](../guides/extensions) for more information, including built-in
extensions!

:::

## `generator`

Configures aspects of the template generator.

### `templates`

A list of paths in which templates can be located. Supports the following types of paths, and
defaults to `./templates`.

- File system paths, relative from the workspace root.
- Git repositories and a revision, prefixed with `git://`. 
- npm packages and a version, prefixed with `npm://`. 

```yaml title=".moon/workspace.yml" {2-4}
generator:
  templates:
    - './templates'
    - 'file://./other/templates'
    - 'git://github.com/moonrepo/templates#master'
    - 'npm://@moonrepo/templates#1.2.3'
```

> Learn more about this in the official
> [code generation guide](../guides/codegen#configuring-template-locations)!

## `hasher`

Configures aspects of the smart hashing layer.

### `batchSize`

> This setting is deprecated!

When hashing a list of files, we split the list into batches to help reduce memory footprint and
avoid overloading the configured VCS. This setting controls how many files are in each batch and
defaults to `2500`.

If you're running into memory issues, or moon hanging during the file hashing process, lowering this
number may help resolve the issue.

```yaml title=".moon/workspace.yml" {2}
hasher:
  batchSize: 1000
```

### `ignoreMissingPatterns`

When [`hasher.warnOnMissingInputs`](#warnonmissinginputs) is enabled, moon will log a warning to the
terminal that an input is missing. This is useful for uncovering misconfigurations, but can be quite
noisy when inputs are truly optional.

To ignore warnings for missing inputs, a list of [glob patterns](../concepts/file-pattern#globs) can
be configured to filter and ignore files. Files are matched against workspace relative paths, so
prefixing patterns with `**/` is suggested.

```yaml title=".moon/workspace.yml" {2-4}
hasher:
  ignoreMissingPatterns:
    - '**/.eslintrc.*'
    - '**/*.config.*'
```

### `ignorePatterns`

A list of [glob patterns](../concepts/file-pattern#globs) used to filter and ignore files during the
inputs hashing process. Files are matched against workspace relative paths, so prefixing patterns
with `**/` is suggested.

```yaml title=".moon/workspace.yml" {2,3}
hasher:
  ignorePatterns:
    - '**/*.png'
```

### `optimization`

Determines the optimization level to utilize when hashing content before running targets.

- `accuracy` (default) - When hashing dependency versions, utilize the resolved value in the
  lockfile. This requires parsing the lockfile, which may reduce performance.
- `performance` - When hashing dependency versions, utilize the value defined in the manifest. This
  is typically a version range or requirement.

```yaml title=".moon/workspace.yml" {2}
hasher:
  optimization: 'performance'
```

### `walkStrategy`

Defines the file system walking strategy to utilize when discovering inputs to hash.

- `glob` - Walks the file system using glob patterns.
- `vcs` (default) - Calls out to the [VCS](#vcs) to extract files from its working tree.

```yaml title=".moon/workspace.yml" {2}
hasher:
  walkStrategy: 'glob'
```

### `warnOnMissingInputs`

When enabled, will log warnings to the console when attempting to hash an input that does not exist.
This is useful in uncovering misconfigured tasks. Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
hasher:
  warnOnMissingInputs: false
```

## `notifier`

Configures how moon notifies and interacts with a developer or an external system.

### `terminalNotifications`

When defined, will display OS notifications for action pipeline events when running commands from a
terminal. Supports the following values:

- `always` - Display on pipeline success and failure.
- `failure` - Display on pipeline failure only.
- `success` - Display on pipeline success only.
- `task-failure` - Display for each task failure.

```yaml title=".moon/workspace.yml" {2}
notifier:
  terminalNotifications: 'always'
```

### `webhookUrl`

Defines an HTTPS URL that all pipeline events will be posted to. View the
[webhooks guide for more information](../guides/webhooks) on available events.

```yaml title=".moon/workspace.yml" {2}
notifier:
  webhookUrl: 'https://api.company.com/some/endpoint'
```

### `acknowledge`

When enabled, webhook notfier will wait for request result and validates the return code for 2xx.
Defaults to `false`.

:::warning

Activating this setting will slow down your pipeline, because every webhook request will be
evaluated!

:::

```yaml title=".moon/workspace.yml" {2}
notifier:
  webhookUrl: 'https://api.company.com/some/endpoint'
  webhookAcknowledge: true
```

## `pipeline`

Configures aspects of task running and the action pipeline.

### `archivableTargets`

:::info

This setting is deprecated and purely existed for moonbase, our old cloud remote caching service.
Going forward, if using Bazel Remote Caching, all tasks are automatically cached (archived).

:::

Defines a list of [targets](../concepts/target), with or without scope, that will be cached and
archived within the pipeline. Tasks that produce [outputs](./project#outputs) are automatically
archived, and do not need to be defined here. Defaults to an empty list.

```yaml title=".moon/workspace.yml" {2-4}
pipeline:
  archivableTargets:
    - ':test'
    - 'app:typecheck'
```

> This setting primarily exists for [remote caching](../guides/remote-cache) as it will create and
> persist tar archives located in `.moon/cache/outputs`.

### `autoCleanCache`

Automatically cleans cached artifacts older than [`cacheLifetime`](#cachelifetime) from the cache
directory (`.moon/cache`) after every run. This is useful for keeping the cache directory lean.
Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  autoCleanCache: false
```

### `cacheLifetime`

The maximum lifetime of cached artifacts before they're marked as stale and automatically removed by
the action pipeline. Defaults to "7 days". This field requires an integer and a timeframe unit that
can be [parsed as a duration](https://docs.rs/humantime/2.1.0/humantime/fn.parse_duration.html).

```yaml title=".moon/workspace.yml" {2}
pipeline:
  cacheLifetime: '24 hours'
```

### `inheritColorsForPipedTasks`

Force colors to be inherited from the current terminal for all tasks that are ran as a child process
and their output is piped to the action pipeline. Defaults to `true`.
[View more about color handling in moon](../commands/overview#colors).

```yaml title=".moon/workspace.yml" {2}
pipeline:
  inheritColorsForPipedTasks: true
```

### `installDependencies`

When enabled, runs the
[`InstallWorkspaceDeps` and `InstallProjectDeps` actions](../how-it-works/action-graph#install-dependencies)
within the pipeline before running an applicable task. Installation is determined based on changed
manifests and lockfiles. Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  installDependencies: false
```

Instead of a boolean, a list of toolchain IDs can be provided to only allow those toolchains to
install dependencies.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  installDependencies: ['node']
```

### `killProcessThreshold`

Threshold in milliseconds in which to force kill running child processes after the pipeline receives
an external signal (like `SIGINT` or `SIGTERM`). A value of 0 will not kill the process and let them
run to completion. Defaults to `2000` (2 seconds).

```yaml title=".moon/workspace.yml" {2}
pipeline:
  killProcessThreshold: 5000
```

### `logRunningCommand`

When enabled, will log the task's command, resolved arguments, and working directory when a target
is ran. Defaults to `false`.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  logRunningCommand: true
```

### `syncProjects`

When enabled, runs the [`SyncProject` action](../how-it-works/action-graph#sync-project) within the
pipeline before running an applicable task. Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  syncProjects: false
```

Instead of a boolean, a list of project IDs can be provided to only sync those projects.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  syncProjects: ['app']
```

> The [`moon sync projects`](../commands/sync/projects) command can be executed to manually sync
> projects.

### `syncWorkspace`

When enabled, runs the [`SyncWorkspace` action](../how-it-works/action-graph#sync-workspace) within
the pipeline before all other actions. This syncing includes operations such as codeowners, VCS
hooks, and more. Defaults to `true`.

```yaml title=".moon/workspace.yml" {2}
pipeline:
  syncWorkspace: false
```

> The [`moon sync ...`](../commands/sync) sub-commands can be executed to manually sync features.

## `unstable_remote`

Configures a remote service, primarily for cloud-based caching of artifacts. Learn more about this
in the [remote caching](../guides/remote-cache) guide.

### `api`

The API format of the remote server. This format dictates which type of client moon uses for
communicating with. Supports the following:

- `grpc` (default) - Uses the gRPC API: https://github.com/bazelbuild/remote-apis
- `http` - Uses the HTTP API: https://bazel.build/remote/caching#http-caching

```yaml title=".moon/workspace.yml" {2}
unstable_remote:
  api: 'grpc'
```

### `auth`

Configures authorization and authentication level features of our remote clients.

#### `headers`

A mapping of HTTP headers to include in all requests to the remote server. These headers are applied
to all [API formats and protocols](#api), not just HTTP.

```yaml title=".moon/workspace.yml" {2-4}
unstable_remote:
  auth:
    headers:
      'X-Custom-Header': 'value'
```

#### `token`

The name of an environment variable in which to extract a token for
[Bearer HTTP authorization](https://swagger.io/docs/specification/v3_0/authentication/bearer-authentication/).
An `Authorization` HTTP header will be included in all requests to the remote server.

If the token does not exist, or is not enabled, remote caching will be disabled.

```yaml title=".moon/workspace.yml" {2-4}
unstable_remote:
  auth:
    token: 'ENV_VAR_NAME'
```

### `cache`

Configures aspects of the caching layer, primarily the action cache (AC) and content addressable
cache (CAS).

#### `compression`

The compression format to use when uploading/downloading blobs. Supports `none` and `zstd`, and
defaults to no compression (`identity` format in RE API).

```yaml title=".moon/workspace.yml" {3}
unstable_remote:
  cache:
    compression: 'zstd'
```

:::info

Compression is only applied to gRPC based APIs, not HTTP.

:::

#### `instanceName`

A
[unique identifier](https://github.com/bazelbuild/remote-apis/blob/main/build/bazel/remote/execution/v2/remote_execution.proto#L223)
used to distinguish between the various instances on the host. This allows the same remote service
to serve and partition multiple moon repositories. Defaults to `moon-outputs`.

```yaml title=".moon/workspace.yml" {3}
unstable_remote:
  cache:
    instanceName: 'custom-dir-name'
```

> We suggest changing the instance name to the name of your repository!

#### `verifyIntegrity`

When downloading blobs, verify the digests/hashes in the response match the associated blob
contents. This will reduce performance but ensure partial or corrupted blobs won't cause failures.
Defaults to `false`.

```yaml title=".moon/workspace.yml" {3}
unstable_remote:
  cache:
    verifyIntegrity: true
```

### `host`

The host URL to communicate with when uploading and downloading artifacts. Supports both
`grpc(s)://` and `http(s)://` protocols. This field is required!

```yaml title=".moon/workspace.yml" {2}
unstable_remote:
  host: 'grpcs://your-host.com:9092'
```

### `mtls`

Connect to the host using server and client authentication with mTLS. This takes precedence over
normal TLS.

```yaml title=".moon/workspace.yml" {3-7}
unstable_remote:
  # ...
  mtls:
    caCert: 'certs/ca.pem'
    clientCert: 'certs/client.pem'
    clientKey: 'certs/client.key'
    domain: 'your-host.com'
```

#### `assumeHttp2`

If true, assume that the host supports HTTP/2, even if it doesn't provide protocol negotiation via
ALPN.

#### `caCert`

A file path, relative from the workspace root, to the certificate authority PEM encoded X509
certificate (typically `ca.pem`).

#### `clientCert`

A file path, relative from the workspace root, to the client's PEM encoded X509 certificate
(typically `client.pem`).

#### `clientKey`

A file path, relative from the workspace root, to the client's PEM encoded X509 private key
(typically `client.key`).

#### `domain`

The domain name in which to verify the TLS certificate.

### `tls`

Connect to the host using server-only authentication with TLS.

```yaml title=".moon/workspace.yml" {3-5}
unstable_remote:
  # ...
  tls:
    cert: 'certs/ca.pem'
    domain: 'your-host.com'
```

#### `assumeHttp2`

If true, assume that the host supports HTTP/2, even if it doesn't provide protocol negotiation via
ALPN.

#### `cert`

A file path, relative from the workspace root, to the certificate authority PEM encoded X509
certificate (typically `ca.pem`).

#### `domain`

The domain name in which to verify the TLS certificate.

## `runner`

This setting was renamed to [`pipeline`](#pipeline) but still works for backwards compatibility.

## `telemetry`

When enabled, will check for a newer moon version and send anonymous usage data to the moonrepo
team. This data is used to improve the quality and reliability of the tool. Defaults to `true`.

```yaml title=".moon/workspace.yml" {1}
telemetry: false
```

## `vcs`

Configures the version control system to utilize within the workspace (and repository). A VCS is
required for determining touched (added, modified, etc) files, calculating file hashes, computing
affected files, and much more.

### `defaultBranch`

Defines the default branch in the repository for comparing differences against. For git, this is
typically "master" (default) or "main".

```yaml title=".moon/workspace.yml" {2}
vcs:
  defaultBranch: 'master'
```

### `hooks`

Defines a mapping of hooks to a list of commands to run when that event is triggered. There are no
restrictions to what commands can be run, but the binaries for each command must exist on each
machine that will be running hooks.

For Git, each [hook name](https://git-scm.com/docs/githooks#_hooks) must be a valid kebab-cased
name. [Learn more about Git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks).

```yaml title=".moon/workspace.yml" {2-5}
vcs:
  hooks:
    pre-commit:
      - 'moon run :lint :format --affected --status=staged --no-bail'
      - 'another-command'
```

:::info

If running `moon` commands directly, the `moon` binary must be installed globally!

:::

### `hookFormat`

The shell and file type in which generated hook files are formatted with. Supports the following:

- `native` (default) - The format native to the current operating system. Bash on Unix, and
  PowerShell on Windows.
- `bash` - Forces the format to Bash for all operating systems.

```yaml title=".moon/workspace.yml" {2}
vcs:
  hookFormat: 'bash'
```

### `manager`

Defines the VCS tool/binary that is being used for managing the repository. Accepts "git" (default).
Expect more version control systems in the future!

```yaml title=".moon/workspace.yml" {2}
vcs:
  manager: 'git'
```

### `provider`

Defines the service provider that the repository is hosted on. Accepts "github" (default), "gitlab",
"bitbucket", or "other".

```yaml title=".moon/workspace.yml" {2}
vcs:
  provider: 'github'
```

### `remoteCandidates`

(Git only) Defines a list of remote candidates to query against to determine merge bases. Defaults
to "origin" and "upstream".

```yaml title=".moon/workspace.yml" {2-4}
vcs:
  remoteCandidates:
    - 'origin'
    - 'upstream'
```

### `syncHooks`

Will automatically generate [hook scripts](#hooks) to `.moon/hooks` and sync the scripts to the
local VCS checkout. The hooks format and location is based on the [`vcs.manager`](#manager) setting.
Defaults to `false`.

```yaml title=".moon/workspace.yml" {4}
vcs:
  hooks:
    # ...
  syncHooks: true
```

:::caution

When enabled, this will sync hooks for _all_ users of the repository. For personal or small
projects, this may be fine, but for larger projects, this may be undesirable and disruptive!

:::

## `versionConstraint`

Defines a version requirement for the currently running moon binary. This provides a mechanism for
enforcing that the globally installed moon on every developers machine is using an applicable
version.

```yaml title=".moon/workspace.yml" {1}
versionConstraint: '>=0.20.0'
```

---

## Create a project

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';
import LangPartials from '@site/src/components/LangPartials';

With a [workspace](./setup-workspace), we can now house one or many [projects](./concepts/project),
with a project being an application, library, or tool. In the end, each project will have its own
build layer, personal tasks, and custom configuration.

## Declaring a project in the workspace

Although a project may exist in your repository, it's not accessible from moon until it's been
mapped in the [`projects`](./config/workspace#projects) setting found in
[`.moon/workspace.yml`](./config/workspace). When mapping a project, we require a unique name for
the project, and a project source location (path relative from the workspace root).

Let's say we have a frontend web application called "client", and a backend application called
"server", our `projects` setting would look like the following.

```yaml title=".moon/workspace.yml"
projects:
  client: 'apps/client'
  server: 'apps/server'
```

We can now run [`moon project client`](./commands/project) and
[`moon project server`](./commands/project) to display information about each project. If these
projects were not mapped, or were pointing to an invalid source, the command would throw an error.

:::success

The [`projects`](./config/workspace#projects) setting also supports a list of globs, if you'd prefer
to not manually curate the projects list!

:::

## Configuring a project

A project can be configured in 1 of 2 ways:

- Through the [`.moon/tasks.yml`](./config/tasks) config file, which defines file groups and tasks
  that are inherited by _all_ projects within the workspace. Perfect for standardizing common tasks
  like linting, typechecking, and code formatting.
- Through the [`moon.yml`](./config/project) config file, found at the root of each project, which
  defines files groups, tasks, dependencies, and more that are unique to that project.

Both config files are optional, and can be used separately or together, the choice is yours!

Now let's continue with our client and server example above. If we wanted to configure both
projects, and define config that's also shared between the 2, we could do something like the
following:

```yaml title="apps/client/moon.yml"
tasks:
  build:
    command: 'vite dev'
    inputs:
      - 'src/**/*'
    outputs:
      - 'dist'
```

```yaml title="apps/server/moon.yml"
tasks:
  build:
    command: 'babel src --out-dir build'
    inputs:
      - 'src/**/*'
    outputs:
      - 'build'
```

```yaml title=".moon/tasks.yml"
tasks:
  format:
    command: 'prettier --check .'
  lint:
    command: 'eslint --no-error-on-unmatched-pattern .'
  test:
    command: 'jest --passWithNoTests .'
  typecheck:
    command: 'tsc --build'
```

### Adding optional metadata

When utilizing moon in a large monorepo or organization, ownership becomes very important, but also
difficult to maintain. To combat this problem, moon supports the
[`project`](./config/project#project) field within a project's [`moon.yml`](./config/project)
config.

This field is _optional_ by default, but when defined it provides metadata about the project,
specifically around team ownership, which developers maintain the project, where to discuss it, and
more!

Furthermore, we also support the [`layer`](./config/project#layer) and
[`language`](./config/project#language) settings for a more granular breakdown of what exists in the
repository.

```yaml title="/moon.yml"
layer: 'tool'
language: 'typescript'

project:
  name: 'moon'
  description: 'A repo management tool.'
  channel: '#moon'
  owner: 'infra.platform'
  maintainers: ['miles.johnson']
```

## Next steps

          Configure .moon/workspace.yml further
        
      ),
      url: './config/workspace',
    },
    {
      icon: 'project-config-global',
      label: (
        
          Configure .moon/tasks.yml further
        
      ),
      url: './config/tasks',
    },
    {
      icon: 'project-config',
      label: (
        
          Configure moon.yml further
        
      ),
      url: './config/project',
    },
    { icon: 'project', label: 'Learn about projects', url: './concepts/project' },
  ]}
/>

---

## Create a task

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';
import LangPartials from '@site/src/components/LangPartials';

The primary focus of moon is a task runner, and for it to operate in any capacity, it requires tasks
to run. In moon, a task is a binary or system command that is ran as a child process within the
context of a project (is the current working directory). Tasks are defined per project with
[`moon.yml`](./config/project), or inherited by many projects with
[`.moon/tasks.yml`](./config/tasks), but can also be inferred from a language's ecosystem
([we'll talk about this later](./migrate-to-moon)).

:::tip

Change the language dropdown at the top right to switch the examples!

:::

## Configuring a task

Most — if not all projects — utilize the same core tasks: linting, testing, code formatting,
typechecking, and _building_. Because these are so universal, let's implement the build task within
a project using [`moon.yml`](./config/project).

Begin by creating the `moon.yml` file at the root of a project and add `build` to the
[`tasks`](./config/project#tasks) field, with a [`command`](./config/project#command) parameter.

import BaseBun from './__partials__/create-task/bun/base.mdx';
import BaseDeno from './__partials__/create-task/deno/base.mdx';
import BaseGo from './__partials__/create-task/go/base.mdx';
import BaseNode from './__partials__/create-task/node/base.mdx';
import BasePHP from './__partials__/create-task/php/base.mdx';
import BasePython from './__partials__/create-task/python/base.mdx';
import BaseRuby from './__partials__/create-task/ruby/base.mdx';
import BaseRust from './__partials__/create-task/rust/base.mdx';

  
  
  
  
  
  
  
  

By itself, this isn't doing much, so let's add some arguments. Arguments can also be defined with
the [`args`](./config/project#args) setting.

import ArgsBun from './__partials__/create-task/bun/args.mdx';
import ArgsDeno from './__partials__/create-task/deno/args.mdx';
import ArgsGo from './__partials__/create-task/go/args.mdx';
import ArgsNode from './__partials__/create-task/node/args.mdx';
import ArgsPHP from './__partials__/create-task/php/args.mdx';
import ArgsPython from './__partials__/create-task/python/args.mdx';
import ArgsRuby from './__partials__/create-task/ruby/args.mdx';
import ArgsRust from './__partials__/create-task/rust/args.mdx';

  
  
  
  
  
  
  
  

With this, the task can be ran from the command line with
[`moon run :build`](./commands/run)! This is tasks in its most simplest form, but continue
reading on how to take full advantage of our task runner.

### Inputs

Our task above works, but isn't very efficient as it _always_ runs, regardless of what has changed
since the last time it has ran. This becomes problematic in continuous integration environments, not
just locally.

To mitigate this problem, moon provides a system known as inputs, which are file paths, globs, and
environment variables that are used by the task when it's ran. moon will use and compare these
inputs to calculate whether to run, or to return the previous run state from the cache.

If you're a bit confused, let's demonstrate this by expanding the task with the
[`inputs`](./config/project#inputs) setting.

import InputsBun from './__partials__/create-task/bun/inputs.mdx';
import InputsDeno from './__partials__/create-task/deno/inputs.mdx';
import InputsGo from './__partials__/create-task/go/inputs.mdx';
import InputsNode from './__partials__/create-task/node/inputs.mdx';
import InputsPHP from './__partials__/create-task/php/inputs.mdx';
import InputsPython from './__partials__/create-task/python/inputs.mdx';
import InputsRuby from './__partials__/create-task/ruby/inputs.mdx';
import InputsRust from './__partials__/create-task/rust/inputs.mdx';

  
  
  
  
  
  
  
  

This list of inputs may look complicated, but they are merely run checks. For example, when moon
detects a change in...

- Any files within the `src` folder, relative from the project's root.
- A config file in the project's root.
- A shared config file in the workspace root (denoted by the leading `/`).

...the task will be ran! If the change occurs _outside_ of the project or _outside_ the list of
inputs, the task will _not_ be ran.

:::tip

Inputs are a powerful feature that can be fine-tuned to your project's need. Be as granular or open
as you want, the choice is yours!

:::

### Outputs

Outputs are the opposite of [inputs](#inputs), as they are files and folders that are created as a
result of running the task. With that being said, outputs are _optional_, as not all tasks require
them, and the ones that do are typically build related.

Now why is declaring outputs important? For incremental builds and smart caching! When moon
encounters a build that has already been built, it hydrates all necessary outputs from the cache,
then immediately exits. No more waiting for long builds!

Continuing our example, let's route the built files and expand our task with the
[`outputs`](./config/project#outputs) setting.

import OutputsBun from './__partials__/create-task/bun/outputs.mdx';
import OutputsDeno from './__partials__/create-task/deno/outputs.mdx';
import OutputsGo from './__partials__/create-task/go/outputs.mdx';
import OutputsNode from './__partials__/create-task/node/outputs.mdx';
import OutputsPHP from './__partials__/create-task/php/outputs.mdx';
import OutputsPython from './__partials__/create-task/python/outputs.mdx';
import OutputsRuby from './__partials__/create-task/ruby/outputs.mdx';
import OutputsRust from './__partials__/create-task/rust/outputs.mdx';

  
  
  
  
  
  
  
  

## Depending on other tasks

For scenarios where you need run a task _before_ another task, as you're expecting some repository
state or artifact to exist, can be achieved with the [`deps`](./config/project#deps) setting, which
requires a list of [targets](./concepts/target):

- `:` - Full canonical target.
- `~:` or `` - A task within the current project.
- `^:` - A task from all [depended on projects](./concepts/project#dependencies).

```yaml title="/moon.yml" {1,7,8}
dependsOn:
  # ...

tasks:
  build:
    # ...
    deps:
      - '^:build'
```

## Using file groups

Once you're familiar with configuring tasks, you may notice certain inputs being repeated
constantly, like source files, test files, and configuration. To reduce the amount of boilerplate
required, moon provides a feature known as [file groups](./concepts/file-group), which enables
grouping of similar file types within a project using
[file glob patterns or literal file paths](./concepts/file-pattern).

File groups are defined with the [`fileGroups`](./config/project#filegroups) setting, which maps a
list of file paths/globs to a group, like so.

```yaml title="/moon.yml"
fileGroups:
  configs:
    - '*.config.js'
  sources:
    - 'src/**/*'
    - 'types/**/*'
  tests:
    - 'tests/**/*'
```

We can then replace the inputs in our task above with these new file groups using a syntax known as
[tokens](./concepts/token), specifically the [`@globs`](./concepts/token#globs) and
[`@files`](./concepts/token#files) token functions. Tokens are an advanced feature, so please refer
to their documentation for more information!

import FilegroupsBun from './__partials__/create-task/bun/filegroups.mdx';
import FilegroupsDeno from './__partials__/create-task/deno/filegroups.mdx';
import FilegroupsGo from './__partials__/create-task/go/filegroups.mdx';
import FilegroupsNode from './__partials__/create-task/node/filegroups.mdx';
import FilegroupsPHP from './__partials__/create-task/php/filegroups.mdx';
import FilegroupsPython from './__partials__/create-task/python/filegroups.mdx';
import FilegroupsRuby from './__partials__/create-task/ruby/filegroups.mdx';
import FilegroupsRust from './__partials__/create-task/rust/filegroups.mdx';

  
  
  
  
  
  
  
  

With file groups (and tokens), you're able to reduce the amount of configuration required _and_
encourage certain file structures for consuming projects!

## Next steps

          Configure .moon/tasks.yml further
        
      ),
      url: './config/tasks',
    },
    {
      icon: 'project-config',
      label: (
        
          Configure moon.yml further
        
      ),
      url: './config/project',
    },
    { icon: 'task', label: 'Learn about tasks', url: './concepts/task' },
    { icon: 'token', label: 'Learn about tokens', url: './concepts/token' },
  ]}
/>

---

## VS Code extension

import Image from '@site/src/components/Image';
import TwoColumn from '@site/src/components/TwoColumn';

Enhance your VS Code experience with our integrated moon console! Whether you're a fan of the
command line, or prefer interactive interfaces, our console will be a welcome experience.

> This extension is in its early stages. Expect more advanced features in the future, like
> autocompletion, config validation, and more!

## Views

  
    
  
  

All views are available within the moon sidebar. Simply click the moon icon in the left activity
bar!

  

}>

### Projects

The backbone of moon is the projects view. In this view, all moon configured projects will be
listed, categorized by their [`layer`](../config/project#layer), [`stack`](../config/project#stack),
and designated with their [`language`](../config/project#language).

Each project can then be expanded to view all available tasks. Tasks can be ran by clicking the `▶`
icon, or using the command palette.

> This view is available in both the "Explorer" and "moon" sidebars.

}>

### Tags

Similar to the projects view, the tags view displays projects grouped by their
[`tags`](../config/project#tags).

> This view is only available in the "moon" sidebar.

}
>

### Last run

Information about the last ran task will be displayed in a beautiful table with detailed stats.

This table displays all actions that were ran alongside the primary target(s). They are ordered
topologically via the action graph.

## Features

### YAML validation

To enable accurate validation of our YAML configuration files, you'll need to update the
`yaml.schemas` setting in `.vscode/settings.json` to point to the local schemas at
`.moon/cache/schemas`.

This can be automated by running the "moon: Append YAML schemas configuration to settings" in the
command palette, after the extension has been installed.

## Troubleshooting

View the
[official VS Code marketplace](https://marketplace.visualstudio.com/items?itemName=moonrepo.moon-console)
for more information on the extension, its commands, available settings, and more!

If you encounter a bug, or have a feature request, please submit them to the
[moonrepo/dev](https://github.com/moonrepo/dev/tree/master/packages/vscode-extension) repository!

---

## FAQ

## General

### Where did the name "moon" come from?

The first incarnation of the name was a misspelling of monorepo (= moonrepo). This is where the
domain moonrepo.dev came from, and our official company, moonrepo, Inc.

However, moonrepo is quite a long name with many syllables, and as someone who prefers short 1
syllable words, moon was perfect. The word moon also has great symmetry, as you can see in our logo!

But that's not all... moon is also an acronym. It originally stood for **m**onorepo,
**o**rganization, **o**rchestration, and **n**otification tool. But since moon can also be used for
polyrepos, we replaced monorepo with **m**anagement (as shown on the homepage). This is a great
acronym, as it embraces what moon is trying to solve:

- **M**anage repos, projects, and tasks with ease.
- **O**rganize projects and the repo to scale.
- **O**rchestrate tasks as efficiently as possible.
- **N**otify developers and systems about important events.

### Will moon support other languages?

Yes! Although we're focusing right now on the web ecosystem (Node.js, Rust, Go, PHP, Python, etc),
we've designed moon to be language agnostic and easily pluggable in the future. View our
[supported languages for more information](/docs#supported-languages).

### Will moon support continuous deployment?

Yes! We plan to integrate CD with the current build and CI system, but we are focusing on the latter
2 for the time being. Why not start using moon today so that you can easily adopt CD when it's
ready?

### What should be considered the "source of truth"?

If you're a frontend developer, you'll assume that a `package.json` is the source of truth for a
project, as it defines scripts, dependencies, and repo-local relations. While true, this breaks down
with additional tooling, like TypeScript project references, as now you must maintain
`tsconfig.json` as well as `package.json`. The risk of these falling out of sync is high.

This problem is further exacerbated by more tooling, or additional programming languages. What if
your frontend project is dependent on a backend project? This isn't easily modeled in
`package.json`. What if the backend project needs to be built and ran before running the frontend
project? Again, while not impossible, it's quite cumbersome to model in `package.json` scripts. So
on and so forth.

moon aims to solve this with a different approach, by standardizing all projects in the workspace on
[`moon.yml`](./config/project). With this, the `moon.yml` is the source of truth for each project,
and provides us with the following:

- The configuration is language agnostic. All projects are configured in a similar manner.
- Tasks can reference other tasks easily. For example, npm scripts referencing rake tasks, and vice
  verse, is a non-ideal experience.
- Dependencies defined with [`dependsOn`](./config/project#dependson) use moon project names, and
  not language specific semantics. This field also easily populates the dependency/project graphs.
- For JavaScript projects:
  - `package.json` dependencies (via `dependsOn`) are kept in sync when
    [`node.syncProjectWorkspaceDependencies`](./config/toolchain#syncprojectworkspacedependencies)
    is enabled.
  - `tsconfig.json` project references (via `dependsOn`) are kept in sync when
    [`typescript.syncProjectReferences`](./config/toolchain#syncprojectreferences) is enabled.

By using moon as the source of truth, we can ensure a healthy repository, by accurately keeping
everything in sync, and modifying project/language configuration to operate effectively.

:::info

With all that being said, moon supports
[implicit dependency scanning](./concepts/project#dependencies), if you'd prefer to continue
utilizing language specific functionality, instead of migrating entirely to moon.

:::

### How to stop moon formatting JSON and YAML files?

To ensure a healthy repository state, moon constantly modifies JSON and YAML files, specifically
`package.json` and `tsconfig.json`. This may result in a different formatting style in regards to
indentation. While there is no way to stop or turn off this functionality, we respect
[EditorConfig](https://editorconfig.org/) during this process.

Create a root `.editorconfig` file to enforce a consistent syntax.

```ini title=".editorconfig"
[*.{json,yaml,yml}]
indent_style = space
indent_size = 4
```

## Projects & tasks

### How to pipe or redirect tasks?

Piping (`|`) or redirecting (`>`) the output of one moon task to another moon task, whether via
stdin or through `inputs`, is not possible within our pipeline (task runner) directly.

However, we do support this functionality on the command line, or within a task itself, using the
[`script`](./config/project#script) setting.

```yaml title="moon.yml"
tasks:
  pipe:
    script: 'gen-json | jq ...'
```

Alternativaly, you can wrap this script in something like a Bash file, and execute that instead.

```bash title="scripts/pipe.sh"
#!/usr/bin/env bash
gen-json | jq ...
```

```yaml title="moon.yml"
tasks:
  pipe:
    command: 'bash ./scripts/pipe.sh'
```

### How to run multiple commands within a task?

Only [`script`](./config/project#script) based tasks can run multiple commands via `&&` or `;`
syntax. This is possible as we execute the entire script within a shell, and not directly with the
toolchain.

```yaml title="moon.yml"
tasks:
  multiple:
    script: 'mkdir test && cd test && do-something'
```

### How to run tasks in a shell?

By default, all tasks run in a shell, based on the task's [`shell`](./config/project#shell) option,
as demonstrated below:

```yaml title="moon.yml"
tasks:
  # Runs in a shell
  global:
    command: 'some-command-on-path'

  # Custom shells
  unix:
    command: 'bash -c some-command'
    options:
      shell: false
  windows:
    command: 'pwsh.exe -c some-command'
    options:
      shell: false
```

### Can we run other languages?

Yes! Although our toolchain only supports a few languages at this time, you can still run other
languages within tasks by setting their [`toolchain`](./config/project#toolchain) to "system".
System tasks are an escape hatch that will use any command available on the current machine.

```yaml title="moon.yml"
tasks:
  # Ruby
  lint:
    command: 'rubocop'
    toolchain: 'system'
  # PHP
  test:
    command: 'phpunit tests'
    toolchain: 'system'
```

However, because these languages are not supported directly within our toolchain, they will not
receive the benefits of the toolchain. Some of which are:

- Automatic installation of the language. System tasks expect the command to already exist in the
  environment, which requires the user to manually install them.
- Consistent language and dependency manager versions across all machines.
- Built-in cpu and heap profiling (language specific).
- Automatic dependency installs when the lockfile changes.
- And many more.

## JavaScript ecosystem

### Can we use `package.json` scripts?

We encourage everyone to define tasks in a [`moon.yml`](./config/project#tasks) file, as it allows
for additional metadata like `inputs`, `outputs`, `options`, and more. However, if you'd like to
keep using `package.json` scripts, enable the
[`node.inferTasksFromScripts`](./config/toolchain#infertasksfromscripts) setting.

View the [official documentation](./migrate-to-moon) for more information on this approach,
including risks, disadvantages, and caveats.

### Can moon version/publish packages?

At this time, no, as we're focusing on the build and test aspect of development. With that being
said, this is something we'd like to support first-class in the future, but until then, we suggest
the following popular tools:

- [Yarn releases](https://yarnpkg.com/features/release-workflow) (requires >= v2)
- [Changesets](https://github.com/changesets/changesets)
- [Lerna](https://github.com/lerna/lerna)

### Why is npm/pnpm/yarn install running twice when running a task?

moon will automatically install dependencies in a project or in the workspace root (when using
package workspaces) when the lockfile or `package.json` has been modified since the last time the
install ran. If you are running a task and multiple installs are occurring (and it's causing
issues), it can mean 1 of 2 things:

- If you are using package workspaces, then one of the projects triggering the install is not listed
  within the `workspaces` field in the root `package.json` (for npm and yarn), or in
  `pnpm-workspace.yml` (for pnpm).
- If the install is triggering in a non-JavaScript related project, then this project is incorrectly
  listed as a package workspace.
- If you don't want a package included in the workspace, but do want to install its dependencies,
  then it'll need its own lockfile.

## Troubleshooting

### How to resolve the "version 'GLIBC_X.XX' not found" error?

This is typically caused by running moon in an old environment, like Ubuntu 18, and the minimum
required libc doesn't exist or is too old. Since moon is Rust based, we're unable to support all
environments and versions perpetually, and will only support relatively modern environments.

There's not an easy fix to this problem, but there are a few potential solutions, from easiest to
hardest:

- Run moon in a Docker container/image that has the correct environment and libs. For example, the
  `node:latest` image.
- Upgrade the environment to a newer one. For example, Ubuntu 18 -> 22.
- Try and install a newer libc
  ([more information](https://stackoverflow.com/questions/72513993/how-install-glibc-2-29-or-higher-in-ubuntu-18-04)).

For more information on this problem as a whole,
[refer to this in-depth article](https://kobzol.github.io/rust/ci/2021/05/07/building-rust-binaries-in-ci-that-work-with-older-glibc.html).

---

## Continuous integration (CI)

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Image from '@site/src/components/Image';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

All companies and projects rely on continuous integration (CI) to ensure high quality code and to
avoid regressions. Because this is such a critical piece of every developer's workflow, we wanted to
support it as a first-class feature within moon, and we do just that with the
[`moon ci`](../commands/ci) command.

## How it works

The `ci` command does all the heavy lifting necessary for effectively running jobs. It achieves this
by automatically running the following steps:

- Determines touched files by comparing the current HEAD against a base.
- Determines all [targets](../concepts/target) that need to run based on touched files.
- Additionally runs affected [targets](../concepts/target) dependencies _and_ dependents.
- Generates an action and dependency graph.
- Installs the toolchain, Node.js, and npm dependencies.
- Runs all actions within the graph using a thread pool.
- Displays stats about all passing, failed, and invalid actions.

## Configuring tasks

By default, _all tasks_ run in CI, as you should always be building, linting, typechecking, testing,
so on and so forth. However, this isn't always true, so this can be disabled on a per-task basis
through the [`runInCI`](../config/project#runinci) or [`local`](../config/project#local) options.

```yaml
tasks:
  dev:
    command: 'webpack server'
    options:
      runInCI: false
    # Or
    local: true
```

:::caution

This option _must_ be set to false for tasks that spawn a long-running or never-ending process, like
HTTP or development servers. To help mitigate this, tasks named `dev`, `start`, or `serve` are false
by default. This can be easily controlled with the [`local`](../config/project#local) setting.

:::

## Integrating

The following examples can be referenced for setting up moon and its CI workflow in popular
providers. For GitHub, we're using our
[`setup-toolchain` action](https://github.com/moonrepo/setup-toolchain) to install moon. For other
providers, we assume moon is an npm dependency and must be installed with Node.js.

```yaml title=".github/workflows/ci.yml"
name: 'Pipeline'
on:
  push:
    branches:
      - 'master'
  pull_request:
jobs:
  ci:
    name: 'CI'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: 'actions/checkout@v4'
        with:
          fetch-depth: 0
      - uses: 'moonrepo/setup-toolchain@v0'
      - run: 'moon ci'
```

```yaml title=".buildkite/pipeline.yml"
steps:
  - label: 'CI'
    commands:
      - 'yarn install --immutable'
      - 'moon ci'
```

```yaml title=".circleci/config.yml"
version: 2.1
orbs:
  node: 'circleci/node@5.0.2'
jobs:
  ci:
    docker:
      - image: 'cimg/base:stable'
    steps:
      - checkout
      - node/install:
          install-yarn: true
          node-version: '16.13'
      - node/install-packages:
          check-cache: 'always'
          pkg-manager: 'yarn-berry'
      - run: 'moon ci'
workflows:
  pipeline:
    jobs:
      - 'ci'
```

```yaml title=".travis.yml"
language: node_js
node_js:
  - 16
cache: yarn
script: 'moon ci'
```

## Choosing targets

By default `moon ci` will run _all_ tasks from _all_ projects that are affected by touched files and
have the [`runInCI`](../config/project#runinci) task option enabled. This is a great catch-all
solution, but may not vibe with your workflow or requirements.

If you'd prefer more control, you can pass a list of targets to `moon ci`, instead of moon
attempting to detect them. When providing targets, `moon ci` will still only run them if affected by
touched files, but will still filter with the `runInCI` option.

```shell
# Run all builds
$ moon ci :build

# In another job, run tests
$ moon ci :test :lint
```

## Comparing revisions

By default the command will attempt to detect the base and head revisions automatically based on the
current CI provider (powered by the [`ci_env`](https://github.com/milesj/rust-cicd-env) Rust crate).
If nothing was detected, this will fallback to the configured
[`vcs.defaultBranch`](../config/workspace#defaultbranch) for the base revision, and `HEAD` for the
head revision.

These values can be customized with the `--base` and `--head` command line options, or the
`MOON_BASE` and `MOON_HEAD` environment variables, which takes highest precedence.

```shell
$ moon ci --base  --head 
# Or
$ MOON_BASE= MOON_HEAD= moon ci
```

## Parallelizing tasks

If your CI environment supports sharding across multiple jobs, then you can utilize moon's built in
parallelism by passing `--jobTotal` and `--job` options. The `--jobTotal` option is an integer of
the total number of jobs available, and `--job` is the current index (0 based) amongst the total.

When these options are passed, moon will only run affected [targets](../concepts/target) based on
the current job slice.

GitHub Actions do not support native parallelism, but it can be emulated using it's matrix.

```yaml title=".github/workflows/ci.yml"
# ...
jobs:
  ci:
    # ...
    strategy:
      matrix:
        index: [0, 1]
    steps:
      # ...
      - run: 'moon ci --job ${{ matrix.index }} --jobTotal 2'
```

- [Documentation](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs)

```yaml title=".buildkite/pipeline.yml"
# ...
steps:
  - label: 'CI'
    parallelism: 10
    commands:
      # ...
      - 'moon ci --job $$BUILDKITE_PARALLEL_JOB --jobTotal $$BUILDKITE_PARALLEL_JOB_COUNT'
```

- [Documentation](https://buildkite.com/docs/tutorials/parallel-builds#parallel-jobs)

```yaml title=".circleci/config.yml"
# ...
jobs:
  ci:
    # ...
    parallelism: 10
    steps:
      # ...
      - run: 'moon ci --job $CIRCLE_NODE_INDEX --jobTotal $CIRCLE_NODE_TOTAL'
```

- [Documentation](https://circleci.com/docs/2.0/parallelism-faster-jobs/)

TravisCI does not support native parallelism, but it can be emulated using it's matrix.

```yaml title=".travis.yml"
# ...
env:
  global:
    - TRAVIS_JOB_TOTAL=2
  jobs:
    - TRAVIS_JOB_INDEX=0
    - TRAVIS_JOB_INDEX=1
script: 'moon ci --job $TRAVIS_JOB_INDEX --jobTotal $TRAVIS_JOB_TOTAL'
```

- [Documentation](https://docs.travis-ci.com/user/speeding-up-the-build/)

> Your CI environment may provide environment variables for these 2 values.

## Caching artifacts

When a CI pipeline reaches a certain scale, its run times increase, tasks are unnecessarily ran, and
build artifacts are not shared. To combat this, we support [remote caching](./remote-cache), a
mechanism where we store build artifacts in the cloud, and sync these artifacts to machines on
demand.

### Manual persistence

If you'd prefer to _not use_ remote caching at this time, you can cache artifacts yourself, by
persisting the `.moon/cache/{hashes,outputs}` directories. All other files and folders in
`.moon/cache` _should not_ be persisted, as they are not safe/portable across machines.

However, because tasks can generate a different hash each run, you'll need to manually invalidate
your cache. Blindly storing the `hashes` and `outputs` directories without a mechanism to invalidate
will simply not work, as the contents will drastically change between CI runs. This is the primary
reason why the remote caching service exists.

## Reporting run results

If you're using GitHub Actions as your CI provider, we suggest using our
[`moonrepo/run-report-action`](https://github.com/marketplace/actions/moon-ci-run-reports). This
action will report the results of a [`moon ci`](../commands/ci) run to a pull request as a comment
and workflow summary.

```yaml title=".github/workflows/ci.yml"
# ...
jobs:
  ci:
    name: 'CI'
    runs-on: 'ubuntu-latest'
    steps:
      # ...
      - run: 'moon ci'
      - uses: 'moonrepo/run-report-action@v1'
        if: success() || failure()
        with:
          access-token: ${{ secrets.GITHUB_TOKEN }}
```

The report looks something like the following:

### Community offerings

The following GitHub actions are provided by the community:

- [`appthrust/moon-ci-retrospect`](https://github.com/appthrust/moon-ci-retrospect) - Displays the
  results of a `moon ci` run in a more readable fashion.

---

## Code generation

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Code generation provides an easy mechanism for automating common development workflows and file
structures. Whether it's scaffolding a new library or application, updating configuration, or
standardizing patterns.

To accomplish this, we provide a generator, which is divided into two parts. The first being the
templates and their files to be scaffolded. The second is our rendering engine that writes template
files to a destination.

## Creating a new template

To create a new template, run [`moon generate`][command] while passing the `--template` option. This
will create a template directory and [`template.yml`][config] file in the 1st file-based template
location defined in [`generator.templates`][gen-templates].

```shell
$ moon generate  --template
```

### Configuring `template.yml`

Every template requires a [`template.yml`][config] file in the template's directory root. This file
acts as a schema and declares metadata and variables required by the generator.

```yaml title="template.yml"
title: 'npm package'
description: |
  Scaffolds the initial structure for an npm package,
  including source and test folders, a package.json, and more.
variables:
  name:
    type: 'string'
    default: ''
    required: true
    prompt: 'Package name?'
```

### Managing files

Feel free to add any files and folders to the template that you'd like to be generated by consumers!
These files will then be scaffolded 1:1 in structure at the target destination.

An example of the templates folder structure may look something like the following:

```
templates/
├── npm-package/
│   ├── src/
│   ├── tests/
│   ├── package.json
│   └── template.yml
└── react-app/
```

#### Interpolation

Variables can be interpolated into file paths using the form `[varName]`. For example, if you had a
template file `src/[type].ts`, and a variable `type` with a value of "bin", then the destination
file path would be `src/bin.ts`.

This syntax also supports [filters](#filters), such as `[varName | camel_case]`. However, spaces may
cause issues with file path encoding, so this functionality is primarily recommended for the
[`destination`](../config/template#destination) setting.

#### File extensions

To enable syntax highlighting for template engine syntax, you may use the `.tera` (preferred) or
`.twig` file extensions. These extensions are optional, but will be removed when the files are
generated.

Depending on your preferred editor, these extensions may be supported through a plugin, or can be
configured based on file type.

- **VS Code**
  - [Tera extension](https://marketplace.visualstudio.com/items?itemName=karunamurti.tera)
  - [Twig extension](https://marketplace.visualstudio.com/items?itemName=mblode.twig-language-2)
- **Atom**
  - [Twig package](https://atom.io/packages/atom-twig)
- **Webstorm**
  - [Twig plugin](https://plugins.jetbrains.com/plugin/7303-twig)

#### Partials

Partials are special template files that are used for
[composition](https://keats.github.io/tera/docs/#include) and
[inheritance](https://keats.github.io/tera/docs/#inheritance). Because of this, these files _should
not_ be generated into the target destination, and _do not_ support frontmatter.

To ensure they are not generated, include the word "partial" anywhere in the file path. For example,
`partials/header.tpl` or `header.partial.tpl`.

#### Raws

Raw template files are another special type of file that bypass all Tera rendering, and are used
as-is instead. This is useful for files that contain syntax that conflicts with Tera.

To mark a file as raw, add a `.raw` extension, for example: `file.raw.js` or `file.js.raw`. When the
file is generated, the `.raw` extension will be removed.

#### Frontmatter

Frontmatter is a well-known concept for "per-file configuration", and is achieved by inserting YAML
at the top of the file, delimited by wrapping `---`. This is a very powerful feature that provides
more control than the alternatives, and allows for some very cool integrations.

moon's frontmatter supports functionality like file skipping, force overwriting, and destination
path rewriting.
[View the configuration docs for a full list of supported fields](../config/template#frontmatter).

```twig title="package.json"
---
force: true
---

{
  "name": "{{ name | kebab_case }}",
  "version": "0.0.1"
}
```

Since frontmatter exists in the file itself, you can take advantage of the rendering engine to
populate the field values dynamically. For example, if you're scaffolding a React component, you can
convert the component name and file name to PascalCase.

```twig
{% set component_name = name | pascal_case %}

---
to: components/{{ component_name }}.tsx
---

export function {{ component_name }}() {
  return ;
}
```

#### Assets

Assets are binary files that are copied as-is to the destination, without any rendering, and no
support for frontmatter. This applies to all non-text based files, like images, audio, video, etc.

### Template engine & syntax

Rendering templates is powered by [Tera](https://keats.github.io/tera/), a Rust based template
engine with syntax similar to Twig, Liquid, Django, and more. We highly encourage everyone to read
Tera's documentation for an in-depth understanding, but as a quick reference, Tera supports the
following:

- [Variable interpolation](https://keats.github.io/tera/docs/#variables) (defined with the
  [`variables`](../config/template#variables) setting), with
  [built-in filters](https://keats.github.io/tera/docs/#built-in-filters).

```twig
{{ varName }} -> foo
{{ varName | upper }} -> FOO
```

- [Conditional blocks](https://keats.github.io/tera/docs/#if) and
  [loops](https://keats.github.io/tera/docs/#for).

```twig
{% if price  1000 and not rich %}
  That's expensive!
{% else %}
  N/A
{% endif %}
```

```twig
{% for item in items %}
  {{ loop.index }} - {{ item.name }}
{% endfor %}
```

- And many more features, like auto-escaping, white space control, and math operators!

#### Filters

Filters are a mechanism for transforming values during interpolation and are written using pipes
(`|`). Tera provides many [built-in filters](https://keats.github.io/tera/docs/#built-in-filters),
but we also provide the following custom filters:

- Strings - `camel_case`, `pascal_case`, `snake_case`, `upper_snake_case`, `kebab_case`,
  `upper_kebab_case`, `lower_case`, `upper_case`

```twig
{{ some_value | upper_case }}
```

- Paths - `path_join`, `path_relative`

```twig
{{ some_path | path_join(part = "another/folder") }}
{{ some_path | path_relative(from = other_path) }}
{{ some_path | path_relative(to = other_path) }}
```

#### Functions

The following functions are available within a template:

- `variables()` - Returns an object containing all variables within the current template.
  

#### Variables

The following variables are always available within a template:

- `dest_dir` - Absolute path to the destination folder.
- `dest_rel_dir` - Relative path to the destination folder from the working directory.
- `working_dir` - Current working directory.
- `workspace_root` - The moon workspace root.

## Generating code from a template

Once a template has been created and configured, you can generate files based on it using the
[`moon generate`][command] command! This is also know as scaffolding or code generation.

This command requires the name of a template as the 1st argument. The template name is the folder
name on the file system that houses all the template files, or the [`id`](../config/template#id)
setting configured in [`template.yml`](../config/template).

```shell
$ moon generate npm-package
```

An optional destination path, relative from the current working directory, can be provided as the
2nd argument. If not provided, the [`destination`](../config/template#destination) setting
configured in [`template.yml`](../config/template) will be used, or you'll be prompted during
generation to provide one.

```shell
$ moon generate npm-package ./packages/example
```

> This command is extremely interactive, as we'll prompt you for the destination path, variable
> values, whether to overwrite files, and more. If you'd prefer to avoid interactions, pass
> `--defaults`, or `--force`, or both.

### Configuring template locations

Templates can be located anywhere, especially when [being shared](#sharing-templates). Because of
this, our generator will loop through all template paths configured in
[`generator.templates`][gen-templates], in order, until a match is found.

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - './templates'
    # Or
    - 'file://other/templates'
```

When using literal file paths, all paths are relative from the workspace root.

#### Archive URLs

Template locations can reference archives (zip, tar, etc) through https URLs. These archives should
contain templates and will be downloaded and unpacked. The list of
[available archive formats can be found here](https://github.com/moonrepo/starbase/blob/master/crates/archive/src/lib.rs#L76).

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - 'https://domain.com/some/path/to/archive.zip'
```

> Archives will be unpacked to `~/.moon/templates/archive/`, and will be cached for future
> use.

#### Globs

If you'd prefer more control over literal file paths (above), you can instead use glob paths or the
`glob://` protocol. Globs are relative from the workspace root, and will only match directories, or
patterns that end in `template.yml`.

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - './templates/*'
    # Or
    - 'glob://projects/*/templates/*'
```

#### Git repositories

Templates locations can also reference templates in an external Git repository using the `git://`
locator protocol. This locator requires the Git host, repository path, and revision (branch, tag,
commit, etc).

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - 'git://github.com/moonrepo/templates#master'
    - 'git://gitlab.com/org/repo#v1.2.3'
```

> Git repositories will be cloned to `~/.moon/templates/git/` using an HTTPS URL (not a Git
> URL), and will be cached for future use.

#### npm packages

Additionally, template locations can also reference npm packages using the `npm://` locator
protocol. This locator requires a package name and published version.

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - 'npm://@moonrepo/templates#1.2.3'
    - 'npm://other-templates#4.5.6'
```

> npm packages will be downloaded and unpacked to `~/.moon/templates/npm` and cached for future use.

### Declaring variables with CLI arguments

During generation, you'll be prompted in the terminal to provide a value for any configured
variables. However, you can pre-fill these variable values by passing arbitrary command line
arguments after `--` to [`moon generate`][command]. Argument names must exactly match the variable
names.

Using the package template example above, we could pre-fill the `name` variable like so:

```shell
$ moon generate npm-package ./packages/example -- --name '@company/example' --private
```

:::info

- Array variables support multiple options of the same name.
- Boolean variables can be negated by prefixing the argument with `--no-`.
- Object variables _can not_ declare values through arguments.

:::

## Sharing templates

Although moon is designed for a monorepo, you may be using multiple repositories and would like to
use the same templates across all of them. So how can we share templates across repositories? Why
not try...

- Git submodules
- Git repositories (using `git://` protocol)
- File archives
- Node.js modules
- npm packages (using `npm://` protocol)
- Another packaging system

Regardless of the choice, simply configure [`generator.templates`][gen-templates] to point to these
locations:

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - './templates'
    - 'file://./templates'
    # Git
    - './path/to/submodule'
    - 'git://github.com/org/repo#branch'
    # npm
    - './node_modules/@company/shared-templates'
    - 'npm://@company/shared-templates#1.2.3'
```

### Git and npm layout structure

If you plan to share templates using Git repositories (`git://`) or npm packages (`npm://`), then
the layout of those projects must follow these guidelines:

- A project must support multiple templates
- A template is denoted by a folder in the root of the project
- Each template must have a [`template.yml`][config] file
- Template names are derived from the folder name, or the `id` field in [`template.yml`][config]

An example of this layout structure may look something like the following:

```

├── template-one/
│   └── template.yml
├── template-two/
│   └── template.yml
├── template-three/
│   └── template.yml
└── package.json, etc
```

These templates can then be referenced by name, such as [`moon generate template-one`][command].

[config]: ../config/template
[command]: ../commands/generate
[gen-templates]: ../config/workspace#templates

---

## Code owners

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

Code owners enables companies to define individuals, teams, or groups that are responsible for code
in a repository. This is useful in ensuring that pull/merge requests are reviewed and approved by a
specific set of contributors, before the branch is merged into the base branch.

With that being said, moon _does not_ implement a custom code owners solution, and instead builds
upon the popular `CODEOWNERS` integration in VCS providers, like GitHub, GitLab, and Bitbucket.

## Defining owners

With moon, you _do not_ modify a `CODEOWNERS` file directly. Instead you define owners _per project_
with [`moon.yml`](../config/project), or globally with [`.moon/workspace.yml`](../config/workspace).
These owners are then aggregated and automatically
[synced to a `CODEOWNERS` file](#generating-codeowners).

:::info

An owner is a user, team, or group unique to your VCS provider. Please refer to your provider's
documentation for the correct format in which to define owners.

:::

### Project-level

For projects, we support an [`owners`](../config/project#owners) setting in
[`moon.yml`](../config/project) that accepts file patterns/paths and their owners (contributors
required to review), as well as operational settings for minimum required approvals, custom groups,
and more.

Paths configured here are relative from the project root, and will be prefixed with the project
source (path from workspace root to project root) when the file is synced.

```yaml title="packages/components/moon.yml"
owners:
  requiredApprovals: 2
  paths:
    'src/': ['@frontend', '@design-system']
    '*.config.js': ['@frontend-infra']
    '*.json': ['@frontend-infra']
```

The configuration above would generate the following:

```shell title=".github/CODEOWNERS"
# components
/packages/components/src/ @frontend @design-system
/packages/components/*.config.js @frontend-infra
/packages/components/*.json @frontend-infra
```

```shell title=".gitlab/CODEOWNERS"
# components
[components][2]
/packages/components/src/ @frontend @design-system
/packages/components/*.config.js @frontend-infra
/packages/components/*.json @frontend-infra
```

```shell title="CODEOWNERS"
# components
/packages/components/src/ @frontend @design-system
/packages/components/*.config.js @frontend-infra
/packages/components/*.json @frontend-infra
```

### Workspace-level

Project scoped owners are great but sometimes you need to define owners for files that span across
all projects, or files at any depth within the repository. With the
[`codeowners.globalPaths`](../config/workspace#globalpaths) setting in
[`.moon/workspace.yml`](../config/workspace), you can do just that.

Paths configured here are used as-is, allowing for full control of what ownership is applied.

```yaml title=".moon/workspace.yml"
codeowners:
  globalPaths:
    # All files
    '*': ['@admins']
    # Config folder at any depth
    'config/': ['@app-platform']
    # GitHub folder at the root
    '/.github/': ['@infra']
```

The configuration above would generate the following at the top of the file (is the same for all
providers):

```shell title=".github/CODEOWNERS"
# (workspace)
* @admins
config/ @app-platform
/.github/ @infra
```

```shell title=".gitlab/CODEOWNERS"
# (workspace)
* @admins
config/ @app-platform
/.github/ @infra
```

```shell title="CODEOWNERS"
# (workspace)
* @admins
config/ @app-platform
/.github/ @infra
```

## Generating `CODEOWNERS`

Code owners is an opt-in feature, and as such, the `CODEOWNERS` file can be generated in a few ways.
The first is manually, with the [`moon sync codeowners`](../commands/sync/codeowners) command.

```shell
$ moon sync codeowners
```

While this works, it is a manual process, and can easily be forgotten, resulting in an out-of-date
file.

An alternative solution is the [`codeowners.syncOnRun`](../config/workspace#synconrun) setting in
[`.moon/workspace.yml`](../config/workspace#codeowners), that when enabled, moon will automatically
generate a `CODEOWNERS` file when a [target](../concepts/target) is ran.

```yaml title=".moon/workspace.yml"
codeowners:
  syncOnRun: true
```

> The format and location of the `CODEOWNERS` file is based on the
> [`vcs.provider`](../config/workspace#provider) setting.

## FAQ

### What providers or formats are supported?

The following providers are supported, based on the [`vcs.provider`](../config/workspace#provider)
setting.

- [Bitbucket](https://marketplace.atlassian.com/apps/1218598/code-owners-for-bitbucket?tab=overview&hosting=cloud)
  (via a 3rd-party app)
- [GitHub](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)
- [GitLab](https://docs.gitlab.com/ee/user/project/codeowners/reference.html)
- Other (very basic syntax)

### Where does the `CODEOWNERS` file get created?

The location of the file is dependent on the configured provider.

- GitHub -> `.github/CODEOWNERS`
- GitLab -> `.gitlab/CODEOWNERS`
- Everything else -> `CODEOWNERS`

### Why are owners defined in `moon.yml` and not an alternative like `OWNERS`?

A very popular pattern for defining owners is through an `OWNERS` file, which can appear in any
folder, at any depth, within the repository. All of these files are then aggregated into a single
`CODEOWNERS` file.

While this is useful for viewing ownership of a folder at a glance, it incurs a massive performance
hit as we'd have to constantly glob the _entire_ repository to find all `OWNERS` files. We found it
best to define owners in `moon.yml` instead for the following reasons:

- No performance hit, as we're already loading and parsing these config files.
- Co-locates owners with the rest of moon's configuration.
- Ownership is now a part of the project graph, enabling future features.

---

## Debugging a task

Running [tasks](../concepts/task) is the most common way to interact with moon, so what do you do
when your task isn't working as expected? Diagnose it of course! Diagnosing the root cause of a
broken task can be quite daunting, but do not fret, as the following steps will help guide you in
this endeavor.

## Verify configuration

Before we dive into the internals of moon, we should first verify that the task is actually
configured correctly. Our configuration layer is very strict, but it can't catch everything, so jump
to the [`moon.yml`](../config/project#tasks) documentation for more information.

To start, moon will create a snapshot of the project and its tasks, with all [tokens][token]
resolved, and paths expanded. This snapshot is located at
`.moon/cache/states//snapshot.json`. With the snapshot open, inspect the root `tasks`
object for any inconsistencies or inaccuracies.

Some issues to look out for:

- Have `command` and `args` been parsed correctly?
- Have [tokens][token] resolved correctly? If not, verify syntax or try another token type.
- Have `inputFiles`, `inputGlobs`, and `inputVars` expanded correctly from [`inputs`][inputs]?
- Have `outputFiles` and `outputGlobs` expanded correctly from [`outputs`][outputs]?
- Is the `toolchain` (formerly `platform`) correct for the command? If incorrect, explicitly set the
  [`toolchain`][toolchain].
- Are `options` and `flags` correct?

:::info

Resolved information can also be inspected with the [`moon task  --json`](../commands/task)
command.

:::

### Verify inherited configuration

If the configuration from the previous step looks correct, you can skip this step, otherwise let's
verify that the inherited configuration is also correct. In the `snapshot.json` file, inspect the
root `inherited` object, which is structured as follows:

- `order` - The order in which configuration files from `.moon` are loaded, from lowest to highest
  priority, and the order files are merged. The `*` entry is `.moon/tasks.yml`, while other entries
  map to `.moon/tasks/**/*.yml`.
- `layers` - A mapping of configuration files that were loaded, derived from the `order`. Each layer
  represents a partial object (not expanded or resolved). Only files that exist will be mapped here.
- `config` - A partial configuration object representing the state of all merged layers. This is
  what is merged with the project's `moon.yml` file.

Some issues to look out for:

- Is the order correct? If not, verify the project's [`language`](../config/project#language) and
  the task's [`toolchain`][toolchain].
- Does `config` correctly represent the merged state of all `layers`? Do note that tasks are shallow
  merged (by name), _not_ deep merged.
- Have the root `tasks` properly inherited [`implicitDeps`][implicitDeps],
  [`implicitInputs`][implicitInputs], and `fileGroups`?

## Inspect trace logs

If configuration looks good, let's move on to inspecting the trace logs, which can be a non-trivial
amount of effort. Run the task to generate the logs, bypass the cache, and include debug
information:

```shell
MOON_DEBUG_PROCESS_ENV=true MOON_DEBUG_PROCESS_INPUT=true moon run  --log trace --updateCache
```

Once ran, a large amount of information will be logged to the terminal. However, most of it can be
ignored, as we're only interested in the "is this task affected by changes" logs. This breaks down
as follows:

1. First, we gather touched files from the local checkout, which is typically
   `git status --porcelain --untracked-files` (from the `moon_process::command_inspector` module).
   The logs do not output the list of files that are touched, but you can run this command locally
   to verify the output.
2. Secondly, we gather all files from the project directory, using the
   `git ls-files --full-name --cached --modified --others --exclude-standard  --deduplicate`
   command (also from the `moon_process::command_inspector` module). This command can also be ran
   locally to verify the output.
3. Lastly, all files from the previous 2 commands will be hashed using the `git hash-object`
   command. If you passed the `MOON_DEBUG_PROCESS_INPUT` environment variable, you'll see a massive
   log entry of all files being hashed. This is what we use to generate moon's specific hash.

If all went well, you should see a log entry that looks like this:

```
Generated hash  for target 
```

The important piece is the hash, which is a 64-character SHA256 hash, and represents the unique hash
of this task/target. This is what moon uses to determine a cache hit/miss, and whether or not to
skip re-running a task.

Let's copy the hash and move on to the next step.

## Inspect the hash manifest

With the hash in hand, let's dig deeper into moon's internals, by inspecting the hash manifest at
`.moon/cache/hashes/.json`, or running the [`moon query hash`](../commands/query/hash)
command:

```shell
moon query hash 
```

The manifest is JSON and its contents are all the information used to generate its unique hash. This
information is an array, and breaks down as follows:

- The first item in the array is the task itself. The important fields to diagnose here are `deps`
  and `inputs`.
  - Dependencies are other tasks (and their hash) that this task depends on.
  - Inputs are all the files (and their hash from `git hash-object`) this task requires to run.
- The remaining items are toolchain/language specific, some examples are:
  - **Node.js** - The current Node.js version and the resolved versions/hashes of all `package.json`
    dependencies.
  - **Rust** - The current Rust version and the resolved versions/hashes of all `Cargo.toml`
    dependencies.
  - **TypeScript** - Compiler options for changing compilation output.

Some issues to look out for:

- Do the dependencies match the task's configured [`deps`][deps] and [`implicitDeps`][implicitDeps]?
- Do the inputs match the task's configured [`inputs`][inputs] and
  [`implicitInputs`][implicitInputs]? If not, try tweaking the config.
- Are the toolchain/language specific items correct?
- Are dependency versions/hashes correctly parsed from the appropriate lockfile?

### Diffing a previous hash

Another avenue for diagnosing a task is to diff the hash against a hash from a previous run. Since
we require multiple hashes, we'll need to run the task multiple times,
[inspect the logs](#inspect-trace-logs), and extract the hash for each. If you receive the same hash
for each run, you'll need to tweak configuration or change files to produce a different hash.

Once you have 2 unique hashes, we can pass them to the
[`moon query hash-diff`](../commands/query/hash-diff) command. This will produce a `git diff` styled
output, allowing for simple line-by-line comparison debugging.

```shell
moon query hash-diff  
```

```diff
Left:  0b55b234f1018581c45b00241d7340dc648c63e639fbafdaf85a4cd7e718fdde
Right: 2388552fee5a02062d0ef402bdc7232f0a447458b058c80ce9c3d0d4d7cfe171

[
	{
		"command": "build",
		"args": [
+			"./dist"
-			"./build"
		],
		...
	}
]
```

This is extremely useful in diagnoising why a task is running differently than before, and is much
easier than inspecting the hash manifest files manually!

## Ask for help

If you've made it this far, and still can't figure out why a task is not working correctly, please
ask for help!

- [Join the Discord community](https://discord.gg/qCh9MEynv2) (if lost)
- [Report an issue](https://github.com/moonrepo/moon/issues/new/choose) (if an actual bug)

[token]: ../concepts/token
[deps]: ../config/project#deps
[inputs]: ../config/project#inputs
[outputs]: ../config/project#outputs
[toolchain]: ../config/project#toolchain
[implicitDeps]: ../config/tasks#implicitdeps
[implicitInputs]: ../config/tasks#implicitinputs

---

## Docker integration

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Using [Docker](https://www.docker.com/) to run your applications? Or build your artifacts? No
worries, moon can be utilized with Docker, and supports a robust integration layer.

:::success

Looking to speed up your Docker builds? Want to build in the cloud?
[Give Depot a try](https://depot.dev?ref=moonrepo)!

:::

## Requirements

The first requirement, which is very important, is adding `.moon/cache` to the workspace root
`.dockerignore` (moon assumes builds are running from the root). Not all files in `.moon/cache` are
portable across machines/environments, so copying these file into Docker will definitely cause
interoperability issues.

```text title=".dockerignore"
.moon/cache
```

The other requirement depends on how you want to integrate Git with Docker. Since moon executes
`git` commands under the hood, there are some special considerations to be aware of when running
moon within Docker. There's 2 scenarios to choose from:

1. (recommended) Add the `.git` folder to `.dockerignore`, so that it's not `COPY`'d. moon will
   continue to work just fine, albeit with some functionality disabled, like caching.
2. Ensure that the `git` library is installed in the container, and copy the `.git` folder with
   `COPY`. moon will work with full functionality, but it will increase the overall size of the
   image because of caching.

## Creating a `Dockerfile`

:::info

Our [`moon docker file`][file] command can automatically generate a `Dockerfile` based on this
guide! We suggest generating the file then reading the guide below to understand what's going on.

:::

We're very familiar with how tedious `Dockerfile`s are to write and maintain, so in an effort to
reduce this headache, we've built a handful of tools to make this process much easier. With moon,
we'll take advantage of Docker's layer caching and staged builds as much as possible.

With that being said, there's many approaches you can utilize, depending on your workflow (we'll
document them below):

- Running `moon docker` commands _before_ running `docker run|build` commands.
- Running `moon docker` commands _within_ the `Dockerfile`.
- Using multi-staged or non-staged (standard) builds.
- Something else unique to your setup!

### What we're trying to avoid

Before we dive into writing a perfect `Dockerfile`, we'll briefly talk about the pain points we're
trying to avoid. In the context of Node.js and monorepo's, you may be familiar with having to `COPY`
each individual `package.json` in the monorepo before installing `node_modules`, to effectively use
layer caching. This is very brittle, as each new application or package is created, every
`Dockerfile` in the monorepo will need to be modified to account for this new `package.json`.

Furthermore, we'll have to follow a similar process for _only copying source files_ necessary for
the build or `CMD` to complete. This is _very tedious_, so most developers simply use `COPY . .` and
forget about it. Copying the entire monorepo is costly, especially as it grows.

As an example, we'll use moon's official repository. The `Dockerfile` would look something like the
following.

```docker
FROM node:latest

WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

# Copy moon files
COPY ./.moon ./.moon

# Copy all package.json's and lockfiles
COPY ./packages/cli/package.json ./packages/cli/package.json
COPY ./packages/core-linux-arm64-gnu/package.json ./packages/core-linux-arm64-gnu/package.json
COPY ./packages/core-linux-arm64-musl/package.json ./packages/core-linux-arm64-musl/package.json
COPY ./packages/core-linux-x64-gnu/package.json ./packages/core-linux-x64-gnu/package.json
COPY ./packages/core-linux-x64-musl/package.json ./packages/core-linux-x64-musl/package.json
COPY ./packages/core-macos-arm64/package.json ./packages/core-macos-arm64/package.json
COPY ./packages/core-macos-x64/package.json ./packages/core-macos-x64/package.json
COPY ./packages/core-windows-x64-msvc/package.json ./packages/core-windows-x64-msvc/package.json
COPY ./packages/runtime/package.json ./packages/runtime/package.json
COPY ./packages/types/package.json ./packages/types/package.json
COPY ./package.json ./package.json
COPY ./yarn.lock ./yarn.lock
COPY ./.yarn ./.yarn
COPY ./.yarnrc.yml ./yarnrc.yml

# Install toolchain and dependencies
# In non-moon repos: yarn install
RUN moon docker setup

# Copy project and required files
# Or COPY . .
COPY ./packages/types ./packages/types
COPY ./packages/runtime ./packages/runtime

# Build the target
RUN moon run runtime:build
```

For such a small monorepo, this already looks too confusing!!! Let's remedy this by utilizing moon
itself to the fullest!

### Scaffolding the bare minimum

The first step in this process is to only copy the bare minimum of files necessary for installing
dependencies (Node.js modules, etc). This is typically manifests (`package.json`), lockfiles
(`yarn.lock`, etc), and any configuration (`.yarnrc.yml`, etc).

This can all be achieved with the [`moon docker scaffold`][scaffold] command, which scaffolds a
skeleton of the repository structure, with only necessary files (the above). Let's update our
`Dockerfile` usage.

This assumes [`moon docker scaffold `][scaffold] is ran outside of the `Dockerfile`.

```docker
FROM node:latest
WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

# Copy workspace skeleton
COPY ./.moon/docker/workspace .

# Install toolchain and dependencies
RUN moon docker setup
```

```docker
#### BASE
FROM node:latest AS base
WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

#### SKELETON
FROM base AS skeleton

# Copy entire repository and scaffold
COPY . .
RUN moon docker scaffold 

#### BUILD
FROM base AS build

# Copy toolchain
COPY --from=skeleton /root/.proto /root/.proto

# Copy workspace skeleton
COPY --from=skeleton /app/.moon/docker/workspace .

# Install toolchain and dependencies
RUN moon docker setup
```

And with this, our dependencies will be layer cached effectively! Let's now move onto copying source
files.

### Copying necessary source files

The next step is to copy all source files necessary for `CMD` or any `RUN` commands to execute
correctly. This typically requires copying all source files for the project _and_ all source files
of the project's dependencies... NOT the entire repository!

Luckily our [`moon docker scaffold `][scaffold] command has already done this for us! Let's
continue updating our `Dockerfile` to account for this, by appending the following:

```docker
# Copy source files
COPY ./.moon/docker/sources .

# Build something (optional)
RUN moon run :
```

```docker
# Copy source files
COPY --from=skeleton /app/.moon/docker/sources .

# Build something (optional)
RUN moon run :
```

:::info

If you need to copy additional files for your commands to run successfully, you can configure the
`docker.scaffold.include` setting in [`.moon/workspace.yaml`](../config/workspace#scaffold) (entire
workspace) or [`moon.yml`](../config/project#scaffold) (per project).

:::

### Pruning extraneous files

Now that we've ran a command or built an artifact, we should prune the Docker environment to remove
unneeded files and folders. We can do this with the [`moon docker prune`][prune] command, which
_must be ran_ within the context of a `Dockerfile`!

```docker
# Prune workspace
RUN moon docker prune
```

When ran, this command will do the following, in order:

- Remove extraneous dependencies (`node_modules`) for unfocused projects.
- Install production only dependencies for the projects that were scaffolded.

:::info

This process can be customized using the `docker.prune` setting in
[`.moon/workspace.yaml`](../config/workspace#prune).

:::

### Final result

And with this moon integration, we've reduced the original `Dockerfile` of 35 lines to 18 lines, a
reduction of almost 50%. The original file can also be seen as `O(n)`, as each new manifest requires
cascading updates, while the moon approach is `O(1)`!

```docker
FROM node:latest
WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

# Copy workspace skeleton
COPY ./.moon/docker/workspace .

# Install toolchain and dependencies
RUN moon docker setup

# Copy source files
COPY ./.moon/docker/sources .

# Build something (optional)
RUN moon run :

# Prune workspace
RUN moon docker prune

# CMD
```

```docker
#### BASE
FROM node:latest AS base
WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

#### SKELETON
FROM base AS skeleton

# Copy entire repository and scaffold
COPY . .
RUN moon docker scaffold 

#### BUILD
FROM base AS build

# Copy workspace skeleton
COPY --from=skeleton /app/.moon/docker/workspace .

# Install toolchain and dependencies
RUN moon docker setup

# Copy source files
COPY --from=skeleton /app/.moon/docker/sources .

# Build something (optional)
RUN moon run :

# Prune workspace
RUN moon docker prune

# CMD
```

## Running `docker` commands

When running `docker` commands, they _must_ be ran from moon's workspace root (typically the
repository root) so that the project graph and all `moon docker` commands resolve correctly.

```shell
docker build .
```

If you're `Dockerfile`s are located within each applicable project, use the `-f` argument.

```shell
docker run -f ./apps/client/Dockerfile .
```

## Troubleshooting

### Supporting `node:alpine` images

If you're trying to use the `node:alpine` image with moon's
[integrated toolchain](../concepts/toolchain), you'll need to set the `MOON_TOOLCHAIN_FORCE_GLOBALS`
environment variable in the Docker image to disable moon's toolchain. This is required as Node.js
does not provide pre-built binaries for the Alpine target, so installing the Node.js toolchain will
fail.

```docker
FROM node:alpine

ENV MOON_TOOLCHAIN_FORCE_GLOBALS=true
```

[file]: ../commands/docker/file
[prune]: ../commands/docker/prune
[scaffold]: ../commands/docker/scaffold

---

## Angular example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Angular](https://angular.io/) into moon.

Begin by creating a new Angular project in the root of an existing moon project (this should not be
created in the workspace root, unless a polyrepo).

```shell
cd apps && npx -p @angular/cli@latest ng new angular-app
```

> View the [official Angular docs](https://angular.io/start) for a more in-depth guide to getting
> started!

## Setup

Since Angular is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

```yaml title="/moon.yml"
fileGroups:
  app:
    - 'src/**/*'
    - 'angular.*'

tasks:
  dev:
    command: 'ng serve'
    local: true

  build:
    command: 'ng build'
    inputs:
      - '@group(app)'
      - '@group(sources)'
    outputs:
      - 'dist'

  # Extends the top-level lint
  lint:
    args:
      - '--ext'
      - '.ts'
```

### ESLint integration

Angular does not provide a built-in linting abstraction, but instead there is an
[ESLint package](https://github.com/angular-eslint/angular-eslint), which is great, but complicates
things a bit. Because of this, you have two options for moving forward:

- Use a [global `lint` task](./eslint) and bypass Angular's solution (preferred).
- Use Angular's ESLint package solution only.

Regardless of which option is chosen, the following changes are applicable to all options and should
be made. Begin be installing the dependencies that the
[`@angular-eslint`](https://nextjs.org/docs/basic-features/eslint#eslint-config) package need in the
application's `package.json`.

"
  dev
/>

Since Angular has some specific rules, we'll need to tell the ESLint package to overrides the
default ones. This can be achieved with a project-level `.eslintrc.json` file.

```json title="/.eslintrc.json"
{
  "root": true,
  "ignorePatterns": ["projects/**/*"],
  "overrides": [
    {
      "files": ["*.ts"],
      "extends": [
        "eslint:recommended",
        "plugin:@typescript-eslint/recommended",
        "plugin:@angular-eslint/recommended",
        // This is required if you use inline templates in Components
        "plugin:@angular-eslint/template/process-inline-templates"
      ],
      "rules": {
        /**
         * Any TypeScript source code (NOT TEMPLATE) related rules you wish to use/reconfigure over and above the
         * recommended set provided by the @angular-eslint project would go here.
         */
        "@angular-eslint/directive-selector": [
          "error",
          { "type": "attribute", "prefix": "app", "style": "camelCase" }
        ],
        "@angular-eslint/component-selector": [
          "error",
          { "type": "element", "prefix": "app", "style": "kebab-case" }
        ]
      }
    },
    {
      "files": ["*.html"],
      "extends": [
        "plugin:@angular-eslint/template/recommended",
        "plugin:@angular-eslint/template/accessibility"
      ],
      "rules": {
        /**
         * Any template/HTML related rules you wish to use/reconfigure over and above the
         * recommended set provided by the @angular-eslint project would go here.
         */
      }
    }
  ]
}
```

With the basics now setup, choose the option that works best for you.

We encourage using the global `lint` task for consistency across all projects within the repository.
With this approach, the `eslint` command itself will be ran and the `ng lint` command will be
ignored, but the `@angular-eslint` rules will still be used.

If you'd prefer to use the `ng lint` command, add it as a task to the project's
[`moon.yml`](../../config/project).

```yaml title="/moon.yml"
tasks:
  lint:
    command: 'ng lint'
    inputs:
      - '@group(angular)'
```

Furthermore, if a global `lint` task exists, be sure to exclude it from being inherited.

```yaml title="/moon.yml"
workspace:
  inheritedTasks:
    exclude: ['lint']
```

In addition to configuring `moon.yml`, you also need to add a lint target in the `angular.json` file
for linting to work properly. The lint target specifies which builder to use for linting, as well as
the file patterns that should be linted.

```json title="/angular.json"
{
  "projects": {
    "angular-app": {
      "architect": {
        "lint": {
          "builder": "@angular-eslint/builder:lint",
          "options": {
            "lintFilePatterns": ["src/**/*.ts", "src/**/*.html"]
          }
        }
      }
    }
  }
}
```

Adding this lint target is crucial for ensuring that the linting process is properly configured and
integrated with Angular's build system.

### TypeScript integration

Angular has [built-in support for TypeScript](https://angular.io/guide/typescript-configuration), so
there is no need for additional configuration to enable TypeScript support.

At this point we'll assume that a `tsconfig.json` has been created in the application, and
typechecking works. From here we suggest utilizing a [global `typecheck` task](./typescript) for
consistency across all projects within the repository.

## Configuration

### Root-level

We suggest _against_ root-level configuration, as Angular should be installed per-project, and the
`ng` command expects the configuration to live relative to the project root.

### Project-level

When creating a new Angular project, a [`angular.json`](https://angular.io/guide/workspace-config)
is created, and _must_ exist in the project root. This allows each project to configure Angular for
their needs.

```json title="/angular.json"
{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "projects": {
    "angular-app": {
      "projectType": "application",
      ...
    }
  },
  ...
}
```

---

## Astro example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Astro](https://docs.astro.build).

Begin by creating a new Astro project in the root of an existing moon project (this should not be
created in the workspace root, unless a polyrepo).

```shell
cd apps && npm create astro@latest
```

## Setup

Since Astro is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

:::tip

We suggest inheriting Astro tasks from the
[official moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/astro).

:::

```yaml title="/moon.yml"
# Inherit tasks from the `astro` preset
# https://github.com/moonrepo/moon-configs
tags: ['astro']

# Disable project references
toolchain:
  typescript:
    syncProjectReferences: false
```

### ESLint integration

When using a [`lint`](./eslint) task, the
[`eslint-plugin-astro`](https://ota-meshi.github.io/eslint-plugin-astro/user-guide/) package must be
installed to lint `.astro` files.

" />

Once the dependency has been installed in the application's `package.json`. We can then enable this
configuration by creating an `.eslintrc.js` file in the project root. Be sure this file is listed in
your lint task's inputs!

```js title="/.eslintrc.js"
module.exports = {
  extends: ['plugin:astro/recommended'],
  overrides: [
    {
      files: ['*.astro'],
      parser: 'astro-eslint-parser',
      // If using TypeScript
      parserOptions: {
        parser: '@typescript-eslint/parser',
        extraFileExtensions: ['.astro'],
        project: 'tsconfig.json',
        tsconfigRootDir: __dirname,
      },
    },
  ],
};
```

And lastly, when linting through moon's command line, you'll need to include the `.astro` extension
within the `lint` task. This can be done by extending the top-level task within the project (below),
or by adding it to the top-level entirely.

```yaml title="/moon.yml"
tasks:
  lint:
    args:
      - '--ext'
      - '.ts,.tsx,.astro'
```

### Prettier integration

When using a [`format`](./prettier) task, the `prettier-plugin-astro` package must be installed to
format `.astro` files. View the official
[Astro docs](https://docs.astro.build/en/editor-setup/#prettier) for more information.

" />

### TypeScript integration

Since Astro utilizes custom `.astro` files, it requires a specialized TypeScript integration, and
luckily Astro provides an [in-depth guide](https://docs.astro.build/en/guides/typescript/). With
that being said, we do have a few requirements and pointers!

- Use the official [Astro `tsconfig.json`](https://docs.astro.build/en/guides/typescript/#setup) as
  a basis.
- From our internal testing, the `astro check` command (that typechecks `.astro` files) _does not
  support project references_. If the `composite` compiler option is enabled, the checker will fail
  to find `.astro` files. To work around this, we disable `workspace.typescript` in our moon config
  above.
- Since typechecking requires 2 commands, one for `.astro` files, and the other for `.ts`, `.tsx`
  files, we've added the [`typecheck`](./typescript) task as a dependency for the `check` task. This
  will run both commands through a single task!

## Configuration

### Root-level

We suggest _against_ root-level configuration, as Astro should be installed per-project, and the
`astro` command expects the configuration to live relative to the project root.

### Project-level

When creating a new Astro project, a
[`astro.config.mjs`](https://docs.astro.build/en/reference/configuration-reference/) is created, and
_must_ exist in the project root. This allows each project to configure Astro for their needs.

```js title="/astro.config.mjs"
import { defineConfig } from 'astro/config';

// https://astro.build/config
export default defineConfig({});
```

---

## ESLint example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [ESLint](https://eslint.org/) into moon.

Begin by installing `eslint` and any plugins in your root. We suggest using the same version across
the entire repository.

## Setup

Since linting is a universal workflow, add a `lint` task to
[`.moon/tasks/node.yml`](../../config/tasks) with the following parameters.

```yaml title=".moon/tasks/node.yml"
tasks:
  lint:
    command:
      - 'eslint'
      # Support other extensions
      - '--ext'
      - '.js,.jsx,.ts,.tsx'
      # Always fix and run extra checks
      - '--fix'
      - '--report-unused-disable-directives'
      # Dont fail if a project has nothing to lint
      - '--no-error-on-unmatched-pattern'
      # Do fail if we encounter a fatal error
      - '--exit-on-fatal-error'
      # Only 1 ignore file is supported, so use the root
      - '--ignore-path'
      - '@in(4)'
      # Run in current dir
      - '.'
    inputs:
      # Source and test files
      - 'src/**/*'
      - 'tests/**/*'
      # Other config files
      - '*.config.*'
      # Project configs, any format, any depth
      - '**/.eslintrc.*'
      # Root configs, any format
      - '/.eslintignore'
      - '/.eslintrc.*'
```

Projects can extend this task and provide additional parameters if need be, for example.

```yaml title="/moon.yml"
tasks:
  lint:
    args:
      # Enable caching for this project
      - '--cache'
```

### TypeScript integration

If you're using the [`@typescript-eslint`](https://typescript-eslint.io) packages, and want to
enable type-safety based lint rules, we suggest something similar to the official
[monorepo configuration](https://typescript-eslint.io/docs/linting/monorepo).

Create a `tsconfig.eslint.json` in your repository root, extend your shared compiler options (we use
[`tsconfig.options.json`](./typescript)), and include all your project files.

```json title="tsconfig.eslint.json"
{
  "extends": "./tsconfig.options.json",
  "compilerOptions": {
    "emitDeclarationOnly": false,
    "noEmit": true
  },
  "include": ["apps/**/*", "packages/**/*"]
}
```

Append the following inputs to your `lint` task.

```yaml title=".moon/tasks/node.yml"
tasks:
  lint:
    # ...
    inputs:
      # TypeScript support
      - 'types/**/*'
      - 'tsconfig.json'
      - '/tsconfig.eslint.json'
      - '/tsconfig.options.json'
```

And lastly, add `parserOptions` to your [root-level config](#root-level).

## Configuration

### Root-level

The root-level ESLint config is _required_, as ESLint traverses upwards from each file to find
configurations, and this denotes the stopping point. It's also used to define rules for the _entire_
repository.

```js title=".eslintrc.js"
module.exports = {
  root: true, // Required!
  extends: ['moon'],
  rules: {
    'no-console': 'error',
  },

  // TypeScript support
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.eslint.json',
    tsconfigRootDir: __dirname,
  },
};
```

The `.eslintignore` file must also be defined at the root, as
[only 1 ignore file](https://eslint.org/docs/user-guide/configuring/ignoring-code#the-eslintignore-file)
can exist in a repository. We ensure this ignore file is used by passing `--ignore-path` above.

```bash title=".eslintignore"
node_modules/
*.min.js
*.map
*.snap
```

### Project-level

A project-level ESLint config can be utilized by creating a `.eslintrc.` in the
project root. This is optional, but necessary when defining rules and ignore patterns unique to the
project.

```js title="/.eslintrc.js"
module.exports = {
  // Patterns to ignore (alongside the root .eslintignore)
  ignorePatterns: ['build', 'lib'],
  // Project specific rules
  rules: {
    'no-console': 'off',
  },
};
```

> The
> [`extends`](https://eslint.org/docs/user-guide/configuring/configuration-files#extending-configuration-files)
> setting should **not** extend the root-level config, as ESLint will automatically merge configs
> while traversing upwards!

### Sharing

To share configuration across projects, you have 3 options:

- Define settings in the [root-level config](#root-level). This only applies to the parent
  repository.
- Create and publish an
  [`eslint-config`](https://eslint.org/docs/developer-guide/shareable-configs#using-a-shareable-config)
  or [`eslint-plugin`](https://eslint.org/docs/developer-guide/working-with-plugins) npm package.
  This can be used in any repository.
- A combination of 1 and 2.

For options 2 and 3, if you're utilizing package workspaces, create a local package with the
following content.

```js title="packages/eslint-config-company/index.js"
module.exports = {
  extends: ['airbnb'],
};
```

Within your root-level ESLint config, you can extend this package to inherit the settings.

```js title=".eslintrc.js"
module.exports = {
  extends: 'eslint-config-company',
};
```

> When using this approach, the package must be built and symlinked into `node_modules` _before_ the
> linter will run correctly. Take this into account when going down this path!

## FAQ

### How to lint a single file or folder?

Unfortunately, this isn't currently possible, as the `eslint` binary itself requires a file or
folder path to operate on, and in the task above we pass `.` (current directory). If this was not
passed, then nothing would be linted.

This has the unintended side-effect of not being able to filter down lintable targets by passing
arbitrary file paths. This is something we hope to resolve in the future.

To work around this limitation, you can create another lint task.

### Should we use `overrides`?

Projects should define their own rules using an ESLint config in their project root. However, if you
want to avoid touching many ESLint configs (think migrations), then
[overrides in the root](https://eslint.org/docs/user-guide/configuring/configuration-files#configuration-based-on-glob-patterns)
are a viable option. Otherwise, we highly encourage project-level configs.

```js title=".eslintrc.js"
module.exports = {
  // ...
  overrides: [
    // Only apply to apps "foo" and "bar", but not others
    {
      files: ['apps/foo/**/*', 'apps/bar/**/*'],
      rules: {
        'no-magic-numbers': 'off',
      },
    },
  ],
};
```

---

## Jest example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Jest](https://jestjs.io/) into moon.

Begin by installing `jest` in your root. We suggest using the same version across the entire
repository.

## Setup

Since testing is a universal workflow, add a `test` task to
[`.moon/tasks/node.yml`](../../config/tasks) with the following parameters.

```yaml title=".moon/tasks/node.yml"
tasks:
  test:
    command:
      - 'jest'
      # Always run code coverage
      - '--coverage'
      # Dont fail if a project has no tests
      - '--passWithNoTests'
    inputs:
      # Source and test files
      - 'src/**/*'
      - 'tests/**/*'
      # Project configs, any format
      - 'jest.config.*'
```

Projects can extend this task and provide additional parameters if need be, for example.

```yaml title="/moon.yml"
tasks:
  test:
    args:
      # Disable caching for this project
      - '--no-cache'
```

## Configuration

### Root-level

A root-level Jest config is not required and should be avoided, instead, use a [preset](#sharing) to
share configuration.

### Project-level

A project-level Jest config can be utilized by creating a `jest.config.` in the
project root. This is optional, but necessary when defining project specific settings.

```js title="/jest.config.js"
module.exports = {
  // Project specific settings
  testEnvironment: 'node',
};
```

### Sharing

To share configuration across projects, you can utilize Jest's built-in
[`preset`](https://jestjs.io/docs/configuration#preset-string) functionality. If you're utilizing
package workspaces, create a local package with the following content, otherwise publish the npm
package for consumption.

```js title="packages/company-jest-preset/jest-preset.js"
module.exports = {
  testEnvironment: 'jsdom',
  watchman: true,
};
```

Within your project-level Jest config, you can extend the preset to inherit the settings.

```js title="/jest.config.js"
module.exports = {
  preset: 'company-jest-preset',
};
```

> You can take this a step further by passing the `--preset` option in the [task above](#setup), so
> that all projects inherit the preset by default.

## FAQ

### How to test a single file or folder?

You can filter tests by passing a file name, folder name, glob, or regex pattern after `--`. Any
passed files are relative from the project's root, regardless of where the `moon` command is being
ran.

```shell
$ moon run :test -- filename
```

### How to use `projects`?

With moon, there's no reason to use
[`projects`](https://jestjs.io/docs/configuration#projects-arraystring--projectconfig) as the `test`
task is ran _per_ project. If you'd like to test multiple projects, use
[`moon run :test`](../../commands/run).

---

## Nest example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [NestJS](https://nestjs.com/) into moon.

Begin by creating a new NestJS project in the root of an existing moon project (this should not be
created in the workspace root, unless a polyrepo).

```shell
npx @nestjs/cli@latest new nestjs-app --skip-git
```

> View the [official NestJS docs](https://docs.nestjs.com/first-steps) for a more in-depth guide to
> getting started!

## Setup

Since NestJS is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

```yaml title="/moon.yml"
layer: 'application'

fileGroups:
  app:
    - 'nest-cli.*'

tasks:
  dev:
    command: 'nest start --watch'
    local: true

  build:
    command: 'nest build'
    inputs:
      - '@group(app)'
      - '@group(sources)'
```

### TypeScript integration

NestJS has [built-in support for TypeScript](https://NestJS.io/guide/typescript-configuration), so
there is no need for additional configuration to enable TypeScript support.

At this point we'll assume that a `tsconfig.json` has been created in the application, and
typechecking works. From here we suggest utilizing a [global `typecheck` task](./typescript) for
consistency across all projects within the repository.

## Configuration

### Root-level

We suggest _against_ root-level configuration, as NestJS should be installed per-project, and the
`nest` command expects the configuration to live relative to the project root.

### Project-level

When creating a new NestJS project, a [`nest-cli.json`](https://docs.nestjs.com/cli/monorepo) is
created, and _must_ exist in the project root. This allows each project to configure NestJS for
their needs.

```json title="/nest-cli.json"
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "type": "application",
  "root": "./",
  "sourceRoot": "src",
  "compilerOptions": {
    "tsConfigPath": "tsconfig.build.json"
  }
}
```

---

## Next example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Next.js](https://nextjs.org) into moon.

Begin by creating a new Next.js project at a specified folder path (this should not be created in
the workspace root, unless a polyrepo).

```shell
cd apps && npx create-next-app  --typescript
```

> View the [official Next.js docs](https://nextjs.org/learn/basics/create-nextjs-app/setup) for a
> more in-depth guide to getting started!

## Setup

Since Next.js is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

:::tip

We suggest inheriting Next.js tasks from the
[official moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/next).

:::

```yaml title="/moon.yml"
# Inherit tasks from the `next` preset
# https://github.com/moonrepo/moon-configs
tags: ['next']
```

### ESLint integration

Next.js has [built-in support for ESLint](https://nextjs.org/docs/basic-features/eslint), which is
great, but complicates things a bit. Because of this, you have two options for moving forward:

- Use a [global `lint` task](./eslint) and bypass Next.js's solution (preferred).
- Use Next.js's solution only.

Regardless of which option is chosen, the following changes are applicable to all options and should
be made. Begin be installing the
[`eslint-config-next`](https://nextjs.org/docs/basic-features/eslint#eslint-config) dependency in
the application's `package.json`.

" dev />

Since the Next.js app is located within a subfolder, we'll need to tell the ESLint plugin where to
locate it. This can be achieved with a project-level `.eslintrc.js` file.

```js title="/.eslintrc.js"
module.exports = {
  extends: 'next', // or 'next/core-web-vitals'
  settings: {
    next: {
      rootDir: __dirname,
    },
  },
};
```

With the basics now setup, choose the option that works best for you.

We encourage using the global `lint` task for consistency across all projects within the repository.
With this approach, the `eslint` command itself will be ran and the `next lint` command will be
ignored, but the `eslint-config-next` rules will still be used.

Additionally, we suggest disabling the linter during the build process, but is not a requirement. As
a potential alternative, add the `lint` task as a dependency for the `build` task.

```js title="/next.config.js"
module.exports = {
  eslint: {
    ignoreDuringBuilds: true,
  },
};
```

If you'd prefer to use the `next lint` command, add it as a task to the project's
[`moon.yml`](../../config/project).

```yaml title="/moon.yml"
tasks:
  lint:
    command: 'next lint'
    inputs:
      - '@group(next)'
```

Furthermore, if a global `lint` task exists, be sure to exclude it from being inherited.

```yaml title="/moon.yml"
workspace:
  inheritedTasks:
    exclude: ['lint']
```

### TypeScript integration

Next.js also has
[built-in support for TypeScript](https://nextjs.org/docs/basic-features/typescript), but has
similar caveats to the [ESLint integration](#eslint-integration). TypeScript itself is a bit
involved, so we suggest reading the official Next.js documentation before continuing.

At this point we'll assume that a `tsconfig.json` has been created in the application, and
typechecking works. From here we suggest utilizing a [global `typecheck` task](./typescript) for
consistency across all projects within the repository.

Additionally, we suggest disabling the typechecker during the build process, but is not a
requirement. As a potential alternative, add the `typecheck` task as a dependency for the `build`
task.

```js title="/next.config.js"
module.exports = {
  typescript: {
    ignoreBuildErrors: true,
  },
};
```

## Configuration

### Root-level

We suggest _against_ root-level configuration, as Next.js should be installed per-project, and the
`next` command expects the configuration to live relative to the project root.

### Project-level

When creating a new Next.js project, a
[`next.config.`](https://nextjs.org/docs/api-reference/next.config.js/introduction) is
created, and _must_ exist in the project root. This allows each project to configure Next.js for
their needs.

```js title="/next.config.js"
module.exports = {
  compress: true,
};
```

---

## Nuxt example

import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Nuxt v3](https://nuxt.com), a [Vue](./vue) framework,
into moon.

Begin by creating a new Nuxt project at a specified folder path (this should not be created in the
workspace root, unless a polyrepo).

```shell
cd apps && npx nuxi init 
```

> View the [official Nuxt docs](https://nuxt.com/docs/getting-started/installation) for a more
> in-depth guide to getting started!

## Setup

Since Nuxt is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

```yaml title="/moon.yml"
fileGroups:
  nuxt:
    - 'assets/**/*'
    - 'components/**/*'
    - 'composables/**/*'
    - 'content/**/*'
    - 'layouts/**/*'
    - 'middleware/**/*'
    - 'pages/**/*'
    - 'plugins/**/*'
    - 'public/**/*'
    - 'server/**/*'
    - 'utils/**/*'
    - '.nuxtignore'
    - 'app.config.*'
    - 'app.vue'
    - 'nuxt.config.*'

tasks:
  nuxt:
    command: 'nuxt'
    local: true

  # Production build
  build:
    command: 'nuxt build'
    inputs:
      - '@group(nuxt)'
    outputs:
      - '.nuxt'
      - '.output'

  # Development server
  dev:
    command: 'nuxt dev'
    local: true

  # Preview production build locally
  preview:
    command: 'nuxt preview'
    deps:
      - '~:build'
    local: true
```

Be sure to keep the `postinstall` script in your project's `package.json`.

```json title="/package.json"
{
  // ...
  "scripts": {
    "postinstall": "nuxt prepare"
  }
}
```

### ESLint integration

Refer to our [Vue documentation](./vue#eslint-integration) for more information on linting.

### TypeScript integration

Nuxt requires `vue-tsc` for typechecking, so refer to our
[Vue documentation](./vue#typescript-integration) for more information.

## Configuration

### Root-level

We suggest _against_ root-level configuration, as Nuxt should be installed per-project, and the
`nuxt` command expects the configuration to live relative to the project root.

### Project-level

When creating a new Nuxt project, a
[`nuxt.config.ts`](https://v3.nuxtjs.org/api/configuration/nuxt-config) is created, and _must_ exist
in the project root. This allows each project to configure Next.js for their needs.

```js title="/nuxt.config.ts"
export default defineNuxtConfig({});
```

## Testing

Nuxt supports testing through [Jest](https://jestjs.io/) or [Vitest](https://vitest.dev/). Refer to
our [Jest documentation](./jest) or [Vitest documentation](./vite) for more information on testing.

---

## Packemon example

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import AddDepsTabs from '@site/src/components/AddDepsTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Packemon](https://packemon.dev/) into moon. Packemon
is a tool for properly building npm packages for distribution, it does this by providing the
following functionality:

- Compiles source code to popular formats: CJS, MJS, ESM, UMD, etc.
- Validates the `package.json` for incorrect fields or values.
- Generates `exports` mappings for `package.json` based on the define configuration.
- And many more [optimizations and features](https://packemon.dev/docs/features)!

Begin by installing `packemon` in your root. We suggest using the same version across the entire
repository.

## Setup

Since Packemon is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

:::tip

We suggest inheriting Packemon tasks from the
[official moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/packemon).

:::

```yaml title="/moon.yml"
# Inherit tasks from the `packemon` preset
# https://github.com/moonrepo/moon-configs
tags: ['packemon']

# Set the output formats
tasks:
  build:
    outputs:
      - 'cjs'
```

### TypeScript integration

Packemon has built-in support for TypeScript, but to _not_ conflict with a
[typecheck task](./typescript), a separate `tsconfig.json` file is required, which is named
`tsconfig..json`.

This config is necessary to _only_ compile source files, and to not include unwanted files in the
declaration output directory.

```json title="tsconfig.esm.json"
{
  "extends": "../../tsconfig.options.json",
  "compilerOptions": {
    "outDir": "esm",
    "rootDir": "src"
  },
  "include": ["src/**/*"],
  "references": []
}
```

### Build targets

To configure the target platform(s) and format(s), you must define a
[`packemon` block](https://packemon.dev/docs/config) in the project's `package.json`. The chosen
formats must also be listed as `outputs` in the task.

```json title="package.json"
{
  "name": "package",
  // ...
  "packemon": {
    "format": "esm",
    "platform": "browser"
  }
}
```

---

## Prettier example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Prettier](https://prettier.io/) into moon.

Begin by installing `prettier` in your root. We suggest using the same version across the entire
repository.

## Setup

Since code formatting is a universal workflow, add a `format` task to
[`.moon/tasks/node.yml`](../../config/tasks) with the following parameters.

```yaml title=".moon/tasks/node.yml"
tasks:
  format:
    command:
      - 'prettier'
      # Use the same config for the entire repo
      - '--config'
      - '@in(4)'
      # Use the same ignore patterns as well
      - '--ignore-path'
      - '@in(3)'
      # Fail for unformatted code
      - '--check'
      # Run in current dir
      - '.'
    inputs:
      # Source and test files
      - 'src/**/*'
      - 'tests/**/*'
      # Config and other files
      - '**/*.{md,mdx,yml,yaml,json}'
      # Root configs, any format
      - '/.prettierignore'
      - '/.prettierrc.*'
```

## Configuration

### Root-level

The root-level Prettier config is _required_, as it defines conventions and standards to apply to
the entire repository.

```js title=".prettierrc.js"
module.exports = {
  arrowParens: 'always',
  semi: true,
  singleQuote: true,
  tabWidth: 2,
  trailingComma: 'all',
  useTabs: true,
};
```

The `.prettierignore` file must also be defined at the root, as
[only 1 ignore file](https://prettier.io/docs/en/ignore.html#ignoring-files-prettierignore) can
exist in a repository. We ensure this ignore file is used by passing `--ignore-path` above.

```bash title=".prettierignore"
node_modules/
*.min.js
*.map
*.snap
```

### Project-level

We suggest _against_ project-level configurations, as the entire repository should be formatted
using the same standards. However, if you're migrating code and need an escape hatch,
[overrides in the root](https://prettier.io/docs/en/configuration.html#configuration-overrides) will
work.

## FAQ

### How to use `--write`?

Unfortunately, this isn't currently possible, as the `prettier` binary itself requires either the
`--check` or `--write` options, and since we're configuring `--check` in the task above, that takes
precedence. This is also the preferred pattern as checks will run (and fail) in CI.

To work around this limitation, we suggest the following alternatives:

- Configure your editor to run Prettier on save.
- Define another task to write the formatted code, like `format-write`.

---

## React example

import AddDepsTabs from '@site/src/components/AddDepsTabs';

React is an application or library concern, and not a build system one, since the bundling of React
is abstracted away through another tool like webpack. Because of this, moon has no guidelines around
utilizing React directly. You can use React however you wish!

However, with that being said, we do suggest the following:

- Add `react` and related dependencies to each project, not the root. This includes `@types/react`
  as well. This will ensure accurate [hashing](../../concepts/cache#hashing).

" />

- Configure Babel with the `@babel/preset-react` preset.
- Configure [TypeScript](./typescript) compiler options with `"jsx": "react-jsx"`.

---

## Remix example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Remix](https://remix.run) into moon.

Begin by creating a new Remix project at a specified folder path (this should not be created in the
workspace root, unless a polyrepo).

```shell
cd apps && npx create-remix
```

During this installation, Remix will ask a handful of questions, but be sure to answer "No" for the
"Do you want me to run `npm install`?" question. We suggest installing dependencies at the workspace
root via package workspaces!

> View the [official Remix docs](https://remix.run/docs/en/v1) for a more in-depth guide to getting
> started!

## Setup

Since Remix is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

:::tip

We suggest inheriting Remix tasks from the
[official moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/remix).

:::

```yaml title="/moon.yml"
# Inherit tasks from the `remix` preset
# https://github.com/moonrepo/moon-configs
tags: ['remix']
```

### ESLint integration

Remix does not provide a built-in linting abstraction, and instead provides a simple ESLint
configuration package,
[`@remix-run/eslint-config`](https://www.npmjs.com/package/@remix-run/eslint-config). For the rest
of this section, we're going to assume that a [global `lint` task](./eslint) has been configured.

Begin be installing the `@remix-run/eslint-config` dependency in the application's `package.json`.
We can then enable this configuration by creating an `.eslintrc.js` file in the project root. Be
sure this file is listed in your `lint` task's inputs!

```js title="/.eslintrc.js"
module.exports = {
  extends: ['@remix-run/eslint-config', '@remix-run/eslint-config/node'],

  // If using TypeScript
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
  },
};
```

### TypeScript integration

Remix ships with TypeScript support (when enabled during installation), but the `tsconfig.json` it
generates is _not_ setup for TypeScript project references, which we suggest using with a
[global `typecheck` task](./typescript).

When using project references, we suggest the following `tsconfig.json`, which is a mix of Remix and
moon. Other compiler options, like `isolatedModules` and `esModuleInterop`, should be declared in a
shared configuration found in the workspace root (`tsconfig.projectOptions.json` in the example).

```json title="/tsconfig.json"
{
  "extends": "../../tsconfig.projectOptions.json",
  "compilerOptions": {
    "baseUrl": ".",
    "emitDeclarationOnly": false,
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "noEmit": true,
    "paths": {
      "~/*": ["./app/*"]
    }
  },
  "include": [".eslintrc.js", "remix.env.d.ts", "**/*"],
  "exclude": [".cache", "build", "public"]
}
```

## Configuration

### Root-level

We suggest _against_ root-level configuration, as Remix should be installed per-project, and the
`remix` command expects the configuration to live relative to the project root.

### Project-level

When creating a new Remix project, a
[`remix.config.js`](https://remix.run/docs/en/v1/api/conventions) is created, and _must_ exist in
the project root. This allows each project to configure Remix for their needs.

```js title="/remix.config.js"
module.exports = {
  appDirectory: 'app',
};
```

---

## Solid example

import AddDepsTabs from '@site/src/components/AddDepsTabs';

[Solid](https://www.solidjs.com) (also known as SolidJS) is a JavaScript framework for building
interactive web applications. Because of this, Solid is an application or library concern, and not a
build system one, since the bundling of Solid is abstracted away through the application or a
bundler.

With that being said, we do have some suggestions on utilizing Solid effectively in a monorepo. To
begin, install Solid to a project.

" />

## Setup

Solid utilizes JSX for rendering markup, which requires
[`babel-preset-solid`](https://www.npmjs.com/package/babel-preset-solid) for parsing and
transforming. To enable the preset for the entire monorepo, add the preset to a root
`babel.config.js`, otherwise add it to a `.babelrc.js` in each project that requires it.

```js
module.exports = {
  presets: ['solid'],
};
```

### TypeScript integration

For each project using Solid, add the following compiler options to the `tsconfig.json` found in the
project root.

```json title="/tsconfig.json"
{
  "compilerOptions": {
    "jsx": "preserve",
    "jsxImportSource": "solid-js"
  }
}
```

### Vite integration

If you're using a [Vite](./vite) powered application (Solid Start or starter templates), you should
enable [`vite-plugin-solid`](https://www.npmjs.com/package/vite-plugin-solid) instead of configuring
Babel. Be sure to read our [guide on Vite](./vite) as well!

```js title="/vite.config.js"
import { defineConfig } from 'vite';
import solidPlugin from 'vite-plugin-solid';

export default defineConfig({
  // ...
  plugins: [solidPlugin()],
});
```

---

## Storybook example

import AddDepsTabs from '@site/src/components/AddDepsTabs';

Storybook is a frontend workshop for building UI components and pages in isolation. Thousands of
teams use it for UI development, testing, and documentation. It’s open source and free.

[Storybook v7](https://storybook.js.org/docs/7.0) is typically coupled with
[Vite](https://vitejs.dev/). To scaffold a new Storybook project with Vite, run the following
command in a project root. This guide assumes you are using React, however it is possible to use
almost any (meta) framework with Storybook.

```shell
cd  && npx storybook init
```

> We highly suggest reading our documentation on [using Vite (and Vitest) with moon](./vite) and
> [using Jest with moon](./jest) for a more holistic view.

## Setup

This section assumes Storybook is being used with Vite, and is integrated on a per-project basis.

After setting up Storybook, ensure [`moon.yml`](../../config/project) has the following tasks:

```yaml title="/moon.yml"
fileGroups:
  storybook:
    - 'src/**/*'
    - 'stories/**/*'
    - 'tests/**/*'
    - '.storybook/**/*'

tasks:
  buildStorybook:
    command: 'build-storybook --output-dir @out(0)'
    inputs:
      - '@group(storybook)'
    outputs:
      - 'build'

  storybook:
    local: true
    command: 'start-storybook'
    inputs:
      - '@group(storybook)'
```

To run the Storybook development server:

```shell
moon run :storybook
```

### Vite integration

Storybook 7 uses Vite out of the box, and as such, no configuration is required, but should you
choose to extend the Vite config, you can do so by passing in `viteFinal`:

```ts title=".storybook/main.ts"
import { mergeConfig } from 'vite';

export default {
  stories: ['../stories/**/*.stories.mdx', '../stories/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: ['@storybook/addon-links', '@storybook/addon-essentials'],
  core: {
    builder: '@storybook/builder-vite',
  },
  async viteFinal(config) {
    // Merge custom configuration into the default config
    return mergeConfig(config, {
      // Use the same "resolve" configuration as your app
      resolve: (await import('../vite.config.js')).default.resolve,
      // Add dependencies to pre-optimization
      optimizeDeps: {
        include: ['storybook-dark-mode'],
      },
    });
  },
};
```

For more information on how to integrate Vite with Storybook see the
[relevant documentation](https://storybook.js.org/docs/7.0/react/builders/vite#configuration).

### Webpack integration

If you want to use Webpack with your Storybook project, you can do so by installing the relevant
package and updating configuration.

" />

```ts title=".storybook/main.ts"
export default {
  core: {
    builder: '@storybook/builder-webpack5',
  },
};
```

For more information on how to integrate Webpack with Storybook, see the
[relevant documentation](https://storybook.js.org/docs/7.0/react/builders/webpack).

### Jest integration

You can use Jest to test your stories, but isn't a requirement. Storybook ships with first-party
plugins for improved developer experience.

Install the test runner and any relevant packages:

"
/>

Add the test task to your project:

```yaml title="/moon.yml"
tasks:
  testStorybook:
    command: 'test-storybook'
    inputs:
      - '@group(storybook)'
```

Then enable plugins and interactions in your Storybook project:

```ts title=".storybook/main.ts"
export default {
  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    // Other Storybook addons
    '@storybook/addon-interactions', // Addon is registered here
    '@storybook/addon-coverage',
  ],
  features: {
    interactionsDebugger: true, // Enable playback controls
  },
};
```

You can now start writing your tests. For an extended guide on how to write tests within your
stories, see
[writing an interaction test](https://storybook.js.org/docs/react/writing-tests/interaction-testing#write-an-interaction-test)
on the Storybook docs.

## Configuration

Storybook requires a `.storybook` folder relative to the project root. Because of this, Storybook
should be scaffolded in each project individually. Configuration may be shared through package
imports.

---

## SvelteKit example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

[SvelteKit](https://kit.svelte.dev) is built on [Svelte](https://svelte.dev), a UI framework that
uses a compiler to let you write breathtakingly concise components that do minimal work in the
browser, using languages you already know — HTML, CSS and JavaScript. It's a love letter to web
development.

```shell
cd apps && npm create svelte@latest 
```

You will be prompted to choose between select templates, TypeScript, ESLint, Prettier, Playwright
and Vitest among other options. moon supports and has guides for many of these tools.

> We highly suggest reading our documentation on [using Vite (and Vitest) with moon](./vite),
> [using ESLint with moon](./eslint) and [using Prettier with moon](./prettier) for a more holistic
> view.

## Setup

Since SvelteKit is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

:::tip

We suggest inheriting SvelteKit tasks from the
[official moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/sveltekit).

:::

```yaml title="/moon.yml"
# Inherit tasks from the `sveltekit` preset
# https://github.com/moonrepo/moon-configs
tags: ['sveltekit']
```

### ESLint integration

SvelteKit provides an option to setup ESLint along with your project, with moon you can use a
[global `lint` task](./eslint). We encourage using the global `lint` task for consistency across all
projects within the repository. With this approach, the `eslint` command itself will be ran and the
`svelte3` rules will still be used.

```yaml title="/moon.yml"
tasks:
  # Extends the top-level lint
  lint:
    args:
      - '--ext'
      - '.ts,.svelte'
```

Be sure to enable the Svelte parser and plugin in a project local ESLint configuration file.

```js title=".eslintrc.cjs"
module.exports = {
  plugins: ['svelte3'],
  ignorePatterns: ['*.cjs'],
  settings: {
    'svelte3/typescript': () => require('typescript'),
  },
  overrides: [{ files: ['*.svelte'], processor: 'svelte3/svelte3' }],
};
```

### TypeScript integration

SvelteKit also has built-in support for TypeScript, but has similar caveats to the
[ESLint integration](#eslint-integration). TypeScript itself is a bit involved, so we suggest
reading the official [SvelteKit documentation](https://kit.svelte.dev/docs/introduction) before
continuing.

At this point we'll assume that a `tsconfig.json` has been created in the application, and
typechecking works. From here we suggest utilizing a [global `typecheck` task](./typescript) for
consistency across all projects within the repository. However, because Svelte isn't standard
JavaScript, it requires the use of the `svelte-check` command for type-checking.

:::info

The
[moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/sveltekit)
provides the `check` task below.

:::

```yaml title="/moon.yml"
workspace:
  inheritedTasks:
    exclude: ['typecheck']

tasks:
  check:
    command: 'svelte-check --tsconfig ./tsconfig.json'
    deps:
      - 'typecheck-sync'
    inputs:
      - '@group(svelte)'
      - 'tsconfig.json'
```

In case Svelte doesn't automatically create a `tsconfig.json`, you can use the following:

```json title="/tsconfig.json"
{
  "extends": "./.svelte-kit/tsconfig.json",
  "compilerOptions": {
    "allowJs": true,
    "checkJs": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "sourceMap": true,
    "strict": true
  }
}
```

## Configuration

### Root-level

We suggest _against_ root-level configuration, as SvelteKit should be installed per-project, and the
`vite` command expects the configuration to live relative to the project root.

### Project-level

When creating a new SvelteKit project, a
[`svelte.config.js`](https://kit.svelte.dev/docs/configuration) is created, and _must_ exist in the
project root. This allows each project to configure SvelteKit for their needs.

```js title="/svelte.config.js"
import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/kit/vite';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  // Consult https://kit.svelte.dev/docs/integrations#preprocessors
  // for more information about preprocessors
  preprocess: vitePreprocess(),

  kit: {
    adapter: adapter(),
  },
};

export default config;
```

---

## TypeScript example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [TypeScript](https://eslint.org/) into moon. We'll be
using [project references](../javascript/typescript-project-refs), as it ensures that only affected
projects are built, and not the entire repository.

Begin by installing `typescript` and any pre-configured tsconfig packages in your root. We suggest
using the same version across the entire repository.

## Setup

Since typechecking is a universal workflow, add a `typecheck` task to
[`.moon/tasks/node.yml`](../../config/tasks) with the following parameters.

```yaml title=".moon/tasks/node.yml"
tasks:
  typecheck:
    command:
      - 'tsc'
      # Use incremental builds with project references
      - '--build'
      # Always use pretty output
      - '--pretty'
      # Use verbose logging to see affected projects
      - '--verbose'
    inputs:
      # Source and test files
      - 'src/**/*'
      - 'tests/**/*'
      # Type declarations
      - 'types/**/*'
      # Project configs
      - 'tsconfig.json'
      - 'tsconfig.*.json'
      # Root configs (extended from only)
      - '/tsconfig.options.json'
    outputs:
      # Matches `compilerOptions.outDir`
      - 'lib'
```

Projects can extend this task and provide additional parameters if need be, for example.

```yaml title="/moon.yml"
tasks:
  typecheck:
    args:
      # Force build every time
      - '--force'
```

## Configuration

### Root-level

Multiple root-level TypeScript configs are _required_, as we need to define compiler options that
are shared across the repository, and we need to house a list of all project references.

To start, let's create a `tsconfig.options.json` that will contain our compiler options. In our
example, we'll extend [tsconfig-moon](https://www.npmjs.com/package/tsconfig-moon) for convenience.
Specifically, the `tsconfig.workspaces.json` config, which enables ECMAScript modules, composite
mode, declaration emitting, and incremental builds.

```json title="tsconfig.options.json"
{
  "extends": "tsconfig-moon/tsconfig.projects.json",
  "compilerOptions": {
    // Your custom options
    "moduleResolution": "nodenext",
    "target": "es2022"
  }
}
```

We'll also need the standard `tsconfig.json` to house our project references. This is used by
editors and tooling for deep integrations.

```json title="tsconfig.json"
{
  "extends": "./tsconfig.options.json",
  "files": [],
  // All project references in the repo
  "references": []
}
```

> The [`typescript.rootConfigFileName`](../../config/toolchain#rootconfigfilename) setting can be
> used to change the root-level config name and the
> [`typescript.syncProjectReferences`](../../config/toolchain#syncprojectreferences) setting will
> automatically keep project references in sync!

### Project-level

Every project will require a `tsconfig.json`, as TypeScript itself requires it. The following
`tsconfig.json` will typecheck the entire project, including source and test files.

```json title="/tsconfig.json"
{
  // Extend the root compiler options
  "extends": "../../tsconfig.options.json",
  "compilerOptions": {
    // Declarations are written here
    "outDir": "lib"
  },
  // Include files in the project
  "include": ["src/**/*", "tests/**/*"],
  // Depends on other projects
  "references": []
}
```

> The [`typescript.projectConfigFileName`](../../config/toolchain#projectconfigfilename) setting can
> be used to change the project-level config name.

### Sharing

To share configuration across projects, you have 3 options:

- Define settings in a [root-level config](#root-level). This only applies to the parent repository.
- Create and publish an
  [`tsconfig base`](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html#tsconfig-bases)
  npm package. This can be used in any repository.
- A combination of 1 and 2.

For options 2 and 3, if you're utilizing package workspaces, create a local package with the
following content.

```json title="packages/tsconfig-company/tsconfig.json"
{
  "compilerOptions": {
    // ...
    "lib": ["esnext"]
  }
}
```

Within another `tsconfig.json`, you can extend this package to inherit the settings.

```json title="tsconfig.json"
{
  "extends": "tsconfig-company/tsconfig.json"
}
```

## FAQ

### How to preserve pretty output?

TypeScript supports a pretty format where it includes codeframes and color highlighting for
failures. However, when `tsc` is piped or the terminal is not a TTY, the pretty format is lost. To
preserve and always display the pretty format, be sure to pass the `--pretty` argument!

---

## Vite & Vitest example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import CreateDepTabs from '@site/src/components/CreateDepTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

In this guide, you'll learn how to integrate [Vite](https://vitejs.dev/) and
[Vitest](https://vitest.dev/) into moon.

Begin by creating a new Vite project in the root of an existing moon project (this should not be
created in the workspace root, unless a polyrepo).

If you plan on using Vitest, run the following command to add the `vitest` dependency to a project,
otherwise skip to the setup section.

" dev />

## Setup

Since Vite is per-project, the associated moon tasks should be defined in each project's
[`moon.yml`](../../config/project) file.

:::tip

We suggest inheriting Vite tasks from the
[official moon configuration preset](https://github.com/moonrepo/moon-configs/tree/master/javascript/vite).

:::

```yaml title="/moon.yml"
# Inherit tasks from the `vite` and `vitest` presets
# https://github.com/moonrepo/moon-configs
tags: ['vite', 'vitest']
```

## Configuration

### Root-level

We suggest _against_ root-level configuration, as Vite should be installed per-project, and the
`vite` command expects the configuration to live relative to the project root.

### Project-level

When creating a new Vite project, a [`vite.config.`](https://vitejs.dev/config) is created,
and _must_ exist in the project root.

```js title="/vite.config.js"
import { defineConfig } from 'vite';

export default defineConfig({
  // ...
  build: {
    // These must be `outputs` in the `build` task
    outDir: 'dist',
  },
  test: {
    // Vitest settings
  },
});
```

> If you'd prefer to configure Vitest in a
> [separate configuration file](https://vitest.dev/guide/#configuring-vitest), create a
> `vitest.config.` file.

---

## Vue example

import AddDepsTabs from '@site/src/components/AddDepsTabs';
import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';

Vue is an application or library concern, and not a build system one, since the bundling of Vue is
abstracted away through other tools. Because of this, moon has no guidelines around utilizing Vue
directly. You can use Vue however you wish!

However, with that being said, Vue is typically coupled with [Vite](https://vitejs.dev/). To
scaffold a new Vue project with Vite, run the following command in a project root.

```shell
npm init vue@latest
```

> We highly suggest reading our documentation on [using Vite (and Vitest) with moon](./vite) for a
> more holistic view.

## Setup

This section assumes Vue is being used with Vite.

### ESLint integration

When linting with [ESLint](./eslint) and the
[`eslint-plugin-vue`](https://eslint.vuejs.org/user-guide/#installation) library, you'll need to
include the `.vue` extension within the `lint` task. This can be done by extending the top-level
task within the project (below), or by adding it to the top-level entirely.

```yaml title="/moon.yml"
tasks:
  lint:
    args:
      - '--ext'
      - '.js,.ts,.vue'
```

Furthermore, when using TypeScript within ESLint, we need to make a few additional changes to the
`.eslintrc.js` config found in the root (if the entire repo is Vue), or within the project (if only
the project is Vue).

```js
module.exports = {
  parser: 'vue-eslint-parser',
  parserOptions: {
    extraFileExtensions: ['.vue'],
    parser: '@typescript-eslint/parser',
    project: 'tsconfig.json', // Or another config
    tsconfigRootDir: __dirname,
  },
};
```

### TypeScript integration

Vue does not use [TypeScript](./typescript)'s `tsc` binary directly, but instead uses
[`vue-tsc`](https://vuejs.org/guide/typescript/overview.html), which is a thin wrapper around `tsc`
to support Vue components. Because of this, we should update the `typecheck` task in the project to
utilize this command instead.

```yaml title="/moon.yml"
workspace:
  inheritedTasks:
    exclude: ['typecheck']

tasks:
  typecheck:
    command:
      - 'vue-tsc'
      - '--noEmit'
      # Always use pretty output
      - '--pretty'
    inputs:
      - 'env.d.ts'
      # Source and test files
      - 'src/**/*'
      - 'tests/**/*'
      # Project configs
      - 'tsconfig.json'
      - 'tsconfig.*.json'
      # Root configs (extended from only)
      - '/tsconfig.options.json'
```

> Be sure `tsconfig.json` compiler options are based on
> [`@vue/tsconfig`](https://vuejs.org/guide/typescript/overview.html#configuring-tsconfig-json).

---

## Extensions

import VersionLabel from '@site/src/components/Docs/VersionLabel';

An extension is a WASM plugin that allows you to extend moon with additional functionality, have
whitelisted access to the file system, and receive partial information about the current workspace.
Extensions are extremely useful in offering new and unique functionality that doesn't need to be
built into moon's core. It also enables the community to build and share their own extensions!

## Using extensions

Before an extension can be executed with the [`moon ext`](../commands/ext) command, it must be
configured with the [`extensions`](../config/workspace#extensions) setting in
[`.moon/workspace.yml`](../config/workspace) (excluding [built-in's](#built-in-extensions)).

```yaml title=".moon/workspace.yml"
extensions:
  example:
    plugin: 'https://example.com/path/to/example.wasm'
```

Once configured, it can be executed with [`moon ext`](../commands/ext) by name. Arguments unique to
the extension _must_ be passed after a `--` separator.

```shell
$ moon ext example -- --arg1 --arg2
```

## Built-in extensions

moon is shipped with a few built-in extensions that are configured and enabled by default. Official
moon extensions are built and published in our [moonrepo/moon-extensions][repo] repository.

### `download`

The `download` extension can be used to download a file from a URL into the current workspace, as
defined by the `--url` argument. For example, say we want to download the latest [proto](/proto)
binary:

```shell
$ moon ext download --\
  --url https://github.com/moonrepo/proto/releases/latest/download/proto_cli-aarch64-apple-darwin.tar.xz
```

By default this will download `proto_cli-aarch64-apple-darwin.tar.xz` into the current working
directory. To customize the location, use the `--dest` argument. However, do note that the
destination _must be_ within the current moon workspace, as only certain directories are whitelisted
for WASM.

```shell
$ moon ext download --\
  --url https://github.com/moonrepo/proto/releases/latest/download/proto_cli-aarch64-apple-darwin.tar.xz\
  --dest ./temp
```

#### Arguments

- `--url` (required) - URL of a file to download.
- `--dest` - Destination folder to save the file. Defaults to the current working directory.
- `--name` - Override the file name. Defaults to the file name in the URL.

### `migrate-nx`

> This extension is currently _experimental_ and will be improved over time.

The `migrate-nx` extension can be used to migrate an Nx powered repository to moon. This process
will convert the root `nx.json` and `workspace.json` files, and any `project.json` and
`package.json` files found within the repository. The following changes are made:

- Migrates `targetDefaults` as global tasks to [`.moon/tasks/node.yml`](../config/tasks#tasks) (or
  `bun.yml`), `namedInputs` as file groups, `workspaceLayout` as projects, and more.
- Migrates all `project.json` settings to [`moon.yml`](../config/project#tasks) equivalent settings.
  Target to task conversion assumes the following:
  - Target `executor` will be removed, and we'll attempt to extract the appropriate npm package
    command. For example, `@nx/webpack:build` -> `webpack build`.
  - Target `options` will be converted to task `args`.
  - The `{projectRoot}` and `{workspaceRoot}` interpolations will be replaced with moon tokens.

```shell
$ moon ext migrate-nx
```

:::caution

Nx and moon are quite different, so many settings are either ignored when converting, or are not a
1:1 conversion. We do our best to convert as much as possible, but some manual patching will most
likely be required! We suggest testing each converted task 1-by-1 to ensure it works as expected.

:::

#### Arguments

- `--bun` - Migrate to Bun based commands instead of Node.js.
- `--cleanup` - Remove Nx configs/files after migrating.

#### Unsupported

The following features are not supported in moon, and are ignored when converting.

- Most settings in `nx.json`.
- Named input variants: external dependencies, dependent task output files, dependent project
  inputs, or runtime commands.
- Target `configurations` and `defaultConfiguration`. Another task will be created instead that uses
  `extends`.
- Project `root` and `sourceRoot`.

### `migrate-turborepo`

The `migrate-turborepo` extension can be used to migrate a Turborepo powered repository to moon.
This process will convert the root `turbo.json` file, and any `turbo.json` files found within the
repository. The following changes are made:

- Migrates `pipeline` (v1) and `tasks` (v2) global tasks to
  [`.moon/tasks/node.yml`](../config/tasks#tasks) (or `bun.yml`) and project scoped tasks to
  [`moon.yml`](../config/project#tasks). Task commands will execute `package.json` scripts through a
  package manager.
- Migrates root `global*` settings to [`.moon/tasks/node.yml`](../config/tasks#implicitinputs) (or
  `bun.yml`) as `implicitInputs`.

```shell
$ moon ext migrate-turborepo
```

#### Arguments

- `--bun` - Migrate to Bun based commands instead of Node.js.
- `--cleanup` - Remove Turborepo configs/files after migrating.

## Creating an extension

Refer to our [official WASM guide](./wasm-plugins) for more information on how our WASM plugins
work, critical concepts to know, how to create a plugin, and more. Once you have a good
understanding, you may continue this specific guide.

:::note

Refer to our [moonrepo/moon-extensions][repo] repository for in-depth examples.

:::

### Registering metadata

Before we begin, we must implement the `register_extension` function, which simply provides some
metadata that we can bubble up to users, or to use for deeper integrations.

```rust
use extism_pdk::*;
use moon_pdk::*;

#[plugin_fn]
pub fn register_extension(Json(input): Json) -> FnResult> {
   Ok(Json(ExtensionMetadataOutput {
        name: "Extension name".into(),
        description: Some("A description about what the extension does.".into()),
        plugin_version: env!("CARGO_PKG_VERSION").into(),
        ..ExtensionMetadataOutput::default()
    }))
}
```

#### Configuration schema

If you are using [configuration](#supporting-configuration), you can register the shape of the
configuration using the [`schematic`](https://crates.io/crates/schematic) crate. This shape will be
used to generate outputs such as JSON schemas, or TypeScript types.

```rust
#[plugin_fn]
pub fn register_extension(_: ()) -> FnResult> {
    Ok(Json(ExtensionMetadataOutput {
        // ...
        config_schema: Some(schematic::SchemaBuilder::generate::()),
    }))
}
```

Schematic is a heavy library, so we suggest adding the dependency like so:

```toml
[dependencies]
schematic = { version = "*", default-features = false, features = ["schema"] }
```

### Implementing execution

Extensions support a single plugin function, `execute_extension`, which is called by the
[`moon ext`](../commands/ext) command to execute the extension. This is where all your business
logic will reside.

```rust
#[host_fn]
extern "ExtismHost" {
    fn host_log(input: Json);
}

#[plugin_fn]
pub fn execute_extension(Json(input): Json) -> FnResult {
  host_log!(stdout, "Executing extension!");

  Ok(())
}
```

### Supporting arguments

Most extensions will require arguments, as it provides a mechanism for users to pass information
into the WASM runtime. To parse arguments, we provide the
[`Args`](https://docs.rs/clap/latest/clap/trait.Args.html) trait/macro from the
[clap](https://crates.io/crates/clap) crate. Refer to their
[official documentation on usage](https://docs.rs/clap/latest/clap/_derive/index.html) (we don't
support everything).

```rust
use moon_pdk::*;

#[derive(Args)]
pub struct ExampleExtensionArgs {
  // --url, -u
  #[arg(long, short = 'u', required = true)]
  pub url: String,
}
```

Once your struct has been defined, you can parse the provided input arguments using the
[`parse_args`](https://docs.rs/moon_pdk/latest/moon_pdk/args/fn.parse_args.html) function.

```rust
#[plugin_fn]
pub fn execute_extension(Json(input): Json) -> FnResult {
  let args = parse_args::(&input.args)?;

  args.url; // --url

  Ok(())
}
```

### Supporting configuration

Users can configure [extensions](../config/workspace#extensions) with additional settings in
[`.moon/workspace.yml`](../config/workspace). Do note that settings should be in camelCase for them
to be parsed correctly!

```yaml title=".moon/workspace.yml"
extensions:
  example:
    plugin: 'file://./path/to/example.wasm'
    someSetting: 'abc'
    anotherSetting: 123
```

In the plugin, we can map these settings (excluding `plugin`) into a struct. The `Default` trait
must be implemented to handle situations where settings were not configured, or some are missing.

```rust
config_struct!(
  #[derive(Default)]
  pub struct ExampleExtensionConfig {
    pub some_setting: String,
    pub another_setting: u32,
  }
);
```

Once your struct has been defined, you can access the configuration using the
[`get_extension_config`](https://docs.rs/moon_pdk/latest/moon_pdk/extension/fn.get_extension_config.html)
function.

```rust
#[plugin_fn]
pub fn execute_extension(Json(input): Json) -> FnResult {
  let config = get_extension_config::()?;

  config.another_setting; // 123

  Ok(())
}
```

[repo]: https://github.com/moonrepo/moon-extensions

---

## Bun handbook

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Utilizing JavaScript (and TypeScript) in a monorepo can be a daunting task, especially when using
Bun (or Node.js), as there are many ways to structure your code and to configure your tools. With
this handbook, we'll help guide you through this process.

:::info

This guide is a living document and will continue to be updated over time!

:::

## moon setup

For this part of the handbook, we'll be focusing on [moon](/moon), our task runner. To start,
languages in moon act like plugins, where their functionality and support _is not_ enabled unless
explicitly configured. We follow this approach to avoid unnecessary overhead.

### Enabling the language

To enable JavaScript support via Bun, define the [`bun`](../../config/toolchain#bun) setting in
[`.moon/toolchain.yml`](../../config/toolchain), even if an empty object.

```yaml title=".moon/toolchain.yml"
# Enable Bun
bun: {}
```

Or by pinning a `bun` version in [`.prototools`](../../proto/config) in the workspace root.

```toml title=".prototools"
bun = "1.0.0"
```

This will enable the Bun toolchain and provide the following automations around its ecosystem:

- Node modules will automatically be installed if dependencies in `package.json` have changed, or
  the lockfile has changed, since the last time a task has ran.
  - We'll also take `package.json` workspaces into account and install modules in the correct
    location; either the workspace root, in a project, or both.
- Relationships between projects will automatically be discovered based on `dependencies`,
  `devDependencies`, and `peerDependencies` in `package.json`.

### Utilizing the toolchain

When a language is enabled, moon by default will assume that the language's binary is available
within the current environment (typically on `PATH`). This has the downside of requiring all
developers and machines to manually install the correct version of the language, _and to stay in
sync_.

Instead, you can utilize [moon's toolchain](../../concepts/toolchain), which will download and
install the language in the background, and ensure every task is executed using the exact version
across all machines.

Enabling the toolchain is as simple as defining the [`bun.version`](../../config/toolchain#version)
setting.

```yaml title=".moon/toolchain.yml"
# Enable Bun toolchain with an explicit version
bun:
  version: '1.0.0'
```

> Versions can also be defined with [`.prototools`](../../proto/config).

### Configuring the toolchain

Since the JavaScript ecosystem supports multiple runtimes, moon is unable to automatically detect
the correct runtime for all scenarios. Does the existence of a `package.json` mean Node.js or Bun?
We don't know, and default to Node.js because of its popularity.

To work around this, you can set `toolchain` to "bun" at the task-level or project-level.

```yaml title="moon.yml"
# For all tasks in the project
toolchain:
  default: 'bun'

tasks:
  build:
    command: 'webpack'
    # For this specific task
    toolchain: 'bun'
```

> The task-level `toolchain.default` only needs to be set if executing a `node_modules` binary! The
> `bun` binary automatically sets the toolchain to Bun.

### Using `package.json` scripts

If you're looking to prototype moon, or reduce the migration effort to moon tasks, you can configure
moon to inherit `package.json` scripts, and internally convert them to moon tasks. This can be
achieved with the [`bun.inferTasksFromScripts`](../../config/toolchain#infertasksfromscripts)
setting.

```yaml title=".moon/toolchain.yml"
bun:
  inferTasksFromScripts: true
```

Or you can run scripts through `bun run` calls.

```yaml title="moon.yml"
tasks:
  build:
    command: 'bun run build'
```

## Handbook

:::info

Refer to the [Node.js handbook](./node-handbook) for more information on repository structure,
dependency management, and more. Since both runtimes are extremely similar, the information in that
handbook also applies to Bun!

:::

---

## Deno handbook

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Utilizing Deno in a TypeScript based monorepo can be a non-trivial task. With this handbook, we'll
help guide you through this process.

:::info

This guide is a living document and will continue to be updated over time!

:::

## moon setup

For this part of the handbook, we'll be focusing on [moon](/moon), our task runner. To start,
languages in moon act like plugins, where their functionality and support _is not_ enabled unless
explicitly configured. We follow this approach to avoid unnecessary overhead.

### Enabling the language

To enable TypeScript support via Deno, define the [`deno`](../../config/toolchain#deno) setting in
[`.moon/toolchain.yml`](../../config/toolchain), even if an empty object.

```yaml title=".moon/toolchain.yml"
# Enable Deno
deno: {}

# Enable Deno and override default settings
deno:
  lockfile: true
```

Or by pinning a `deno` version in [`.prototools`](../../proto/config) in the workspace root.

```toml title=".prototools"
deno = "1.31.0"
```

This will enable the Deno toolchain and provide the following automations around its ecosystem:

- Automatic handling and caching of lockfiles (when the setting is enabled).
- Relationships between projects will automatically be discovered based on `imports`, `importMap`,
  and `deps.ts` (currently experimental).
- And more to come!

### Work in progress

:::caution

Deno support is currently experimental while we finalize the implementation.

:::

The following features are not supported:

- `deno.jsonc` files (use `deno.json` instead).
- `files.exclude` are currently considered an input. These will be filtered in a future release.

## Coming soon!

The handbook is currently being written while we finalize our Deno integration support!

---

## Node.js handbook

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Utilizing JavaScript (and TypeScript) in a monorepo can be a daunting task, especially when using
Node.js, as there are many ways to structure your code and to configure your tools. With this
handbook, we'll help guide you through this process.

:::info

This guide is a living document and will continue to be updated over time!

:::

## moon setup

For this part of the handbook, we'll be focusing on [moon](/moon), our task runner. To start,
languages in moon act like plugins, where their functionality and support _is not_ enabled unless
explicitly configured. We follow this approach to avoid unnecessary overhead.

### Enabling the language

To enable JavaScript support via Node.js, define the [`node`](../../config/toolchain#node) setting
in [`.moon/toolchain.yml`](../../config/toolchain), even if an empty object.

```yaml title=".moon/toolchain.yml"
# Enable Node.js
node: {}

# Enable Node.js and override default settings
node:
  packageManager: 'pnpm'
```

Or by pinning a `node` version in [`.prototools`](../../proto/config) in the workspace root.

```toml title=".prototools"
node = "18.0.0"
pnpm = "7.29.0"
```

This will enable the Node.js toolchain and provide the following automations around its ecosystem:

- Node modules will automatically be installed if dependencies in `package.json` have changed, or
  the lockfile has changed, since the last time a task has ran.
  - We'll also take `package.json` workspaces into account and install modules in the correct
    location; either the workspace root, in a project, or both.
- Relationships between projects will automatically be discovered based on `dependencies`,
  `devDependencies`, and `peerDependencies` in `package.json`.
  - The versions of these packages will also be automatically synced when changed.
- Tasks can be [automatically inferred](../../config/toolchain#infertasksfromscripts) from
  `package.json` scripts.
- And much more!

### Utilizing the toolchain

When a language is enabled, moon by default will assume that the language's binary is available
within the current environment (typically on `PATH`). This has the downside of requiring all
developers and machines to manually install the correct version of the language, _and to stay in
sync_.

Instead, you can utilize [moon's toolchain](../../concepts/toolchain), which will download and
install the language in the background, and ensure every task is executed using the exact version
across all machines.

Enabling the toolchain is as simple as defining the [`node.version`](../../config/toolchain#version)
setting.

```yaml title=".moon/toolchain.yml"
# Enable Node.js toolchain with an explicit version
node:
  version: '18.0.0'
```

> Versions can also be defined with [`.prototools`](../../proto/config).

### Using `package.json` scripts

If you're looking to prototype moon, or reduce the migration effort to moon tasks, you can configure
moon to inherit `package.json` scripts, and internally convert them to moon tasks. This can be
achieved with the [`node.inferTasksFromScripts`](../../config/toolchain#infertasksfromscripts)
setting.

```yaml title=".moon/toolchain.yml"
node:
  inferTasksFromScripts: true
```

Or you can run scripts through `npm run` (or `pnpm`, `yarn`) calls.

```yaml title="moon.yml"
tasks:
  build:
    command: 'npm run build'
```

## Repository structure

JavaScript monorepo's work best when projects are split into applications and packages, with each
project containing its own `package.json` and dependencies. A root `package.json` must also exist
that pieces all projects together through workspaces.

For small repositories, the following structure typically works well:

```
/
├── .moon/
├── package.json
├── apps/
│   ├── client/
|   |   ├── ...
│   |   └── package.json
│   └── server/
|       ├── ...
│       └── package.json
└── packages/
    ├── components/
    |   ├── ...
    │   └── package.json
    ├── theme/
    |   ├── ...
    │   └── package.json
    └── utils/
        ├── ...
        └── package.json
```

For large repositories, grouping projects by team or department helps with ownership and
organization. With this structure, applications and libraries can be nested at any depth.

```
/
├── .moon/
├── package.json
├── infra/
│   └── ...
├── internal/
│   └── ...
├── payments/
│   └── ...
└── shared/
    └── ...
```

### Applications

Applications are runnable or executable, like an HTTP server, and are pieced together with packages
and its own encapsulated code. They represent the whole, while packages are the pieces. Applications
can import and depend on packages, but they _must not_ import and depend on other applications.

In moon, you can denote a project as an application using the [`layer`](../../config/project#layer)
setting in [`moon.yml`](../../config/project).

```yaml title="moon.yml"
layer: 'application'
```

### Packages

Packages (also known as a libraries) are self-contained reusable pieces of code, and are the
suggested pattern for [code sharing](#code-sharing). Packages can import and depend on other
packages, but they _must not_ import and depend on applications!

In moon, you can denote a project as a library using the [`layer`](../../config/project#layer)
setting in [`moon.yml`](../../config/project).

```yaml title="moon.yml"
layer: 'library'
```

### Configuration

Every tool that you'll utilize in a repository will have its own configuration file. This will be a
lot of config files, but regardless of what tool it is, where the config file should go will fall
into 1 of these categories:

- **Settings are inherited by all projects.** These are known as universal tools, and enforce code
  consistency and quality across the entire repository. Their config file must exist in the
  repository root, but may support overrides in each project.
  - Examples: Babel, [ESLint](../examples/eslint), [Prettier](../examples/prettier),
    [TypeScript](../examples/typescript)
- **Settings are unique per project.** These are developers tools that must be configured separately
  for each project, as they'll have different concerns. Their config file must exist in each
  project, but a shared configuration may exist as a base (for example, Jest presets).
  - Examples: [Jest](../examples/jest), [TypeScript](../examples/typescript) (with project
    references)
- **Settings are one-offs.** These are typically for applications or tools that require their own
  config, but aren't prevalent throughout the entire repository.
  - Examples: [Astro](../examples/astro), [Next](../examples/next), [Nuxt](../examples/nuxt),
    [Remix](../examples/remix), Tailwind

## Dependency management

Dependencies, also known as node modules, are required by all projects, and are installed through a
package manager like npm, pnpm, or yarn. It doesn't matter which package manager you choose, but we
highly suggest choosing one that has proper workspaces support. If you're unfamiliar with
workspaces, they will:

- Resolve all `package.json`'s in a repository using glob patterns.
- Install dependencies from all `package.json`'s at once, in the required locations.
- Create symlinks of local packages in `node_modules` (to emulate an installed package).
- Deduplicate and hoist `node_modules` when applicable.

All of this functionality enables robust monorepo support, and can be enabled with the following:

import PackageWorkspaces from '../../__partials__/node/package-workspaces.mdx';

:::caution

Package workspaces are not a requirement for monorepos, but they do solve an array of problems
around module resolution, avoiding duplicate packages in bundles, and general interoperability.
Proceed with caution for non-workspaces setups!

:::

### Workspace commands

The following common commands can be used for adding, removing, or managing dependencies in a
workspace. View the package manager's official documentation for a thorough list of commands.

import WsCommands from './__partials__/workspace-commands.mdx';

### Developer tools at the root

While not a strict guideline to follow, we've found that installing universal developer tool related
dependencies (Babel, ESLint, Jest, TypeScript, etc) in the root `package.json` as `devDependencies`
to be a good pattern for consistency, quality, and the health of the repository. It provides the
following benefits:

- It ensures all projects are utilizing the same version (and sometimes configuration) of a tool.
- It allows the tool to easily be upgraded. Upgrade once, applied everywhere.
- It avoids conflicting or outdated versions of the same package.

With that being said, this _does not_ include development dependencies that are unique to a project!

### Product libraries in a project

Product, application, and or framework specific packages should be installed as production
`dependencies` in a project's `package.json`. We've found this pattern to work well for the
following reasons:

- Application dependencies are pinned per project, avoiding accidental regressions.
- Applications can upgrade their dependencies and avoid breaking neighbor applications.

## Code sharing

One of the primary reasons to use a monorepo is to easily share code between projects. When code is
co-located within the same repository, it avoids the overhead of the "build -> version -> publish to
registry -> upgrade in consumer" workflow (when the code is located in an external repository).

Co-locating code also provides the benefit of fast iteration, fast adoption, and easier migration
(when making breaking changes for example).

With [package workspaces](#dependency-management), code sharing is a breeze. As mentioned above,
every project that contains a `package.json` that is part of the workspace, will be symlinked into
`node_modules`. Because of this, these packages can easily be imported using their `package.json`
name.

```ts
// Imports from /packages/utils/package.json
import utils from '@company/utils';
```

### Depending on packages

Because packages are symlinked into `node_modules`, we can depend on them as if they were normal npm
packages, but with 1 key difference. Since these packages aren't published, they do not have a
version to reference, and instead, we can use the special `workspace:^` version (yarn and pnpm only,
use `*` for npm).

```json
{
  "name": "@company/consumer",
  "dependencies": {
    "@company/provider": "workspace:^"
  }
}
```

The `workspace:` version basically means "use the package found in the current workspace". The `:^`
determines the version range to _substitute with when publishing_. For example, the `workspace:^`
above would be replaced with version of `@company/provider` as `^` when the
`@company/consumer` package is published.

There's also `workspace:~` and `workspace:*` which substitutes to `~` and ``
respectively. We suggest using `:^` so that version ranges can be deduped.

### Types of packages

When sharing packages in a monorepo, there's typically 3 different kinds of packages:

#### Local only

A local only package is just that, it's only available locally to the repository and _is not_
published to a registry, and _is not_ available to external repositories. For teams and companies
that utilize a single repository, this will be the most common type of package.

A benefit of local packages is that they do not require a build step, as source files can be
imported directly ([when configured correctly](#bundler-integration)). This avoids a lot of
`package.json` overhead, especially in regards to `exports`, `imports`, and other import patterns.

#### Internally published

An internal package is published to a private registry, and _is not_ available to the public.
Published packages are far more strict than local packages, as the `package.json` structure plays a
much larger role for downstream consumers, as it dictates how files are imported, where they can be
found, what type of formats are supported (CJS, ESM), so on and so forth.

Published packages require a build step, for both source code and TypeScript types (when
applicable). We suggest using [esbuild](https://esbuild.github.io/) or
[Packemon](../examples/packemon) to handle this entire flow. With that being said, local projects
can still [import their source files](#bundler-integration).

#### Externally published

An external package is structured similarly to an internal package, but instead of publishing to a
private registry, it's published to the npm public registry.

External packages are primarily for open source projects, and require the repository to also be
public.

### Bundler integration

Co-locating packages is great, but how do you import and use them effectively? The easiest solution
is to configure resolver aliases within your bundler (Webpack, Vite, etc). By doing so, you enable
the following functionality:

- Avoids having to build (and rebuild) the package everytime its code changes.
- Enables file system watching of the package, not just the application.
- Allows for hot module reloading (HMR) to work.
- Package code is transpiled and bundled alongside application code.

```ts title="vite.config.ts"
import path from 'path';
import { defineConfig } from 'vite';

export default defineConfig({
  // ...
  resolve: {
    alias: {
      '@company/utils': path.join(__dirname, '../packages/utils/src'),
    },
  },
});
```

```ts title="webpack.config.js"
const path = require('path');

module.exports = {
  // ...
  resolve: {
    alias: {
      '@company/utils': path.join(__dirname, '../packages/utils/src'),
    },
  },
};
```

:::info

When configuring aliases, we suggest using the `package.json` name as the alias! This ensures that
on the consuming side, you're using the package as if it's a normal node module, and avoids
deviating from the ecosystem.

:::

### TypeScript integration

We suggest using TypeScript project references. Luckily, we have an
[in-depth guide on how to properly and efficiently integrate them](./typescript-project-refs)!

---

## Typescript Eslint

## ESLint integration

### Disabling problematic rules

A handful of ESLint rules are not compatible with the TypeScript plugin, or they cause serious
performance degradation, and should be disabled entirely. According to the
[official typescript-eslint.io documentation](https://typescript-eslint.io/docs/linting/troubleshooting#eslint-plugin-import),
most of these rules come from the `eslint-plugin-import` plugin.

```js title=".eslintrc.js"
module.exports = {
  // ...
  rules: {
    'import/default': 'off',
    'import/named': 'off',
    'import/namespace': 'off',
    'import/no-cycle': 'off',
    'import/no-deprecated': 'off',
    'import/no-named-as-default': 'off',
    'import/no-named-as-default-member': 'off',
    'import/no-unused-modules': 'off',
  },
};
```

### Running from the command line

### Running within editors

#### ESLint

Use the
[dbaeumer.vscode-eslint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
extension. Too avoid poor performance, _do not_ use ESLint for formatting code (via the
`eslint-plugin-prettier` plugin or something similar), and _only_ use it for linting. The difference
in speed is comparable to 100ms vs 2000ms.

```json title=".vscode/settings.json"
{
  // Automatically run all linting fixes on save as a concurrent code action,
  // and avoid formatting with ESLint. Use another formatter, like Prettier.
  "editor.codeActionsOnSave": ["source.fixAll.eslint"],
  "eslint.format.enable": false,

  // If linting is *too slow* while typing, uncomment the following line to
  // only run the linter on save only.
  // "editor.run": "onSave",

  // Your package manager of choice.
  "eslint.packageManager": "yarn",

  // Use the newer and more performant `ESLint` class implementation.
  "eslint.useESLintClass": true,

  // List of directories that that linter should operate on.
  "eslint.workingDirectories": [{ "pattern": "apps/*" }, { "pattern": "packages/*" }]
}
```

#### Prettier

Use the
[esbenp.prettier-vscode](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)
extension.

```json title=".vscode/settings.json"
{
  // Use Prettier as the default formatter for all file types. Types not
  // supported by Prettier can be overridden using bracket syntax, or ignore files.
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true
}
```

---

## TypeScript project references

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Image from '@site/src/components/Image';

> The ultimate in-depth guide for using TypeScript in a monorepo effectively!

How to use TypeScript in a monorepo? What are project references? Why use project references? What
is the best way to use project references? These are just a handful of questions that are
_constantly_ asked on Twitter, forums, Stack Overflow, and even your workplace.

Based on years of experience managing large-scale frontend repositories, we firmly believe that
TypeScript project references are the proper solution for effectively scaling TypeScript in a
monorepo. The official
[TypeScript documentation on project references](https://www.typescriptlang.org/docs/handbook/project-references.html)
answers many of these questions, but it basically boils down to the following:

- Project references _enforce project boundaries, disallowing imports_ to arbitrary projects unless
  they have been referenced explicitly in configuration. This avoids circular references / cycles.
- It enables TypeScript to _process individual units_, instead of the entire repository as a whole.
  Perfect for reducing CI and local development times.
- It supports _incremental compilation_, so only out-of-date or affected projects are processed. The
  more TypeScript's cache is warmed, the faster it will be.
- It simulates how types work in the Node.js package ecosystem.

This all sounds amazing but there's got to be some downsides right? Unfortunately, there is:

- Project references require generating declarations to resolve type information correctly. This
  results in a lot of compilation artifacts littered throughout the repository. There
  [are ways](#gitignore) [around this](../../config/toolchain#routeoutdirtocache).
- This approach is a bit involved and may require some cognitive overhead based on your current
  level of TypeScript tooling knowledge.

:::success

If you'd like a real-world repository to reference, our
[moonrepo/moon](https://github.com/moonrepo/moon), [moonrepo/dev](https://github.com/moonrepo/dev),
and [moonrepo/examples](https://github.com/moonrepo/examples) repositories utilizes this
architecture!

:::

## Preface

Before you dive into this questionably long guide, we'd like to preface with:

- This guide is a living document and will continually be updated with best practices and frequently
  asked questions. Keep returning to learn more!
- This guide assumes a basic level knowledge of TypeScript and how it works.
- The architecture outlined in this guide assumes that TypeScript is _only_ used for typechecking
  and _not_ compiling. However, supporting compilation should be as easy as modifying a handful of
  compiler options.
- Although this guide exists within moon's documentation, it _does not_ require moon. We've kept all
  implementation details generic enough for it be used in any repository, but have also included
  many notes on how moon would improve this experience.

## Configuration

The most complicated part of integrating TypeScript in a monorepo is a proper configuration setup.
Based on our extensive experience, we suggest the following architecture as a base! This _is not_
perfect and can most definitely be expanded upon or modified to fit your needs.

### Root-level

In a polyrepo, the root `tsconfig.json` is typically the only configuration file, as it defines
common compiler options, and includes files to typecheck. In a monorepo, these responsibilities are
now split across multiple configuration files.

#### `tsconfig.json`

To start, the root `tsconfig.json` file is nothing more than a list of _all_ projects in the
monorepo, with each project being an individual entry in the `references` field. Each entry must
contain a `path` field with a relative file system path to the project root (that contains their
config).

We also _do not_ define compiler options in this file, as project-level configuration files would
_not_ be able to extend this file, as it would trigger a circular reference. Instead, we define
common compiler options in a root [`tsconfig.options.json`](#tsconfigoptionsjson) file, that this
file also `extends` from.

In the end, this file should only contain 3 fields: `extends`, `files` (an empty list), and
`references`. This abides the
[official guidance around structure](https://www.typescriptlang.org/docs/handbook/project-references.html#overall-structure).

```json file="tsconfig.json"
{
  "extends": "./tsconfig.options.json",
  "files": [],
  "references": [
    {
      "path": "apps/foo"
    },
    {
      "path": "packages/bar"
    }
    // ... more
  ]
}
```

> When using moon, the
> [`typescript.syncProjectReferences`](../../config/toolchain#syncprojectreferences) setting will
> keep this `references` list automatically in sync, and the name of the file can be customized with
> [`typescript.rootConfigFileName`](../../config/toolchain#rootconfigfilename).

#### `tsconfig.options.json`

This file will contain common compiler options that will be inherited by _all_ projects in the
monorepo. For project references to work correctly, the following settings _must_ be enabled at the
root, and typically should not be disabled in each project.

- `composite` - Enables project references and informs the TypeScript program where to find
  referenced outputs.
- `declaration` - Project references rely on the compiled declarations (`.d.ts`) of external
  projects. If declarations do not exist, TypeScript will generate them on demand.
- `declarationMap` - Generate sourcemaps for declarations, so that language server integrations in
  editors like "Go to" resolve correctly.
- `incremental` - Enables incremental compilation, greatly improving performance.
- `noEmitOnError` - If the typechecker fails, avoid generating invalid or partial declarations.
- `skipLibCheck` - Avoids eager loading and analyzing all declarations, greatly improving
  performance.

Furthermore, we have 2 settings that should be enabled _per project_, depending on the project type.

- `emitDeclarationOnly` - For packages: Emit declarations, as they're required for references, but
  avoid compiling to JavaScript.
- `noEmit` - For applications: Don't emit declarations, as others _should not_ be depending on the
  project.

For convenience, we provide the
[`tsconfig-moon`](https://github.com/moonrepo/dev/tree/master/packages/tsconfig) package, which
defines common compiler options and may be used here.

```json file="tsconfig.options.json"
{
  "compilerOptions": {
    "composite": true,
    "declaration": true,
    "declarationMap": true,
    "emitDeclarationOnly": true,
    "incremental": true,
    "noEmitOnError": true,
    "skipLibCheck": true
    // ... others
  }
}
```

> When using moon, the name of the file can be customized with
> [`typescript.rootOptionsConfigFileName`](../../config/toolchain#rootoptionsconfigfilename).

##### ECMAScript interoperability

ECMAScript modules (ESM) have been around for quite a while now, but the default TypeScript settings
are not configured for them. We suggest the following compiler options if you want proper ESM
support with interoperability with the ecosystem.

```json file="tsconfig.options.json"
{
  "compilerOptions": {
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "strict": true,
    "target": "esnext"
    // ... others
  }
}
```

#### `.gitignore`

Project references unfortunately generate _a ton_ of artifacts that typically shouldn't be committed
to the repository (but could be if you so choose). We suggest ignoring the following:

```shell title=".gitignore"
# The `outDir` for declarations
lib/
# Build cache manifests
*.tsbuildinfo
```

### Project-level

Each project that contains TypeScript files and will utilize the typechecker _must_ contain a
`tsconfig.json` in the project root, typically as a sibling to `package.json`.

#### `tsconfig.json`

A `tsconfig.json` in the root of a project (application or package) is required, as it informs
TypeScript that this is a project, and that it can be referenced by other projects. In its simplest
form, this file should extend the root [`tsconfig.options.json`](#tsconfigoptionsjson) to inherit
common compiler options, define its own compiler options (below), define includes/excludes, and any
necessary references.

> When using moon, the name of the file can be customized with
> [`typescript.projectConfigFileName`](../../config/toolchain#projectconfigfilename).

For applications, declaration emitting can be disabled, since external projects _should not_ be
importing files from an application. If this use case ever arises, move those files into a package.

```json title="apps/foo/tsconfig.json"
{
  "extends": "../../../../tsconfig.options.json",
  "compilerOptions": {
    "noEmit": true
  },
  "include": [],
  "references": []
}
```

For packages, we must define the location in which to generate declarations. These are the
declarations that external projects would reference. This location is typically
[gitignored](#gitignore)!

```json title="packages/bar/tsconfig.json"
{
  "extends": "../../../../tsconfig.options.json",
  "compilerOptions": {
    "emitDeclarationOnly": true,
    "outDir": "./lib"
  },
  "include": [],
  "references": []
}
```

> When using moon, the `outDir` can automatically be re-routed to a shared cache using
> [`typescript.routeOutDirToCache`](../../config/toolchain#routeoutdirtocache), to avoid littering
> the repository with compilation artifacts.

##### Includes and excludes

Based on experience, we suggest defining `include` instead of `exclude`, as managing a whitelist of
typecheckable files is much easier. When dealing with excludes, there are far too many
possibilities. To start, you have `node_modules`, and for applications maybe `dist`, `build`,
`.next`, or another application specific folder, and then for packages you may have `lib`, `cjs`,
`esm`, etc. It becomes very... tedious.

The other benefit of using `include` is that it forces TypeScript to only load _what's necessary_,
instead of eager loading everything into memory, and for typechecking files that aren't part of
source, like configuration.

```json title="/tsconfig.json"
{
  // ...
  "include": ["src/**/*", "tests/**/*", "*.js", "*.ts"]
}
```

##### Depending on other projects

When a project depends on another project (by importing code from it), either using relative paths,
[path aliases](#using-paths-aliases), or its `package.json` name, it must be declared as a
reference. If not declared, TypeScript will error with a message about importing outside the project
boundary.

```json title="/tsconfig.json"
{
  // ...
  "references": [
    {
      "path": "../../foo"
    },
    {
      "path": "../../bar"
    },
    {
      "path": "../../../../baz"
    }
  ]
}
```

To make use of editor intellisense and auto-imports of deeply nested files, you'll most likely need
to add includes for referenced projects as well.

```json title="/tsconfig.json"
{
  // ...
  "include": [
    // ...
    "src/**/*",
    "../../foo/src/**/*",
    "../../bar/src/**/*",
    "../../../../baz/src/**/*"
  ]
}
```

> When using moon, the
> [`typescript.syncProjectReferences`](../../config/toolchain#syncprojectreferences) setting will
> keep this `references` list automatically in sync, and
> [`typescript.includeProjectReferenceSources`](../../config/toolchain#syncprojectreferences) for
> `include`.

#### `tsconfig.*.json`

Additional configurations may exist in a project that serve a role outside of typechecking, with one
such role being _npm package publishing_. These configs are sometimes named `tsconfig.build.json`,
`tsconfig.types.json`, or `tsconfig.lib.json`. Regardless of what they're called, these configs are
_optional_, so unless you have a business need for them, you may skip this section.

##### Package publishing

As mentioned previously, these configs may be used for npm packages, primarily for generating
TypeScript declarations that are mapped through the `package.json`
[`types` (or `typings`) field](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html).

Given this `package.json`...

```json title="/package.json"
{
  // ...
  "types": "./lib/index.d.ts"
}
```

Our `tsconfig.build.json` may look like...

```json title="/tsconfig.build.json"
{
  "extends": "../../../../tsconfig.options.json",
  "compilerOptions": {
    "outDir": "lib",
    "rootDir": "src"
  },
  "include": ["src/**/*"]
}
```

Simple right? But why do we need an additional configuration? Why not use the other `tsconfig.json`?
Great questions! The major reason is that we _only want to publish declarations for source files_,
and the declarations file structure should match 1:1 with the sources structure. The `tsconfig.json`
_does not_ guarantee this, as it may include test, config, or arbitrary files, all of which may not
exist in the sources directory (`src`), and will alter the output to an incorrect directory
structure. Our `tsconfig.build.json` solves this problem by only including source files, and by
forcing the source root to `src` using the `rootDir` compiler option.

However, there is a giant caveat with this approach! Because TypeScript utilizes Node.js's module
resolution, it will reference the declarations defined by the `package.json` `types` or
[`exports`](#supporting-packagejson-exports) fields, instead of the `outDir` compiler option, and
the other `tsconfig.json` _does not guarantee_ these files will exist. This results in TypeScript
failing to find the appropriate types! To solve this, add the `tsconfig.build.json` as a project
reference to `tsconfig.json`.

```json title="/tsconfig.json"
{
  // ...
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
    // ... others
  ]
}
```

##### Vendor specific

Some vendors, like [Vite](../examples/vite), [Vitest](../examples/vite), and
[Astro](../examples/astro) may include additional `tsconfig.*.json` files unique to their ecosystem.
We suggest following their guidelines and implementation when applicable.

## Running the typechecker

Now that our configuration is place, we can run the typechecker, or attempt to at least! This can be
done with the `tsc --build` command, which acts as a
[build orchestrator](https://www.typescriptlang.org/docs/handbook/project-references.html#build-mode-for-typescript).
We also suggest passing `--verbose` for insights into what projects are compiling, and which are
out-of-date.

### On all projects

From the root of the repository, run `tsc --build --verbose` to typecheck _all_ projects, as defined
in [tsconfig.json](#tsconfigjson). TypeScript will generate a directed acyclic graph (DAG) and
compile projects _in order_ so that dependencies and references are resolved correctly.

:::info

Why run TypeScript in the root? Typically you would only want to run against projects, but for
situations where you need to verify that all projects still work, running in the root is the best
approach. Some such situations are upgrading TypeScript itself, upgrading global `@types` packages,
updating shared types, reworking build processes, and more.

:::

### On an individual project

To only typecheck a single project (and its dependencies), there are 2 approaches. The first is to
run from the root, and pass a relative path to the project, such as
`tsc --build --verbose packages/foo`. The second is to change the working directory to the project,
and run from there, such as `cd packages/foo && tsc --build --verbose`.

Both approaches are viable, and either may be used based on your tooling, build system, task runner,
so on and so forth. This is the approach moon suggests with its
[`typecheck` task](../examples/typescript).

### On affected projects

In CI environments, it's nice to _only run_ the typechecker on affected projects — projects that
have changed files. While this isn't entirely possible with `tsc`, it is possible with moon! Head
over to the
[official docs for more information](../../run-task#running-based-on-affected-files-only).

## Using `paths` aliases

Path aliases, also known as path mapping or magic imports, is the concept of defining an import
alias that re-maps its underlying location on the file system. In TypeScript, this is achieved with
the
[`paths` compiler option](https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping).

In a monorepo world, we suggest using path aliases on a per-project basis, instead of defining them
"globally" in the root. This gives projects full control of what's available and what they want to
import, and also plays nice with the mandatory `baseUrl` compiler option.

```json title="/tsconfig.json"
{
  // ...
  "compilerOptions": {
    // ...
    "baseUrl": ".",
    "paths": {
      // Within the project
      ":components/*": ["./src/components/*"],
      // To a referenced project
      ":shared/*": ["../../shared/code/*"]
    }
  },
  "references": [
    {
      "path": "../../shared/code"
    }
  ]
}
```

The above aliases would be imported like the following:

```ts
// Before
import { Button } from '../../../../components/Button';
import utils from '../../shared/code/utils';

// After
import { Button } from ':components/Button';
import utils from ':shared/utils';
```

:::info

When using path aliases, we suggest prefixing or suffixing the alias with `:` so that it's apparent
that it's an alias (this also matches the new `node:` import syntax). Using no special character or
`@` is problematic as it risks a chance of collision with a public npm package and may accidentally
open your repository to a
[supply chain attack](https://snyk.io/blog/npm-security-preventing-supply-chain-attacks/). Other
characters like `~` and `$` have an existing meaning in the ecosystem, so it's best to avoid them
aswell.

:::

### Importing source files from local packages

If you are importing from a project reference using a `package.json` name, then TypeScript will
abide by Node.js module resolution logic, and will import using the
[`main`/`types` or `exports` entry points](https://nodejs.org/api/packages.html#package-entry-points).
This means that you're importing _compiled code_ instead of source code, and will require the
package to be constantly rebuilt if changes are made to it.

However, why not simply import source files instead? With path aliases, you can do just that, by
defining a `paths` alias that maps the `package.json` name to its source files, like so.

```json title="/tsconfig.json"
{
  // ...
  "compilerOptions": {
    // ...
    "paths": {
      // Index import
      "@scope/name": ["../../shared/package/src/index.ts"],
      // Deep imports
      "@scope/name/*": ["../../shared/package/src/*"]
    }
  },
  "references": [
    {
      "path": "../../shared/package"
    }
  ]
}
```

> When using moon, the
> [`typescript.syncProjectReferencesToPaths`](../../config/toolchain#syncprojectreferencestopaths)
> setting will automatically create `paths` based on the local references.

## Sharing and augmenting types

Declaring global types, augmenting node modules, and sharing reusable types is a common practice.
There are many ways to achieve this, so choose what works best for your repository. We use the
following pattern with great success.

At the root of the repository, create a `types` folder as a sibling to `tsconfig.json`. This folder
_must only_ contain declarations (`.d.ts`) files for the following reasons:

- Declarations can be `include`ed in a project without having to be a project reference.
- Hard-coded declarations _do not_ need to be compiled from TypeScript files.

Based on the above, update your project's `tsconfig.json` to include all of these types, or just
some of these types.

```json title="/tsconfig.json"
{
  // ...
  "include": ["src/**/*", "../../../../types/**/*"]
}
```

> In the future, moon will provide a setting to automate this workflow!

## Supporting `package.json` exports

In Node.js v12, they introduced a new field to `package.json` called `exports` that aims to solve
the shortcomings of the `main` field. The `exports` field is very complicated, and instead of
repeating all of its implementation details, we suggest reading
[the official Node.js docs on this topic](https://nodejs.org/api/packages.html#package-entry-points).

With that being said, TypeScript completely ignored the `exports` field until
[v4.7](https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/#esm-nodejs), and
respecting `exports` is _still ignored unless_ the `moduleResolution` compiler option is set to
"nodenext", "node16", or "bundler". If `moduleResolution` is set to "node", then your integration is
resolving based on the `main` and `types` field, which are basically "legacy".

:::warning

Enabling `package.json` imports/exports resolution is very complicated, and may be very tedious,
especially considering the state of the npm ecosystem. Proceed with caution!

:::

### State of the npm ecosystem

As mentioned above, the npm ecosystem (as of November 2022) is in a very fragile state in regards to
imports/exports. Based on our experience attempting to utilize them in a monorepo, we ran into an
array of problems, some of which are:

- Published packages are simply utilizing imports/exports incorrectly. The semantics around CJS/ESM
  are very strict, and they may be configured wrong. This is exacerbated by the new `type` field.
- The `exports` field _overrides_ the `main` and `types` fields. If `exports` exists without type
  conditions, but the `types` field exists, the `types` entry point is completely ignored, resulting
  in TypeScript failures.

With that being said, there are [ways around this](#resolving-issues) and moving forward is
possible, if you dare!

### Enabling imports/exports resolution

To start, set the `moduleResolution` compiler option to "nodenext" (for packages) or "bundler" (for
apps) in the [`tsconfig.options.json`](#tsconfigoptionsjson) file.

```json file="tsconfig.options.json"
{
  "compilerOptions": {
    // ...
    "moduleResolution": "nodenext"
  }
}
```

Next, [run the typechecker from the root](#on-all-projects) against all projects. This will help
uncover all potential issues with the dependencies you're using or the current configuration
architecture. If no errors are found, well _congratulations_, otherwise jump to the next section for
more information on [resolving them](#resolving-issues).

If you're trying to use `exports` in your own packages, ensure that the `types` condition is set,
and it's the first condition in the mapping! We also suggest including `main` and the top-level
`types` for tooling that do not support `exports` yet.

```json title="package.json"
{
  // ...
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
    ".": {
      "types": "./lib/index.d.ts",
      "node": "./lib/index.js"
    }
  }
}
```

:::info

Managing `exports` is non-trivial. If you'd prefer them to be automatically generated based on a set
of inputs, we suggest using [Packemon](https://packemon.dev/)!

:::

### Resolving issues

There's only one way to resolve issues around incorrectly published `exports`, and that is package
patching, either with [Yarn's patching feature](https://yarnpkg.com/features/protocols/#patch),
[pnpm's patching feature](https://pnpm.io/cli/patch), or the
[`patch-package` package](https://www.npmjs.com/package/patch-package). With patching, you can:

- Inject the `types` condition/field if it's missing.
- Re-structure the `exports` mapping if it's incorrect.
- Fix incorrect entry point paths.
- And even fix invalid TypeScript declarations or JavaScript code!

```diff title="package.json"
{
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    "./package.json": "./package.json",
-    ".": "./lib/index.js"
+    ".": {
+      "types": "./lib/index.d.ts",
+      "node": "./lib/index.js"
+    }
  }
}
```

:::info

More often than not, the owners of these packages may be unaware that their `exports` mapping is
incorrect. Why not be a good member of the community and report an issue or even submit a pull
request?

:::

## Editor integration

Unfortunately, we only have experience with VS Code. If you prefer another editor and have guidance
you'd like to share with the community, feel free to submit a pull request and we'll include it
below!

### VS Code

[VS Code](https://code.visualstudio.com/) has first-class support for TypeScript and project
references, and should "just work" without any configuration. You can verify this by restarting the
TypeScript server in VS Code (with the cmd + shift + p command palette) and navigating to
each project. Pay attention to the status bar at the bottom, as you'll see this:

When this status appears, it means that VS Code is _compiling a project_. It will re-appear multiple
times, basically for each project, instead of once for the entire repository.

Furthermore, ensure that VS Code is using the version of TypeScript from the `typescript` package in
`node_modules`. Relying on the version that ships with VS Code may result in unexpected TypeScript
failures.

```json title=".vscode/settings.json"
{
  "typescript.tsdk": "node_modules/typescript/lib"
  // Or "Select TypeScript version" from the command palette
}
```

## FAQ

### I still have questions, where can I ask them?

We'd love to answer your questions and help anyway that we can. Feel free to...

- Join the [moonrepo discord](https://discord.gg/qCh9MEynv2) and post your question in the
  `#typescript` channel.
- Ping me, [Miles Johnson](https://twitter.com/mileswjohnson), on Twitter. I'll try my best to
  respond to every tweet.

### Do I have to use project references?

Short answer, no. If you have less than say 10 projects, references may be overkill. If your
repository is primarily an application, but then has a handful of shared npm packages, references
may also be unnecessary here. In the end, it really depends on how many projects exist in the
monorepo, and what your team/company is comfortable with.

However, we do suggest using project references for very large monorepos (think 100s of projects),
or repositories with a large number of contributors, or if you merely want to reduce CI typechecking
times.

### What about not using project references and only using source files?

A popular alternative to project references is to simply use the source files as-is, by updating the
`main` and `types` entry fields within each `package.json` to point to the original TypeScript
files. This approach is also known as "internal packages".

```json title="package.json"
{
  // ...
  "main": "./src/index.tsx",
  "types": "./src/index.tsx"
}
```

While this _works_, there are some downsides to this approach.

- Loading declaration files are much faster than source files.
- You'll lose all the benefits of TypeScript's incremental caching and compilation. TypeScript will
  consistently load, parse, and evaluate these source files every time. This is especially true for
  CI environments.
- When using `package.json` workspaces, bundlers and other tools may consider these source files
  "external" as they're found in `node_modules`. This will require custom configuration to allow it.
- It breaks consistency. Consistency with the npm ecosystem, and consistency with how packaging and
  TypeScript was designed to work. If all packages are internal, then great, but if you have some
  packages that are published, you now have 2 distinct patterns for "using packages" instead of 1.

With that being said, theres a 3rd alternative that may be the best of both worlds, using project
references _and_ source files,
[by using `paths` aliases](#importing-source-files-from-local-packages).

All in all, this is a viable approach if you're comfortable with the downsides listed above. Use the
pattern that works best for your repository, team, or company!

### How to integrate with ESLint?

We initially included ESLint integration in this guide, but it was very complex and in-depth on its
own, so we've opted to push it to another guide. Unfortunately, that guide is not yet available, so
please come back soon! We'll announce when it's ready.

### How to handle circular references?

Project references _do **not** support
[circular references](https://github.com/microsoft/TypeScript/issues/33685)_ (cycles), which is
great, as they are a _code smell_! If you find yourself arbitrarily importing code from random
sources, or between 2 projects that depend on each other, then this highlights a problem with your
architecture. Projects should be encapsulated and isolated from outside sources, unless explicitly
allowed through a dependency. Dependencies are "upstream", so having them depend on the current
project (the "downstream"), makes little to no sense.

If you're trying to adopt project references and are unfortunately hitting the circular reference
problem, don't fret, untangling is possible, although non-trivial depending on the size of your
repository. It basically boils down to creating an additional project to move coupled code to.

For example, if project A was importing from project B, and B from A, then the solution would be to
create another project, C (typically a shared npm package), and move both pieces of code into C. A
and B would then import from C, instead of from each other. We're not aware of any tools that would
automate this, or detect cycles, so you'll need to do it manually.

---

## MCP integration

import VersionLabel from '@site/src/components/Docs/VersionLabel';

[Model Context Protocol](https://modelcontextprotocol.io) (MCP) is an open standard that enables AI
models to interact with external tools and services through a unified interface. The moon CLI
contains an MCP server that you can register with your code editor to allow LLMs to use moon
directly.

## Setup

### Claude Code

To use [MCP servers in Claude Code](https://docs.anthropic.com/en/docs/claude-code/mcp), run the
following command in your terminal:

```shell
claude mcp add moon -s project -e MOON_WORKSPACE_ROOT=/absolute/path/to/your/moon/workspace -- moon mcp
```

Or create an `.mcp.json` file in your project directory.

```json
{
  "mcpServers": {
    "moon": {
      "command": "moon",
      "args": ["mcp"],
      "env": {
        "MOON_WORKSPACE_ROOT": "/absolute/path/to/your/moon/workspace"
      }
    }
  }
}
```

### Cursor

To use [MCP servers in Cursor](https://docs.cursor.com/context/model-context-protocol), create a
`.cursor/mcp.json` file in your project directory, or `~/.cursor/mcp.json` globally, with the
following content:

```json title=".cursor/mcp.json"
{
  "mcpServers": {
    "moon": {
      "command": "moon",
      "args": ["mcp"],
      "env": {
        "MOON_WORKSPACE_ROOT": "/absolute/path/to/your/moon/workspace"
      }
    }
  }
}
```

Once configured, the moon MCP server should appear in the "Available Tools" section on the MCP
settings page in Cursor.

### VS Code

To use MCP servers in VS Code, you must have the
[Copilot Chat](https://code.visualstudio.com/docs/copilot/chat/copilot-chat) extension installed.
Once installed, create a `.vscode/mcp.json` file with the following content:

```json title=".vscode/mcp.json"
{
  "servers": {
    "moon": {
      "type": "stdio",
      "command": "moon",
      "args": ["mcp"],
      // >= 1.102 (June 2025)
      "cwd": "${workspaceFolder}",
      // Older versions
      "env": {
        "MOON_WORKSPACE_ROOT": "${workspaceFolder}"
      }
    }
  }
}
```

Once your MCP server is configured, you can use it with
[GitHub Copilot’s agent mode](https://code.visualstudio.com/docs/copilot/chat/chat-agent-mode):

- Open the Copilot Chat view in VS Code
- Enable agent mode using the mode select dropdown
- Toggle on moon's MCP tools using the "Tools" button

### Zed

To use [MCP servers in Zed](https://zed.dev/docs/ai/mcp), create a `.zed/settings.json` file in your
project directory, or `~/.config/zed/settings.json` globally, with the following content:

```json title=".zed/settings.json"
{
  "context_servers": {
    "moon": {
      "command": {
        "path": "moon",
        "args": ["mcp"],
        "env": {
          "MOON_WORKSPACE_ROOT": "/absolute/path/to/your/moon/workspace"
        }
      }
    }
  }
}
```

Once your MCP server is configured, you'll need to enable the tools using the following steps:

- Open the Agent panel in Zed
- Click the Write/Ask toggle button and go to "Configure Profiles"
- Click "Customize" in the Ask section
- Click "Configure MCP Tools"
- Enable each tool under the "moon" section

## Available tools

The following tools are available in the moon MCP server and can be executed by LLMs using agent
mode.

- `get_project` - Get a project and its tasks by `id`.
- `get_projects` - Get all projects.
- `get_task` - Get a task by `target`.
- `get_tasks` - Get all tasks.
- `get_touched_files` - Gets touched files between base and head revisions.
  
- `sync_projects` - Runs the `SyncProject` action for one or many projects by `id`.
  
- `sync_workspace` - Runs the `SyncWorkspace` action. 

:::info

The
[request and response shapes](https://github.com/moonrepo/moon/blob/master/packages/types/src/mcp.ts)
for these tools are defined as TypeScript types in the
[`@moonrepo/types`](https://www.npmjs.com/package/@moonrepo/types) package.

:::

---

## Terminal notifications

import VersionLabel from '@site/src/components/Docs/VersionLabel';

moon is able to send operating system desktop notifications for specific events in the action
pipeline, on behalf of your terminal application. This is useful for continuous feedback loops and
reacting to long-running commands while multi-tasking.

Notifications are opt-in and must be enabled with the
[`notify.terminalNotifications`](/docs/config/workspace#terminalnotifications) setting.

```yaml title=".moon/workspace.yml"
notifier:
  terminalNotifications: 'always'
```

## Setup

Notifications must be enabled at the operating system level.

### Linux

Linux support is based on the [XDG specification](https://en.wikipedia.org/wiki/XDG) and utilizes
D-BUS APIs, primarily the
[`org.freedesktop.Notifications.Notify`](https://www.galago-project.org/specs/notification/0.9/x408.html#command-notify)
method. Refer to your desktop distribution for more information.

Notifications will be sent using the `moon` application name (the current executable).

### macOS

- Open "System Settings" or "System Preferences"
- Select "Notifications" in the left sidebar
- Select your terminal application from the list (e.g., "Terminal", "iTerm", etc)
- Ensure "Allow notifications" is enabled
- Customize the other settings as desired

Notifications will be sent from your currently running terminal application, derived from the
`TERM_PROGRAM` environment variable. If we fail to detect the terminal, it will default to "Finder".

### Windows

Requires Windows 10 or later.

- Open "Settings"
- Go to the "System" panel
- Select "Notifications & Actions" in the left sidebar
- Ensure notifications are enabled

Notifications will be sent from the "Windows Terminal" app if it's currently in use, otherwise from
"Microsoft PowerShell".

---

## Offline mode

moon assumes that an internet connection is always available, as we download and install tools into
the toolchain, resolve versions against upstream manifests, and automatically install dependencies.
While this is useful, having a constant internet connection isn't always viable.

To support workflows where internet isn't available or is spotty, moon will automatically check for
an active internet connection, and drop into offline mode if necessary.

## What's disabled when offline

When offline, moon will skip or disable the following:

- Automatic dependency installation will be skipped.
- Toolchain will skip resolving, downloading, and installing tools, and instead use the local cache.
  - If no local cache available, will fallback to binaries found on `PATH`.
  - If not available on `PATH`, will fail to run.
- Upgrade and version checks will be skipped.

## Toggling modes

While we automatically check for an internet connection, both online and offline modes can be forced
with the `PROTO_OFFLINE` environment variable. Setting the variable to `1` or `true` will force
offline mode, while `0` and `false` will force online mode.

## Environment variables

Some additional variables to interact with offline checks.

- `PROTO_OFFLINE_TIMEOUT` - Customize the timeout for offline checks (in milliseconds). Defaults to
  `750`.
- `PROTO_OFFLINE_HOSTS` - Customize additional hosts/IPs to check for offline status. Separate
  multiple hosts with a `,`.
- `PROTO_OFFLINE_IP_VERSION` - Customize which IP version to support, `4` or `6`. If not defined,
  supports both.

---

## Open source usage

import Image from '@site/src/components/Image';

Although moon was designed for large monorepos, it can also be used for open source projects,
especially when coupled with our [built-in continuous integration support](./ci).

However, a pain point with moon is that it has an explicitly configured version for each tool in the
[toolchain](../concepts/toolchain), but open source projects typically need to run checks against
multiple versions! To mitigate this problem, you can set the matrix value as an environment
variable, in the format of `MOON__VERSION`.

```yaml title=".github/workflows/ci.yml"
name: 'Pipeline'
on:
  push:
    branches:
      - 'master'
  pull_request:
jobs:
  ci:
    name: 'CI'
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: ['ubuntu-latest', 'windows-latest']
        node-version: [16, 18, 20]
    steps:
      # Checkout repository
      - uses: 'actions/checkout@v4'
        with:
          fetch-depth: 0
      # Install Node.js
      - uses: 'actions/setup-node@v4'
      # Install dependencies
      - run: 'yarn install --immutable'
      # Run moon and affected tasks
      - run: 'yarn moon ci'
        env:
          MOON_NODE_VERSION: ${{ matrix.node-version }}
```

:::info

This example is only for GitHub actions, but the same mechanism can be applied to other CI
environments.

:::

## Reporting run results

We also suggest using our
[`moonrepo/run-report-action`](https://github.com/marketplace/actions/moon-ci-run-reports) GitHub
action. This action will report the results of a [`moon ci`](../commands/ci) run to a pull request
as a comment and workflow summary.

```yaml title=".github/workflows/ci.yml"
# ...
jobs:
  ci:
    name: 'CI'
    runs-on: 'ubuntu-latest'
    steps:
      # ...
      - run: 'yarn moon ci'
      - uses: 'moonrepo/run-report-action@v1'
        if: success() || failure()
        with:
          access-token: ${{ secrets.GITHUB_TOKEN }}
```

The report looks something like the following:

---

## Pkl configuration

import VersionLabel from '@site/src/components/Docs/VersionLabel';

While YAML is our official configuration format, we want to support dynamic formats, and as such,
have added support for Pkl. What is Pkl? If you haven't heard of Pkl yet,
[Pkl is a programmable configuration format by Apple](https://pkl-lang.org/). We like Pkl, as it
meets the following requirements:

- Is easy to read and write.
- Is dynamic and programmable (loops, variables, etc).
- Has type-safety / built-in schema support.
- Has Rust serde integration.

The primary requirement that we are hoping to achieve is supporting a configuration format that is
_programmable_. We want something that has native support for variables, loops, conditions, and
more, so that you could curate and compose your configuration very easily. Hacking this
functionality into YAML is a terrible user experience in our opinion!

## Installing Pkl

Pkl utilizes a client-server architecture, which means that the `pkl` binary must exist in the
environment for parsing and evaluating `.pkl` files. Jump over to the
[official documentation for instructions on how to install Pkl](https://pkl-lang.org/main/current/pkl-cli/index.html#installation).

If you are using [proto](/proto), you can install Pkl with the following commands.

```shell
proto plugin add pkl https://raw.githubusercontent.com/milesj/proto-plugins/refs/heads/master/pkl.toml
proto install pkl --pin
```

## Using Pkl

To start using Pkl in moon, simply:

- Install [Pkl](#installing-pkl) and the
  [VS Code extension](https://pkl-lang.org/vscode/current/index.html)
- Create configs with the `.pkl` extension instead of `.yml`

:::info

We highly suggest reading the Pkl
[language reference](https://pkl-lang.org/main/current/language-reference/index.html), the
[standard library](https://pkl-lang.org/main/current/standard-library.html), or looking at our
[example configurations](#example-configs) when using Pkl.

:::

### Caveats and restrictions

Since this is an entirely new configuration format that is quite dynamic compared to YAML, there are
some key differences to be aware of!

- Only files are supported. Cannot use or extend from URLs.

- Each `.pkl` file is evaluated in isolation (loops are processed, variables assigned, etc). This
  means that task inheritance and file merging cannot extend or infer this native functionality.

- `default` is a
  [special feature](https://pkl-lang.org/main/current/language-reference/index.html#default-element)
  in Pkl and cannot be used as a setting name. This only applies to
  [`template.pkl`](../config/template#default), but can be worked around by using `defaultValue`
  instead.

```pkl title="template.pkl"
variables {
  ["age"] {
    type = "number"
    prompt = "Age?"
    defaultValue = 0
}
```

- `local` is also a reserved word in Pkl. It can be worked around by escaping it with backticks, or
  you can simply use the [`preset` setting](../config/project#preset) instead.

```pkl
tasks {
  ["example"] {
    `local` = true
    # Or
    preset = "server"
  }
}
```

## Example configs

### `.moon/workspace.pkl`

```pkl
projects {
  globs = List("apps/*", "packages/*")
  sources {
    ["root"] = "."
  }
}

vcs {
  defaultBranch = "master"
}
```

### `.moon/toolchain.pkl`

```pkl
node {
  version = "20.15.0"
  packageManager = "yarn"
  yarn {
    version = "4.3.1"
  }
  addEnginesConstraint = false
  inferTasksFromScripts = false
}
```

### `moon.pkl`

```pkl
type = "application"
language = "typescript"
dependsOn = List("client", "ui")

tasks {
  ["build"] {
    command = "docusaurus build"
    deps = List("^:build")
    outputs = List("build")
    options {
      interactive = true
      retryCount = 3
    }
  }
  ["typecheck"] {
    command = "tsc --build"
    inputs = new Listing {
      "@globs(sources)"
      "@globs(tests)"
      "tsconfig.json"
      "/tsconfig.options.json"
    }
  }
}
```

## Example functionality

### Loops and conditionals

```pkl
tasks {
  for (_os in List("linux", "macos", "windows")) {
    ["build-\(_os)"] {
      command = "cargo"
      args = List(
        "--target",
        if (_os == "linux") "x86_64-unknown-linux-gnu"
          else if (_os == "macos") "x86_64-apple-darwin"
          else "i686-pc-windows-msvc",
        "--verbose"
      )
      options {
        os = _os
      }
    }
  }
}
```

### Local variables

```pkl
local _sharedInputs = List("src/**/*")

tasks {
  ["test"] {
    // ...
    inputs = List("tests/**/*") + _sharedInputs
  }
  ["lint"] {
    // ...
    inputs = List("**/*.graphql") + _sharedInputs
  }
}
```

---

## Task profiling

import Image from '@site/src/components/Docs/Image';

Troubleshooting slow or unperformant tasks? Profile and diagnose them with ease!

:::caution

Profiling is only supported by `node` based tasks, and is not supported by tasks that are created
through `package.json` inference, or for packages that ship non-JavaScript code (like Rust or Go).

:::

## CPU snapshots

CPU profiling helps you get a better understanding of which parts of your code require the most CPU
time, and how your code is executed and optimized by Node.js. The profiler will measure code
execution and activities performed by the engine itself, such as compilation, calls of system
libraries, optimization, and garbage collection.

### Record a profile

To record a CPU profile, pass `--profile cpu` to the [`moon run`](../commands/run) command. When
successful, the profile will be written to
`.moon/cache/states///snapshot.cpuprofile`.

```shell
$ moon run --profile cpu app:lint
```

### Analyze in Chrome

CPU profiles can be reviewed and analyzed with
[Chrome developer tools](https://developer.chrome.com/docs/devtools/) using the following steps.

1. Open Chrome and navigate to `chrome://inspect`.
2. Under "Devices", navigate to "Open dedicated DevTools for Node".
3. The following window will popup. Ensure the "Profiler" tab is selected.

4. Click "Load" and select the `snapshot.cpuprofile` that was
   [previously recorded](#record-a-profile). If successful, the snapshot will appear in the left
   column.

> On macOS, press `command` + `shift` + `.` to display hidden files and folders, to locate the
> `.moon` folder.

5. Select the snapshot in the left column. From here, the snapshot can be analyzed and represented
   with [Bottom up](#bottom-up), [Top down](#top-down), or [Flame chart](#flame-chart) views.

## Heap snapshots

Heap profiling lets you detect memory leaks, dynamic memory problems, and locate the fragments of
code that caused them.

### Record a profile

To record a heap profile, pass `--profile heap` to the [`moon run`](../commands/run) command. When
successful, the profile will be written to
`.moon/cache/states///snapshot.heapprofile`.

```shell
$ moon run --profile heap app:lint
```

### Analyze in Chrome

Heap profiles can be reviewed and analyzed with
[Chrome developer tools](https://developer.chrome.com/docs/devtools/) using the following steps.

1. Open Chrome and navigate to `chrome://inspect`.
2. Under "Devices", navigate to "Open dedicated DevTools for Node".
3. The following window will popup. Ensure the "Memory" tab is selected.

4. Click "Load" and select the `snapshot.heapprofile` that was
   [previously recorded](#record-a-profile-1). If successful, the snapshot will appear in the left
   column.

> On macOS, press `command` + `shift` + `.` to display hidden files and folders, to locate the
> `.moon` folder.

5. Select the snapshot in the left column. From here, the snapshot can be analyzed and represented
   with [Bottom up](#bottom-up), [Top down](#top-down), or [Flame chart](#flame-chart) views.

## Views

Chrome DevTools provide 3 views for analyzing activities within a snapshot. Each view gives you a
different perspective on these activities.

### Bottom up

The Bottom up view is helpful if you encounter a heavy function and want to find out where it was
called from.

- The "Self Time" column represents the aggregated time spent directly in that activity, across all
  of its occurrences.
- The "Total Time" column represents aggregated time spent in that activity or any of its children.
- The "Function" column is the function that was executed, including source location, and any
  children.

### Top down

The Top down view works in a similar fashion to [Bottom up](#bottom-up), but displays functions
starting from the top-level entry points. These are also known as root activities.

### Flame chart

DevTools represents main thread activity with a flame chart. The x-axis represents the recording
over time. The y-axis represents the call stack. The events on top cause the events below it.

---

## Remote caching

import VersionLabel from '@site/src/components/Docs/VersionLabel';

Is your CI pipeline running slower than usual? Are you tired of running the same build over and over
although nothing has changed? Do you wish to reuse the same local cache across other machines and
environments? These are just a few scenarios that remote caching aims to solve.

Remote caching is a system that shares artifacts to improve performance, reduce unnecessary
computation time, and alleviate resources. It achieves this by uploading hashed artifacts to a cloud
storage provider, like AWS S3 or Google Cloud, and downloading them on demand when a build matches a
derived hash.

To make use of remote caching, we provide 2 solutions.

## Self-hosted 

This solution allows you to host any remote caching service that is compatible with the
[Bazel Remote Execution v2 API](https://github.com/bazelbuild/remote-apis/tree/main/build/bazel/remote/execution/v2),
such as [`bazel-remote`](https://github.com/buchgr/bazel-remote). When using this solution, the
following RE API features must be enabled:

- Action result caching
- Content addressable storage caching
- SHA256 digest hashing
- gRPC requests

:::warning

This feature and its implementation is currently unstable, and its documentation is incomplete.
Please report any issues on GitHub or through Discord!

:::

### Host your service

When you have chosen (or built) a compatible service, host it and make it available through gRPC (we
do not support HTTP at this time). For example, if you plan to use `bazel-remote`, you can do
something like the following:

```bash
bazel-remote --dir /path/to/moon-cache --max_size 10 --storage_mode uncompressed --grpc_address 0.0.0.0:9092
```

If you've configured the [`remote.cache.compression`](../config/workspace#compression) setting to
"zstd", you'll need to run the binary with that storage mode as well.

```bash
bazel-remote --dir /path/to/moon-cache --max_size 10 --storage_mode zstd --grpc_address 0.0.0.0:9092
```

:::info

View the official [`bazel-remote`](https://github.com/buchgr/bazel-remote#usage) documentation for
all the available options, like storing artifacts in S3, configuring authentication (TLS/mTLS),
proxies, and more.

:::

### Configure remote caching

Once your service is running, you can enable remote caching by configuring the
[`unstable_remote`](../config/workspace#unstable_remote) settings in
[`.moon/workspace.yml`](../config/workspace). At minimum, the only setting that is required is
`host`.

```yaml title=".moon/workspace.yml"
unstable_remote:
  host: 'grpc://your-host.com:9092'
```

#### TLS and mTLS

We have rudimentary support for TLS and mTLS, but it's very unstable, and has not been thoroughly
tested. There's also [many](https://github.com/hyperium/tonic/issues/1652)
[many](https://github.com/hyperium/tonic/issues/1989)
[issues](https://github.com/hyperium/tonic/issues/1033) around authentication in Tonic.

```yaml title=".moon/workspace.yml"
# TLS
unstable_remote:
  host: 'grpcs://your-host.com:9092'
  tls:
    cert: 'certs/ca.pem'
    domain: 'your-host.com'

# mTLS
unstable_remote:
  host: 'grpcs://your-host.com:9092'
  mtls:
    caCert: 'certs/ca.pem'
    clientCert: 'certs/client.pem'
    clientKey: 'certs/client.key'
    domain: 'your-host.com'
```

## Cloud-hosted: Depot

If you'd prefer not to host your own solution, you could use
[Depot Cache](https://depot.dev/products/cache), a cloud-based caching solution. To make use of
Depot, follow these steps:

- Create an account on [depot.dev](https://depot.dev)
- Create an organization
- Go to organization settings -> API tokens
- Create a new API token
- Add the token as a `DEPOT_TOKEN` environment variable to your moon pipelines

Once these steps have been completed, you can enable remote caching in moon with the following
configuration. If your Depot account has more than 1 organization, you'll need to set the
`X-Depot-Org` header.

```yaml title=".moon/workspace.yml"
unstable_remote:
  host: 'grpcs://cache.depot.dev'
  auth:
    token: 'DEPOT_TOKEN'
    headers:
      'X-Depot-Org': ''
```

## FAQ

#### What is an artifact?

In the context of moon and remote caching, an artifact is the
[outputs of a task](../config/project#outputs), as well as the stdout and stderr of the task that
generated the outputs. Artifacts are uniquely identified by the
[moon generated hash](../concepts/cache#hashing).

#### Do I have to use remote caching?

No, remote caching is _optional_. It's intended purpose is to store long lived build artifacts to
speed up CI pipelines, and optionally local development. For the most part,
[`moon ci`](../commands/ci) does a great job of only running what's affected in pull requests, and
is a great starting point.

#### Does remote caching store source code?

No, remote caching _does not_ store source code. It stores the
[outputs of a task](../config/project#outputs), which is typically built and compiled code. To
verify this, you can inspect the tar archives in `.moon/cache/outputs`.

#### Does moon collect any personally identifiable information?

No, moon does not collect any PII as part of the remote caching process.

#### Are artifacts encrypted?

We do not encrypt on moon's side, as encryption is provided by your cloud storage provider.

---

## Root-level project

Coming from other repositories or task runner, you may be familiar with tasks available at the
repository root, in which one-off, organization, maintenance, or process oriented tasks can be ran.
moon supports this through a concept known as a root-level project.

Begin by adding the root to [`projects`](../config/workspace#projects) with a source value of `.`
(current directory relative from the workspace).

```yaml title=".moon/workspace.yml"
# As a map
projects:
  root: '.'

# As a list of globs
projects:
  - '.'
```

> When using globs, the root project's name will be inferred from the repository folder name. Be
> wary of this as it can change based on what a developer has checked out as.

Once added, create a [`moon.yml`](../config/project) in the root of the repository. From here you
can define tasks that can be ran using this new root-level project name, for example,
`moon run root:`.

```yaml title="moon.yml"
tasks:
  versionCheck:
    command: 'yarn version check'
    inputs: []
    options:
      cache: false
```

And that's it, but there are a few caveats to be aware of...

## Caveats

### Greedy inputs

:::warning

In moon v1.24, root-level tasks default to no inputs. In previous versions, inputs defaulted to
`**/*`. This section is only applicable for older moon versions!

:::

Task [`inputs`](../config/project#inputs) default to `**/*`, which would result in root-level tasks
scanning _all_ files in the repository. This will be a very expensive operation! We suggest
restricting inputs to a very succinct whitelist, or disabling inputs entirely.

```yaml title="moon.yml"
tasks:
  oneOff:
    # ...
    inputs: []
```

### Inherited tasks

Because a root project is still a project in the workspace, it will inherit all tasks defined in
[`.moon/tasks.yml`](../config/tasks), which may be unexpected. To mitigate this, you can exclude
some or all of these tasks in the root config with
[`workspace.inheritedTasks`](../config/project#inheritedtasks).

```yaml title="moon.yml"
workspace:
  inheritedTasks:
    include: []
```

---

## Rust handbook

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Utilizing Rust in a monorepo is a trivial task, thanks to Cargo, and also moon. With this handbook,
we'll help guide you through this process.

:::info

moon is not a build system and does _not_ replace Cargo. Instead, moon runs `cargo` commands, and
efficiently orchestrates those tasks within the workspace.

:::

## moon setup

For this part of the handbook, we'll be focusing on [moon](/moon), our task runner. To start,
languages in moon act like plugins, where their functionality and support _is not_ enabled unless
explicitly configured. We follow this approach to avoid unnecessary overhead.

### Enabling the language

To enable Rust, define the [`rust`](../../config/toolchain#rust) setting in
[`.moon/toolchain.yml`](../../config/toolchain), even if an empty object.

```yaml title=".moon/toolchain.yml"
# Enable Rust
rust: {}

# Enable Rust and override default settings
rust:
  syncToolchainConfig: true
```

:::info

In moon v1.37+, use `unstable_rust` instead of `rust` to enable the new WASM powered Rust toolchain,
which is far more accurate and efficient. The non-WASM toolchain will be deprecated in the future.

:::

Or by pinning a `rust` version in [`.prototools`](../../proto/config) in the workspace root.

```toml title=".prototools"
rust = "1.69.0"
```

This will enable the Rust toolchain and provide the following automations around its ecosystem:

- Manifests and lockfiles are parsed for accurate dependency versions for hashing purposes.
- Cargo binaries (in `~/.cargo/bin`) are properly located and executed.
- Automatically sync `rust-toolchain.toml` configuration files.
- For non-workspaces, will inherit `package.name` from `Cargo.toml` as a project alias.
- And more to come!

### Utilizing the toolchain

When a language is enabled, moon by default will assume that the language's binary is available
within the current environment (typically on `PATH`). This has the downside of requiring all
developers and machines to manually install the correct version of the language, _and to stay in
sync_.

Instead, you can utilize [moon's toolchain](../../concepts/toolchain), which will download and
install the language in the background, and ensure every task is executed using the exact version
across all machines.

Enabling the toolchain is as simple as defining the
[`rust.version`](../../config/toolchain#version-2) setting.

```yaml title=".moon/toolchain.yml"
# Enable Rust toolchain with an explicit version
rust:
  version: '1.69.0'
```

> Versions can also be defined with [`.prototools`](../../proto/config).

:::caution

moon requires `rustup` to exist in the environment, and will use this to install the necessary Rust
toolchains. This requires Rust to be manually installed on the machine, as moon does not
auto-install the language, just the toolchains.

:::

## Repository structure

Rust/Cargo repositories come in two flavors: a single crate with one `Cargo.toml`, or multiple
crates with many `Cargo.toml`s using
[Cargo workspaces](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html). The latter is
highly preferred as it enables Cargo incremental caching.

Regardless of which flavor your repository uses, in moon, both flavors are a single
[moon project](../../concepts/project). This means that all Rust crates are grouped together into a
single moon project, and the [`moon.yml`](../../config/project) file is located at the root relative
to `Cargo.lock` and the `target` folder.

An example of this layout is demonstrated below:

```
/
├── .moon/
├── crates/
│   ├── client/
|   │   ├── ...
│   │   └── Cargo.toml
│   ├── server/
|   │   ├── ...
│   │   └── Cargo.toml
│   └── utils/
|       ├── ...
│       └── Cargo.toml
├── target/
├── Cargo.lock
├── Cargo.toml
└── moon.yml
```

```
/
├── .moon/
├── src/
│   └── lib.rs
├── tests/
│   └── ...
├── target/
├── Cargo.lock
├── Cargo.toml
└── moon.yml
```

### Example `moon.yml`

The following configuration represents a base that covers most Rust projects.

```yaml title="/moon.yml"
language: 'rust'
layer: 'application'

env:
  CARGO_TERM_COLOR: 'always'

fileGroups:
  sources:
    - 'crates/*/src/**/*'
    - 'crates/*/Cargo.toml'
    - 'Cargo.toml'
  tests:
    - 'crates/*/benches/**/*'
    - 'crates/*/tests/**/*'

tasks:
  build:
    command: 'cargo build'
    inputs:
      - '@globs(sources)'
  check:
    command: 'cargo check --workspace'
    inputs:
      - '@globs(sources)'
  format:
    command: 'cargo fmt --all --check'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
  lint:
    command: 'cargo clippy --workspace'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
  test:
    command: 'cargo test --workspace'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
```

```yaml title="/moon.yml"
language: 'rust'
layer: 'application'

env:
  CARGO_TERM_COLOR: 'always'

fileGroups:
  sources:
    - 'src/**/*'
    - 'Cargo.toml'
  tests:
    - 'benches/**/*'
    - 'tests/**/*'

tasks:
  build:
    command: 'cargo build'
    inputs:
      - '@globs(sources)'
  check:
    command: 'cargo check'
    inputs:
      - '@globs(sources)'
  format:
    command: 'cargo fmt --check'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
  lint:
    command: 'cargo clippy'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
  test:
    command: 'cargo test'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
```

## Cargo integration

You can't use Rust without Cargo -- well you could but why would you do that? With moon, we're doing
our best to integrate with Cargo as much as possible. Here's a few of the benefits we currently
provide.

### Global binaries

Cargo supports global binaries through the
[`cargo install`](https://doc.rust-lang.org/cargo/commands/cargo-install.html) command, which
installs a crate to `~/.cargo/bin`, or makes it available through the `cargo ` command. These
are extremely beneficial for development, but they do require every developer to manually install
the crate (and appropriate version) to their machine.

With moon, this is no longer an issue with the [`rust.bins`](../../config/toolchain#bins) setting.
This setting requires a list of crates (with optional versions) to install, and moon will install
them as part of the task runner install dependencies action. Furthermore, binaries will be installed
with [`cargo-binstall`](https://crates.io/crates/cargo-binstall) in an effort to reduce build and
compilation times.

```yaml title=".moon/toolchain.yml" {2-4}
rust:
  bins:
    - 'cargo-make@0.35.0'
    - 'cargo-nextest'
```

At this point, tasks can be configured to run this binary as a command. The `cargo` prefix is
optional, as we'll inject it when necessary.

```yaml title="/moon.yml"
tasks:
  test:
    command: 'nextest run --workspace'
    toolchain: 'rust'
```

:::tip

The `cargo-binstall` crate may require a `GITHUB_TOKEN` environment variable to make GitHub Releases
API requests, especially in CI. If you're being rate limited, or fail to find a download, try
creating a token with necessary permissions.

:::

### Lockfile handling

To expand our integration even further, we also take `Cargo.lock` into account, and apply the
following automations when a target is being ran:

- If the lockfile does not exist, we generate one with
  [`cargo generate-lockfile`](https://doc.rust-lang.org/cargo/commands/cargo-generate-lockfile.html).
- We parse and extract the resolved checksums and versions for more accurate hashing.

## FAQ

### Should we cache the `target` directory as an output?

No, we don't believe so. Both moon and Cargo support incremental caching, but they're not entirely
compatible, and will most likely cause problems when used together.

The biggest factor is that moon's caching and hydration uses a tarball strategy, where each task
would unpack a tarball on cache hit, and archive a tarball on cache miss. The Cargo target directory
is extremely large (moon's is around 50gb), and coupling this with our tarball strategy is not
viable. This would cause massive performance degradation.

However, at maximum, you _could_ cache the compiled binary itself as an output, instead of the
entire target directory. Example:

```yaml title="moon.yml"
tasks:
  build:
    command: 'cargo build --release'
    outputs: ['target/release/moon']
```

### How can we improve CI times?

Rust is known for slow build times and CI is no exception. With that being said, there are a few
patterns to help alleviate this, both on the moon side and outside of it.

To start, you can cache Rust builds in CI. This is a non-moon solution to the `target` directory
problem above.

1. If you use GitHub Actions, feel free to use our
   [moonrepo/setup-rust](https://github.com/moonrepo/setup-rust) action, which has built-in caching.
2. A more integrated solution is [sccache](https://crates.io/crates/sccache), which stores build
   artifacts in a cloud storage provider.

---

## Sharing workspace configuration

For large companies, open source maintainers, and those that love reusability, more often than not
you'll want to use the same configuration across all repositories for consistency. This helps reduce
the maintenance burden while ensuring a similar developer experience.

To help streamline this process, moon provides an `extends` setting in both
[`.moon/workspace.yml`](../config/workspace#extends),
[`.moon/toolchain.yml`](../config/toolchain#extends), and
[`.moon/tasks.yml`](../config/tasks#extends). This setting requires a HTTPS URL _or_ relative file
system path that points to a valid YAML document for the configuration in question.

A great way to share configuration is by using GitHub's "raw file view", as demonstrated below using
our very own [examples repository](https://github.com/moonrepo/examples).

```yaml title=".moon/tasks.yml"
extends: 'https://raw.githubusercontent.com/moonrepo/examples/master/.moon/tasks.yml'
```

## Versioning

Inheriting an upstream configuration can be dangerous, as the settings may change at any point,
resulting in broken builds. To mitigate this, you can used a "versioned" upstream configuration,
which is ideally a fixed point in time. How this is implemented is up to you or your company, but we
suggest the following patterns:

### Using versioned filenames

A rudimentary solution is to append a version to the upstream filename. When the file is modified, a
new version should be created, while the previous version remains untouched.

```diff
-extends: '../shared/project.yml'
+extends: '../shared/project-v1.yml'
```

### Using branches, tags, or commits

When using a version control platform, like GitHub above, you can reference the upstream
configuration through a branch, tag, commit, or sha. Since these are a reference point in time, they
are relatively safe.

```diff
-extends: 'https://raw.githubusercontent.com/moonrepo/examples/master/.moon/tasks.yml'
+extends: 'https://raw.githubusercontent.com/moonrepo/examples/c3f10160bcd16b48b8d4d21b208bb50f6b09bd96/.moon/tasks.yml'
```

---

## VCS hooks

import VersionLabel from '@site/src/components/Docs/VersionLabel';

VCS hooks (most popular with [Git](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)) are a
mechanism for running scripts at pre-defined phases in the VCS's lifecycle, most commonly
pre-commit, pre-push, or pre-merge. With moon, we provide a built-in solution for managing hooks,
and syncing them across developers and machines.

- [Learn more about Git hooks](https://git-scm.com/docs/githooks)

## Defining hooks

Hooks can be configured with the [`vcs.hooks`](../config/workspace#hooks) setting in
[`.moon/workspace.yml`](../config/workspace). This setting requires a map of hook names (in the
format required by your VCS), to a list of arbitrary commands to run within the hook script.
Commands are used as-is and are not formatted or interpolated in any way.

To demonstrate this, let's configure a `pre-commit` hook that runs a moon `lint` task for affected
projects, and also verifies that the commit message abides by a specified format (using
[pre-commit](https://pre-commit.com/)).

```yaml title=".moon/workspace.yml"
vcs:
  hooks:
    pre-commit:
      - 'pre-commit run'
      - 'moon run :lint --affected'
```

:::info

All commands are executed from the repository root (not moon's workspace root) and must exist on
`PATH`. If `moon` is installed locally, you can execute it using a repository relative path, like
`./node_modules/@moonrepo/cli/moon`.

:::

## Enabling hooks

Hooks are a divisive subject, as some developers love them, and others hate them. Finding a viable
solution for everyone can be difficult, so with moon, we opted to support 2 distinct options, but
only 1 can be used at a time. Choose the option that works best for your project, team, or company!

:::caution

If you have existing VCS hooks, back them up as moon's implementation will overwrite them! To
migrate your existing hooks, [configure them as commands to run](#defining-hooks).

:::

### Automatically for everyone

If you'd like hooks to be enforced for every contributor of the repository, then simply enable the
[`vcs.syncHooks`](../config/workspace#synchooks) setting in
[`.moon/workspace.yml`](../config/workspace). This will automatically generate hook scripts and link
them with the local VCS checkout, everytime a [target](../concepts/target) is ran.

```yaml title=".moon/workspace.yml"
vcs:
  hooks: [...]
  syncHooks: true
```

### Manually by each developer

If you'd prefer contributors to have a choice in whether or not they want to use hooks, then simply
do nothing, and guide them to run the [`moon sync hooks`](../commands/sync/hooks) command. This
command will generate hook scripts and link them with the local VCS checkout.

```shell
$ moon sync hooks
```

## Disabling hooks

If you choose to stop using hooks, you'll need to cleanup the previously generated hook scripts, and
reset the VCS checkout. To start, disable the `vcs.syncHooks` setting.

```yaml title=".moon/workspace.yml"
vcs:
  syncHooks: false
```

And then run the following command, which will delete files from your local filesystem. Every
developer that is using hooks will need to run this command.

```shell
$ moon sync hooks --clean
```

## How it works

When hooks are [enabled](#enabling-hooks), the following processes will take place.

1. The configured [hooks](#defining-hooks) will be generated as individual script files in the
   `.moon/hooks` directory. Whether or not you commit or ignore these script files is your choice.
   They are written to the `.moon` directory so that they can be reviewed, audited, and easily
   tested, but _are required_.

2. We then sync these generated hook scripts with the current VCS. For Git, we create `.git/hooks`
   files that execute our generated scripts, using repository relative commands. Any existing VCS
   hooks _will be overwritten_.

:::info

The `.moon/hooks` scripts are generated as Bash scripts (use a `.sh` file extension) on Unix, and
PowerShell scripts (use a `.ps1` file extension) on Windows.

:::

### Git

On Unix based operating systems (Linux, macOS, etc), the `.moon/hooks` scripts are executed from
`.git/hooks` Bash files. Because of this, `bash` should be available on the system (which is
typically the case).

On Windows, things get tricky. Since Git has a requirement that `.git/hooks` files _must be_
extensionless, and older versions of PowerShell require an extension, we have to use a workaround.
To handle this, the `.git/hooks` files are Bash-like scripts (that should work on most machines)
that execute `.moon/hooks` using the `powershell.exe` (or `pwsh.exe`) executables. Because of this,
PowerShell must be available on the system.

## Examples

### Pre-commit

A perfect use case for the `pre-commit` hook is to check linting and formatting of the files being
committed. If either of these tasks fail, the commit will abort until they are fixed. Be sure to use
the [`--affected`](../run-task#running-based-on-affected-files-only) option so that we _only run_ on
changed projects!

```yaml title=".moon/workspace.yml"
vcs:
  hooks:
    pre-commit:
      - 'moon run :lint :format --affected --status=staged'
```

> By default this will run on the _entire_ project (all files). If you want to filter it to only the
> changed files, enable the [`affectedFiles`](../config/project#affectedfiles) task option.

---

## WASM plugins

[moon](/moon) and [proto](/proto) plugins can be written in
[WebAssembly (WASM)](https://webassembly.org/), a portable binary format. This means that plugins
can be written in any language that compiles to WASM, like Rust, C, C++, Go, TypeScript, and more.
Because WASM based plugins are powered by a programming language, they implicitly support complex
business logic and behavior, have access to a sandboxed file system (via WASI), can execute child
processes, and much more.

:::danger

Since our WASM plugin implementations are still experimental, expect breaking changes to occur in
non-major releases.

:::

## Powered by Extism

Our WASM plugin system is powered by [Extism](https://extism.org/), a Rust-based cross-language
framework for building WASM plugins under a unified guest and host API. Under the hood, Extism uses
[wasmtime](https://wasmtime.dev/) as its WASM runtime.

For the most part, you do _not_ need to know about Extism's host SDK, as we have implemented the
bulk of it within moon and proto directly. However, you _should_ be familiar with the guest PDKs, as
this is what you'll be using to implement Rust-based plugins. We suggest reading the following
material:

- [Plugin development kits](https://extism.org/docs/concepts/pdk) (PDKs)
- The [extism-pdk](https://github.com/extism/rust-pdk) Rust crate
- [Host functions](https://extism.org/docs/concepts/host-functions) (how they work)

## Concepts

Before we begin, let's talk about a few concepts that are critical to WASM and our plugin systems.

### Plugin identifier

When implementing plugin functions, you'll need to access information about the current plugin. To
get the current plugin identifier (the key the plugin was configured with), use the
[`get_plugin_id`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.get_plugin_id.html) function.

```rust
let id = get_plugin_id();
```

### Virtual paths

WASM by default does not have access to the host file system, but through [WASI](https://wasi.dev/),
we can provide sandboxed access to a pre-defined list of allowed directories. We call these
[virtual paths](https://docs.rs/warpgate_api/latest/warpgate_api/enum.VirtualPath.html), and all
paths provided via function input or context use them.

Virtual paths are implemented by mapping a real path (host machine) to a virtual path (guest
runtime) using file path prefixes. The following prefixes are currently supported:

| Real path         | Virtual path | Only for |
| ----------------- | ------------ | -------- |
| `~`               | `/userhome`  | ~        |
| `~/.proto`        | `/proto`     | ~        |
| `~/.moon`         | `/moon`      | moon     |
| Working directory | `/cwd`       | ~        |
| moon workspace    | `/workspace` | moon     |

For example, from the context of WASM, you may have a virtual path of `/proto/tools/node/1.2.3`,
which simply maps back to `~/.proto/tools/node/1.2.3` on the host machine. However, this should
almost always be transparent to you, the developer, and to end users.

However, there may be a few cases where you need access to the real path from WASM, for example,
logging or executing commands. For this, the real path can be accessed with the
[`real_path`](https://docs.rs/warpgate_api/latest/warpgate_api/enum.VirtualPath.html#method.real_path)
function on the `VirtualPath` enum (this is a Rust only feature).

```rust
virtual_path.real_path();
```

#### File system caveats

When working with the file system from the context of WASM, there are a few caveats to be aware of.

- All `fs` calls must use the virtual path. Real paths will error.
- Paths not white listed (using prefixes above) will error.
- Changing file permissions is not supported (on Unix and Windows).
  - This is because WASI does not support this.
  - This also means operations like unpacking archives is not possible.

### Host environment

Since WASM executes in its own runtime, it _does not_ have access to the current host operating
system, architecture, so on and so forth. To bridge this gap, we provide the
[`get_host_environment`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.get_host_environment.html)
function.
[Learn more about this type](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/struct.HostEnvironment.html).

```rust
let env = get_host_environment()?;
```

The host operating system and architecture can be accessed with `os` and `arch` fields respectively.
Both fields are an enum in Rust, or a string in other languages.

```rust
if env.os == HostOS::Windows {
    // Windows only
}

if env.arch == HostArch::Arm64 {
    // aarch64 only
}
```

Furthermore, the user's home directory (`~`) can be accessed with the `home_dir` field, which is a
[virtual path](#virtual-paths).

```rust
if env.home_dir.join(some_path).exists() {
    // Do something
}
```

### Host functions & macros

WASM is pretty powerful but it can't do everything since it's sandboxed. To work around this, we
provide a mechanism known as host functions, which are functions that are implemented on the host
(in Rust), and can be executed from WASM. The following host functions are currently available:

- [`exec_command`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.exec_command.html) -
  Execute a system command on the host machine, with a provided list of arguments or environment
  variables.
- [`from_virtual_path`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.real_path.html) -
  Converts a virtual path into a real path.
- [`get_env_var`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.host_env.html) - Get an
  environment variable value from the host environment.
- [`host_log`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.host_log.html) - Log an
  stdout, stderr, or tracing message to the host's terminal.
- [`send_request`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.send_request.html) -
  Requests a URL on the host machine using a Rust-based HTTP client (not WASM).
- [`set_env_var`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.host_env.html) - Set an
  environment variable to the host environment.
- [`to_virtual_path`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.virtual_path.html) -
  Converts a real path into a virtual path.

To use host functions, you'll need to make them available by registering them at the top of your
Rust file (only add the functions you want to use) using the
[extism-pdk](https://crates.io/crates/extism-pdk) crate.

```rust
use extism_pdk::*;

#[host_fn]
extern "ExtismHost" {
    fn exec_command(input: Json) -> Json;
    fn from_virtual_path(path: String) -> String;
    fn get_env_var(key: String) -> String;
    fn host_log(input: Json);
    fn send_request(input: Json) -> Json;
    fn set_env_var(key: String, value: String);
    fn to_virtual_path(path: String) -> Json;
}
```

:::info

To simplify development, we provide built-in functions and macros for the host functions above.
Continue reading for more information on these macros.

:::

#### Converting paths

When working with virtual paths, you may need to convert them to real paths, and vice versa. The
[`into_virtual_path`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.into_virtual_path.html)
and [`into_real_path`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.into_real_path.html)
functions can be used for such situations, which use the `to_virtual_path` and `from_virtual_path`
host functions respectively.

```rust
// Supports strings or paths
let virt = into_virtual_path("/some/real/path")?;
let real = into_real_path(PathBuf::from("/some/virtual/path"))?;
```

#### Environment variables

The [`get_host_env_var`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.get_host_env_var.html)
and [`set_host_env_var`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.set_host_env_var.html)
functions can be used to read and write environment variables on the host, using the `set_env_var`
and `get_env_var` host functions respectively.

```rust
// Set a value
set_host_env_var("ENV_VAR", "value")?;

// Get a value (returns an `Option`)
let value = get_host_env_var("ENV_VAR")?;
```

Additionally, the
[`add_host_paths`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.add_host_paths.html) function
can be used to append paths to the `PATH` environment variable.

```rust
// Append to path
add_host_paths(["/userhome/some/virtual/path"])?;
```

#### Executing commands

The [`exec_command!`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.exec_command.html)
macro can be used to execute a command on the host, using the `exec_command` host function. If the
command does not exist on `PATH`, an error is thrown. This macros supports three modes: pipe,
inherit, and raw (returns `Result`).

```rust
let result = exec_command!(raw, "which", ["node"]);
```

If you want a simpler API, the
[`exec`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.exec.html),
[`exec_captured`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.exec_captured.html) (pipe),
and [`exec_streamed`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.exec_streamed.html)
(inherit) functions can be used.

```rust
// Pipe stdout/stderr
let output = exec_captured("which", ["node"])?;

// Inherit stdout/stderr
exec_streamed("npm", ["install"])?;

// Full control
exec(ExecCommandInput {
    command: "npm".into(),
    args: vec!["install".into()],
    ..ExecCommandInput::default()
})?;
```

#### Sending requests

The [`send_request`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.send_request.html) macro
can be used to request a URL on the host, instead of from WASM, allowing it to use the same HTTP
client as the host CLI. This macro returns a response object, with the raw body in bytes, and the
status code.

```rust
let response = send_request!("https://some.com/url/to/fetch");

if response.status == 200 {
  let json = response.json::()?;
  let text = response.text()?;
} else {
  // Error!
}
```

To simplify the handling of requests -> responses, we also provide the
[`fetch_bytes`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.fetch_bytes.html),
[`fetch_json`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.fetch_json.html), and
[`fetch_text`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/fn.fetch_text.html) functions.

```rust
let json: T = fetch_json("https://some.com/url/to/fetch.json")?;
```

> Only GET requests are supported.

#### Logging

The [`host_log!`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/macro.host_log.html) macro can be
used to write stdout or stderr messages to the host's terminal, using the `host_log` host function.
It supports the same argument patterns as `format!`.

If you want full control, like providing data/fields, use the input mode and provide
[`HostLogInput`](https://docs.rs/warpgate_pdk/latest/warpgate_pdk/struct.HostLogInput.html).

```rust
host_log!(stdout, "Some message");
host_log!(stderr, "Some message with {}", "args");

// With data
host_log!(input, HostLogInput {
    message: "Some message with data".into(),
    data: HashMap::from_iter([
        ("data".into(), serde_json::to_value(data)?),
    ]),
    target: HostLogTarget::Stderr,
});
```

Furthermore, the [extism-pdk](https://crates.io/crates/extism-pdk) crate provides a handful of
macros for writing level-based messages that'll appear in the host's terminal when `--log` is
enabled in the CLI. These also support arguments.

```rust
debug!("This is a debug message");
info!("Something informational happened");
warn!("Proceed with caution");
error!("Oh no, something went wrong");
```

## Configuring plugin locations

To use a WASM plugin, it'll need to be configured in both moon and proto. Luckily both tools use a
similar approach for configuring plugins called the
[plugin locator](https://docs.rs/warpgate/latest/warpgate/enum.PluginLocator.html). A locator string
is composed of 2 parts separated by `://`, the former is the protocol, and the latter is the
location.

```toml
"://"
```

The following locator patterns are supported:

### `file`

The `file://` protocol represents a file path, either absolute or relative (from the current
configuration file).

```toml
# Relative
"file://./path/to/example.wasm"

# Absolute
"file:///root/path/to/example.wasm"
```

### `github`

The `github://` protocol can be used to target and download an asset from a specific GitHub release.
The location must be an organization + repository slug (owner/repo), and the release _must have_ a
`.wasm` asset available to download.

```toml
"github://moonrepo/example-repo"
```

If you are targeting releases in a monorepo, you can append the project name after the repository.
The project name will be used as a prefix for tags, and will match `@v?` or
`-v?` based tags.

```toml
"github://moonrepo/example-repo/project-name"
```

By default, the latest release will be used and cached for 7 days. If you'd prefer to target a
specific release (preferred), append the release tag to the end of the location.

```toml
"github://moonrepo/example-repo@v1.2.3"
```

This strategy is powered by the [GitHub API](https://api.github.com/) and is subject to rate
limiting. If running in a CI environment, we suggesting setting a `GITHUB_TOKEN` environment
variable to authorize API requests with. If using GitHub Actions, it's as simple as:

```yaml
# In some job or step...
env:
  GITHUB_TOKEN: '${{ secrets.GITHUB_TOKEN }}'
```

### `https`

The `https://` protocol is your standard URL, and must point to an absolute file path. Files will be
downloaded to `~/.moon/plugins` or `~/.proto/plugins`. Non-secure URLs are _not supported_!

```toml
"https://domain.com/path/to/plugins/example.wasm"
```

## Creating a plugin

:::info

Although plugins can be written in any language that compiles to WASM, we've only tested Rust. The
rest of this article assume you're using Rust and Cargo! Refer to [Extism](https://extism.org/)'s
documentation for other examples.

:::

To start, create a new crate with Cargo:

```shell
cargo new plugin --lib
cd plugin
```

Set the lib type to `cdylib`, and provide other required settings.

```toml title="Cargo.toml"
[package]
name = "example_plugin"
version = "0.0.1"
edition = "2024"
publish = false

[lib]
crate-type = ['cdylib']

[profile.release]
codegen-units = 1
debug = false
lto = true
opt-level = "s"
panic = "abort"
```

Our Rust plugins are powered by [Extism](https://extism.org/), so lets add their PDK and ours as a
dependency.

```shell
cargo add extism-pdk

# For proto
cargo add proto_pdk

# For moon
cargo add moon_pdk
```

In all Rust files, we can import all the PDKs with the following:

```rust title="src/lib.rs"
use extism_pdk::*;
```

We can then build the WASM binary. The file will be available at
`target/wasm32-wasip1/debug/.wasm`.

```shell
cargo build --target wasm32-wasip1
```

## Building and publishing

At this point, you should have a fully working WASM plugin, but to make it available to the
community, you'll still need to build and make the `.wasm` file available. The easiest solution is
to publish a GitHub release and include the `.wasm` file as an asset.

### Building, optimizing, and stripping

WASM files are pretty fat, even when compiling in release mode. To reduce the size of these files,
we can use `wasm-opt` and `wasm-strip`, both of which are provided by the
[WebAssembly](https://github.com/WebAssembly) group. The following script is what we use to build
our own plugins.

:::info

This functionality is natively supported in our
[moonrepo/build-wasm-plugin](https://github.com/moonrepo/build-wasm-plugin) GitHub Action!

:::

```bash title="build-wasm"
#!/usr/bin/env bash

target="${CARGO_TARGET_DIR:-target}"
input="$target/wasm32-wasip1/release/$1.wasm"
output="$target/wasm32-wasip1/$1.wasm"

echo "Building"

cargo build --target wasm32-wasip1 --release

echo "Optimizing"

# https://github.com/WebAssembly/binaryen
~/binaryen/bin/wasm-opt -Os "$input" --output "$output"

echo "Stripping"

# https://github.com/WebAssembly/wabt
~/wabt/bin/wasm-strip "$output"
```

### Manually create releases

When your plugin is ready to be published, you can create a release on GitHub using the following
steps.

1. Tag the release and push to GitHub.

```shell
git tag v0.0.1
git push --tags
```

2. Build a release version of the plugin using the `build-wasm` script above. The file will be
   available at `target/wasm32-wasip1/.wasm`.

```shell
build-wasm 
```

3. In GitHub, navigate to the tags page, find the new tag, create a new release, and attach the
   built file as an asset.

### Automate releases

If you're using GitHub Actions, you can automate the release process with our official
[moonrepo/build-wasm-plugin](https://github.com/moonrepo/build-wasm-plugin) action.

1. Create a new workflow file at `.github/workflows/release.yml`. Refer to the link above for a
   working example.

2. Tag the release and push to GitHub.

```shell
# In a polyrepo
git tag v0.0.1

# In a monorepo
git tag example_plugin-v0.0.1

# Push the tags
git push --tags
```

3. The action will automatically build the plugin, create a release, and attach the built file as an
   asset.

---

## Webhooks (experimental)

import HeadingApiLink from '@site/src/components/Docs/HeadingApiLink';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

Looking to gather metrics for your pipelines? Gain insight into run durations and failures? Maybe
you want to send Slack or Discord notifications? With our webhooks, all of these are possible!

When the [`notifier.webhookUrl`](../config/workspace#webhookurl) setting is configured with an HTTPS
URL, and moon is running in a CI environment, moon will POST a payload to this endpoint for every
event in our pipeline.

## Payload structure

Every webhook event is posted with the following request body, known as a payload.

- `type` (`string`) - The type of [event](#events).
- `environment` (`object | null`) - Information about the current CI/CD pipeline environment.
- `event` (`object`) - The event specific payload. View each event for an example of their
  structure.
- `createdAt` (`string`) - When the event was created, as a UTC timestamp in ISO 8601 (RFC 3339)
  format.
- `uuid` (`string`) - A unique identifier for all webhooks in the current run batch.
- `trace` (`string`) - A unique identifier for all webhooks in the overall run batch. Can be defined
  via `MOON_TRACE_ID` environment variable.

```json
{
  "type": "...",
  "environment": "...",
  "event": {
    // ...
  },
  "createdAt": "...",
  "uuid": "...",
  "trace": "..."
}
```

> The `uuid` field can be used to differentiate concurrently running pipelines!

### Pipeline environment

When webhooks are sent from a CI/CD pipeline, we attempt to include information about the
environment under the `environment` field. If information could not be detected, this field is null,
otherwise it contains these fields.

- `baseBranch` (`string | null`) - When a merge/pull request, the target (base) branch, otherwise
  null.
- `branch` (`string`) - When a merge/pull request, the source (head) branch, otherwise the
  triggering branch.
- `id` (`string`) - ID of the current pipeline instance.
- `provider` (`string`) - Name of your CI/CD provider. GitHub Actions, GitLab, CircleCI, etc.
- `requestId` (`string | null`) - The ID of the merge/pull request.
- `requestUrl` (`string | null`) - Link to the merge/pull request.
- `revision` (`string`) - The HEAD commit, revision, tag, ref, etc, that triggered the pipeline.
- `url` (`string | null`) - Link to the current pipeline, when available.

## Events

### Pipeline

Runs actions within moon using a robust dependency graph. Is triggered when using
[`moon run`](../commands/run).

### `pipeline.started`

Triggered when the pipeline has been created but before actions have started to run.

This event includes the number of actions registered within the pipeline, but does not provide
detailed information about the actions. Use the [`action.*`](#actionstarted) events for this.

```json
{
  "type": "pipeline.started",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "actionsCount": 15
  },
  "uuid": "..."
}
```

### `pipeline.finished`

Triggered when the pipeline has finished running all actions, with aggregated counts based on final
status.

This event is _not_ triggered if the pipeline crashes (this does not include actions that have
failed, as those are legitimate runs). Use the [`pipeline.aborted`](#pipelineaborted) event if you
want to also catch crashes.

```json
{
  "type": "pipeline.finished",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "cachedCount": 10,
    "baselineDuration": {
      "secs": 60,
      "nanos": 3591693
    },
    "duration": {
      "secs": 120,
      "nanos": 3591693
    },
    "estimatedSavings": {
      "secs": 60,
      "nanos": 0
    },
    "failedCount": 1,
    "passedCount": 4
  },
  "uuid": "..."
}
```

### `pipeline.aborted`

Triggered when the pipeline has crashed for unknown reasons, or had to abort as a result of a
critical action failing.

```json
{
  "type": "pipeline.aborted",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": "..."
  },
  "uuid": "..."
}
```

### Actions

Actions are "jobs" within the pipeline that are executed topologically.

### `action.started`

Triggered when an action within the pipeline has started to run.

```json
{
  "type": "action.started",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "action": {
      "attempts": null,
      "createdAt": "...",
      "duration": {
        "secs": 0,
        "nanos": 3591693
      },
      "error": null,
      "label": "InstallWorkspaceDeps(node:18.0.0)",
      "nodeIndex": 5,
      "status": "passed"
    },
    "node": {
      "action": "InstallDeps",
      "params": [
        {
          "toolchain": "Node",
          "version": "18.0.0"
        }
      ]
    }
  },
  "uuid": "..."
}
```

### `action.finished`

Triggered when an action within the pipeline has finished running, either with a success or failure.
If the action failed, the `error` field will be set with the error message.

```json
{
  "type": "action.finished",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "action": {
      "attempts": null,
      "createdAt": "...",
      "duration": {
        "secs": 0,
        "nanos": 3591693
      },
      "error": null,
      "label": "InstallWorkspaceDeps(node:18.0.0)",
      "nodeIndex": 5,
      "status": "passed"
    },
    "error": null,
    "node": {
      "action": "InstallDeps",
      "params": {
        "toolchain": "Node",
        "version": "18.0.0"
      }
    }
  },
  "uuid": "..."
}
```

### `dependencies.installing`

Triggered when dependencies for a workspace or project have started to install. When targeting a
project, the `project` field will be set, otherwise `null` for the entire workspace.

```json
{
  "type": "dependencies.installing",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "project": {
      "id": "server"
      // ...
    },
    "runtime": {
      "toolchain": "Node",
      "version": "18.0.0"
    },
    "root": ".",
    "toolchain": "node"
  },
  "uuid": "..."
}
```

### `dependencies.installed`

Triggered when dependencies for a workspace or project have finished installing. When targeting a
project, the `project` field will be set, otherwise `null` for the entire workspace. If the install
failed, the `error` field will be set with the error message.

For more information about the action, refer to the [`action.finished`](#actionfinished) event.
Installed deps can be scoped with the `InstallDeps(...)` labels.

```json
{
  "type": "dependencies.installed",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null,
    "project": null,
    "runtime": {
      "toolchain": "Node",
      "version": "18.0.0"
    },
    "root": ".",
    "toolchain": "node"
  },
  "uuid": "..."
}
```

### `environment.initializing`

Triggered when an environment is being setup for a toolchain. When targeting a project, the
`project` field will be set, otherwise `null` for the entire workspace.

```json
{
  "type": "environment.initializing",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "project": {
      "id": "server"
      // ...
    },
    "root": ".",
    "toolchain": "node"
  },
  "uuid": "..."
}
```

### `environment.initialized`

Triggered when an environment has been setup for a toolchain. When targeting a project, the
`project` field will be set, otherwise `null` for the entire workspace. If setup failed, the `error`
field will be set with the error message.

For more information about the action, refer to the [`action.finished`](#actionfinished) event.
Installed deps can be scoped with the `SetupEnvironment(...)` labels.

```json
{
  "type": "environment.initialized",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null,
    "project": null,
    "root": ".",
    "toolchain": "node"
  },
  "uuid": "..."
}
```

### `project.syncing`

Triggered when an affected project has started syncing its workspace state. This occurs
automatically before a project's task is ran.

```json
{
  "type": "project.syncing",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "project": {
      "id": "client"
      // ...
    },
    "runtime": {
      "toolchain": "Node",
      "version": "18.0.0"
    }
  },
  "uuid": "..."
}
```

### `project.synced`

Triggered when an affected project has finished syncing. If the sync failed, the `error` field will
be set with the error message.

For more information about the action, refer to the [`action.finished`](#actionfinished) event.
Synced projects can be scoped with the `SyncProject(...)` labels.

```json
{
  "type": "project.synced",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null,
    "project": {
      "id": "client"
      // ...
    },
    "runtime": {
      "toolchain": "Node",
      "version": "18.0.0"
    }
  },
  "uuid": "..."
}
```

### `tool.installing`

Triggered when a tool within the toolchain has started downloading and installing.

This event is _always_ triggered, regardless of whether the tool has already been installed or not.
For an accurate state, use the [`action.finished`](#actionfinished) event. If the `status` is
"skipped", then the tool was already installed.

```json
{
  "type": "tool.installing",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "runtime": {
      "toolchain": "Node",
      "version": "18.0.0"
    }
  },
  "uuid": "..."
}
```

### `tool.installed`

Triggered when a tool within the toolchain has finished installing. If the install failed, the
`error` field will be set with the error message.

For more information about the action, refer to the [`action.finished`](#actionfinished) event.
Tools can be scoped with the `SetupToolchain(...)` labels.

```json
{
  "type": "tool.installed",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null,
    "runtime": {
      "toolchain": "Node",
      "version": "18.0.0"
    }
  },
  "uuid": "..."
}
```

### `toolchain.installing`

Triggered when a toolchain plugin has started downloading and installing.

This event is _always_ triggered, regardless of whether the tool has already been installed or not.
For an accurate state, use the [`action.finished`](#actionfinished) event. If the `status` is
"skipped", then the tool was already installed.

```json
{
  "type": "toolchain.installing",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "spec": {
      "id": "node",
      "req": "18.0.0"
    }
  },
  "uuid": "..."
}
```

### `toolchain.installed`

Triggered when a toolchain plugin has finished installing. If the install failed, the `error` field
will be set with the error message.

For more information about the action, refer to the [`action.finished`](#actionfinished) event.
Tools can be scoped with the `SetupToolchain(...)` labels.

```json
{
  "type": "toolchain.installed",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null,
    "spec": {
      "id": "node",
      "req": "18.0.0"
    }
  },
  "uuid": "..."
}
```

### `task.running`

Triggered when a [task](../concepts/task) has started to run (via [`moon run`](../commands/run) or
similar command).

```json
{
  "type": "task.running",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "target": "app:build"
  },
  "uuid": "..."
}
```

### `task.ran`

Triggered when a [task](../concepts/task) has finished running. If the run failed, the `error` field
will be set with the error message.

For more information about the action, refer to the [`action.finished`](#actionfinished) event. Ran
tasks can be scoped with the `RunTask(...)`, `RunInteractiveTask(...)`, and `RunPersistentTask(...)`
labels.

```json
{
  "type": "task.ran",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null,
    "target": "app:build"
  },
  "uuid": "..."
}
```

### `workspace.syncing`

Triggered when the workspace is being synced.

```json
{
  "type": "workspace.syncing",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "target": "app:build"
  },
  "uuid": "..."
}
```

### `workspace.synced`

Triggered when the workspace has finished syncing. If the action failed, the `error` field will be
set with the error message.

```json
{
  "type": "workspace.synced",
  "createdAt": "...",
  "environment": "...",
  "event": {
    "error": null
  },
  "uuid": "..."
}
```

---

## Action graph

import ActionGraph from '@site/src/components/Docs/ActionGraph';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

When you run a [task](../config/project#tasks-1) on the command line, we generate an action graph to
ensure [dependencies](../config/project#deps) of tasks have ran before running run the primary task.

The action graph is a representation of all [tasks](../concepts/task), derived from the
[project graph](./project-graph) and [task graph](./task-graph), and is also represented internally
as a directed acyclic graph (DAG).

## Actions

Unlike other task runners in the industry that represent each node in the graph as a task to run, we
represent each node in the graph as an action to perform. This allows us to be more flexible and
efficient with how we run tasks, and allows us to provide more functionality and automation than
other runners.

The following actions compose our action graph:

### Sync workspace

This is a common action that always runs and give's moon a chance to perform operations and health
checks across the entire workspace.

:::info

This action can be skipped by disabling the
[`pipeline.syncWorkspace`](../config/workspace#syncworkspace) setting.

:::

### Setup toolchain

The most important action in the graph is the setup toolchain action, which downloads and installs a
tier 3 language into the toolchain. For other tiers, this is basically a no-operation.

- When the tool has already been installed, this action will be skipped.
- Actions will be scoped by language and version, also known as a runtime. For example,
  `SetupToolchain(node:18.1.0)` or `SetupToolchain(deno:1.31.0)`.
- Tools that require a global binary (found on `PATH`) will display the version as "global". For
  example, `SetupToolchain(node:global)`.

:::info

This action can be skipped by setting the `MOON_SKIP_SETUP_TOOLCHAIN=true` environment variable. The
skip can be scoped per tool by setting the value to the tool name (`node`), and also by version
(`node:20.0.0`). Supports a comma-separated list.

:::

### Setup environment

This action runs after the toolchain has been setup, but before dependencies are installed, so that
the development environment can be setup and configured. This includes operations such as modifying
a manifest (`package.json`, etc), updating configuration files, initializing venv's (Python), so on
and so forth.

### Setup proto

This action runs before all toolchain related actions and ensures that [proto](/proto) has been
installed and is available for use. This is required for toolchains that will be downloaded and
installed.

### Install dependencies

Before we run a task, we ensure that all language dependencies (`node_modules` for example) have
been installed, by automatically installing them if we detect changes since the last run. We achieve
this by comparing lockfile modified timestamps, parsing manifest files, and hashing resolved
dependency versions.

- When dependencies do _not_ need to be installed, this action will be skipped.
- Depending on the language and configuration, we may install dependencies in a project
  (`InstallProjectDeps`), or in the workspace root for all projects (`InstallWorkspaceDeps`).
- Actions will be scoped by language and version, also known as a runtime. For example,
  `InstallWorkspaceDeps(node:18.1.0)` or `InstallProjectDeps(node:18.1.0, example)`.

:::info

This action can be skipped by disabling the
[`pipeline.installDependencies`](../config/workspace#installdependencies) setting.

:::

### Sync project

To ensure a consistently healthy project and repository, we run a process known as syncing
_everytime_ a task is ran. This action will run sync operations for all toolchains associated with
the project.

:::info

This action can be skipped by disabling the
[`pipeline.syncProject`](../config/workspace#syncproject) setting.

:::

### Run task

The primary action in the graph is the run [task](../concepts/task) action, which runs a project's
task as a child process, derived from a [target](../concepts/target). Tasks can depend on other
tasks, and they'll be effectively orchestrated and executed by running in topological order using a
thread pool.

### Run interactive task

Like the base run task, but runs the [task interactively](../concepts/task#interactive) with stdin
capabilities. All interactive tasks are run in isolation in the graph.

### Run persistent task

Like the base run task, but runs the [task in a persistent process](../concepts/task#persistent)
that never exits. All persistent tasks are run in parallel as the last batch in the graph.

## What is the graph used for?

Without the action graph, tasks would not efficiently run, or possibly at all! The graph helps to
run tasks in parallel, in the correct order, and to ensure a reliable outcome.

---

## Languages

import LangGraph from '@site/src/components/Docs/LangGraph';

Although moon is currently focusing on the JavaScript ecosystem, our long-term vision is to be a
multi-language task runner and monorepo management tool. To that end, we've designed our languages
to work like plugins, where their functionality is implemented in isolation, and is _opt-in_.

:::info

We do not support third-party language plugins at this time, but are working towards it!

:::

## Enabling a language

moon [supported languages](../#supported-languages) are opt-in, and _are not_ enabled by default. We
chose this pattern to avoid unnecessary overhead, especially for the future when we have 10 or more
built-in languages.

To enable a supported language, simply define a configuration block with the language's name in
[`.moon/toolchain.yml`](../config/toolchain). Even an empty block will enable the language.

```yaml title=".moon/toolchain.yml"
# Enable Node.js
node: {}

# Enable Node.js with custom settings
node:
  packageManager: 'pnpm'

# Enable Deno
deno: {}
```

> For unsupported languages, use the system toolchain. Continue reading to learn more!

## System language and toolchain

When working with moon, you'll most likely have tasks that run built-in system commands that do not
belong to any of the supported languages. For example, you may have a task that runs `git` or
`docker` commands, or common commands like `rm`, `cp`, `mv`, etc.

For these cases, moon provides a special language/toolchain called `system`, that is always enabled.
This toolchain is a catch-all, an escape-hatch, a fallback, and provides the following:

- Runs a system command or a binary found on `PATH`.
- Wraps the execution in a shell.

To run system commands, set a task's [`toolchain`](../config/project#toolchain) setting to "system".

```yaml title="moon.yml"
tasks:
  example:
    command: 'git status'
    toolchain: 'system'
```

## Tier structure and responsibilities

As mentioned in our introduction,
[language support is divided up into tiers](../#supported-languages), where each tier introduces
more internal integrations and automations, but requires more work to properly implement.

Internally each tier maps to a Rust crate, as demonstrated by the graph at the top of the article.

### Tier 0 = Unsupported

The zero tier represents all languages _not directly_ supported by moon. This tier merely exists as
a mechanism for running non-supported language binaries via the
[system toolchain](#system-language-and-toolchain).

```yaml title="moon.yml"
tasks:
  example:
    command: 'ruby'
    toolchain: 'system'
```

### Tier 1 = Language

The first tier is the language itself. This is the most basic level of support, and is the only tier
that is required to be implemented for a language to be considered minimally supported. This tier is
in charge of:

- Declaring metadata about the language. For example, the name of the binary, supported file
  extensions, available dependency/package/version managers, names of config/manifest/lock files,
  etc.
- Helpers for parsing lockfiles and manifest files, and interacting with the language's ecosystem
  (for example, Node.js module resolution).
- Mechanisms for detecting the language of a project based on config files and other criteria.
- Maps to a project's [`language`](../config/project#language) setting.

```yaml title="moon.yml"
language: 'javascript'
```

### Tier 2 = Platform

The second tier requires the language functionality from tier 1, and eventually the toolchain
functionality from tier 3, and provides interoperability with moon's internals. This is the most
complex of all tiers, and the tier is in charge of:

- Determining when, where, and how to install dependencies for a project or the workspace.
- Loading project aliases and inferring implicit relationships between projects.
- Syncing a project and ensuring a healthy project state.
- Hashing efficiently for dependency installs and target runs.
- Prepending `PATH` with appropriate lookups to execute a task.
- Running a target's command with proper arguments, environment variables, and flags.
- Maps to a project's [`toolchain.default`](../config/project#toolchain-1) or task's
  [`toolchain`](../config/project#toolchain) setting.
- Supports a configuration block by name in [`.moon/toolchain.yml`](../config/toolchain).

```yaml title="moon.yml"
tasks:
  example:
    command: 'webpack'
    toolchain: 'node'
```

```yaml title=".moon/toolchain.yml"
node: {}
```

### Tier 3 = Toolchain

The third tier is toolchain support via [proto](/proto). This is the final tier, as the toolchain is
unusable unless the platform has been entirely integrated, and as such, the platform depends on this
tier. This tier handles:

- Downloading and installing a language into the toolchain.
- Installing and deduping project dependencies.
- Detecting appropriate versions of tools to use.
- Determining which binary to use and execute targets with.
- Supports a `version` field in the named configuration block in
  [`.moon/toolchain.yml`](../config/toolchain).

```yaml title=".moon/toolchain.yml"
node:
  version: '18.0.0'
```

---

## Project graph

import ProjectGraph from '@site/src/components/Docs/ProjectGraph';

The project graph is a representation of all configured
[projects in the workspace](../config/workspace#projects) and their relationships between each
other, and is represented internally as a directed acyclic graph (DAG). Below is a visual
representation of a project graph, composed of multiple applications and libraries, where both
project types depend on libraries.

:::info

The [`moon project-graph`](../commands/project-graph) command can be used to view the structure of
your workspace.

:::

## Relationships

A relationship is between a dependent (downstream project) and a dependency/requirement (upstream
project). Relationships are derived from source code and configuration files within the repository,
and fall into 1 of 2 categories:

### Explicit

These are dependencies that are explicitly defined in a project's [`moon.yml`](../config/project)
config file, using the [`dependsOn`](../config/project#dependson) setting.

```yaml title="moon.yml"
dependsOn:
  - 'components'
  - id: 'utils'
    scope: 'peer'
```

### Implicit

These are dependencies that are implicitly discovered by moon when scanning the repository. How an
implicit dependency is discovered is based on a
[language's platform integration](./languages#tier-2--platform), and how that language's ecosystem
functions.

```json title="package.json"
{
  // ...
  "dependencies": {
    "@company/components": "workspace:*"
  },
  "peerDependencies": {
    "@company/utils": "workspace:*"
  }
}
```

:::caution

If a language is not officially supported by moon, then implicit dependencies will _not_ be
resolved. For unsupported languages, you must explicitly configure dependencies.

:::

### Scopes

Every relationship is categorized into a scope that describes the type of relationship between the
parent and child. Scopes are currently used for [project syncing](../commands/sync) and deep Docker
integration.

- **Production** - Dependency is required in production, _will not be_ pruned in production
  environments, and will sync as a production dependency.
- **Development** - Dependency is required in development and production, _will be_ pruned from
  production environments, and will sync as a development-only dependency.
- **Build** - Dependency is required for building only, and will sync as a build dependency.
- **Peer** - Dependency is a peer requirement, with language specific semantics. Will sync as a peer
  dependency when applicable.

## What is the graph used for?

Great question, the project graph is used throughout the codebase to accomplish a variety of
functions, but mainly:

- Is fed into the [task graph](./task-graph) to determine relationships of tasks between other
  tasks, and across projects.
- Powers our [Docker](../guides/docker) layer caching and scaffolding implementations.
- Utilized for [project syncing](../commands/sync) to ensure a healthy repository state.
- Determines affected projects in [continuous integration](../guides/ci) workflows.

---

## Task graph

import TaskGraph from '@site/src/components/Docs/TaskGraph';

The task graph is a representation of all configured
[tasks in the workspace](../config/workspace#projects) and their relationships between each other,
and is represented internally as a directed acyclic graph (DAG). This graph is derived from
information in the [project graph](./project-graph). Below is a visual representation of a task
graph.

:::info

The [`moon task-graph`](../commands/task-graph) command can be used to view the structure of your
workspace.

:::

## Relationships

A relationship is between a dependent (downstream task) and a dependency/requirement (upstream
task). Relationships are derived explicitly with the task [`deps`](../config/project#deps) setting,
and fall into 1 of 2 categories:

### Required

These are dependencies that are required to run and complete with a success, before the owning task
can run. If a required dependency fails, then the owning task will abort.

### Optional

The opposite of [required](#required), these are dependencies that can either a) not exist during
task inheritance, or b) run and fail without aborting the owning task.

## What is the graph used for?

Great question, the task graph is extremely important for running tasks (duh), and it also:

- Is fed into the [action graph](./action-graph) that can be executed in topological order.
- Determines affected tasks in [continuous integration](../guides/ci) workflows.

---

## Install moon

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';
import AddDepsTabs from '@site/src/components/AddDepsTabs';

The following guide can be used to install moon and integrate it into an existing repository (with
or without incremental adoption), or to a fresh repository.

## Installing

The entirety of moon is packaged and shipped as a single binary. It works on all major operating
systems, and does not require any external dependencies. For convenience, we provide the following
scripts to download and install moon.

### proto

moon can be installed and managed in [proto's toolchain](/proto). This will install moon to
`~/.proto/tools/moon` and make the binary available at `~/.proto/bin`.

```shell
proto install moon
```

Furthermore, the version of moon can be pinned on a per-project basis using the
[`.prototools` config file](/docs/proto/config).

```toml title=".prototools"
moon = "1.31.0"
```

:::info

We suggest using proto to manage moon (and other tools), as it allows for multiple versions to be
installed and used. The other installation options only allow for a single version (typically the
last installed).

:::

### Linux, macOS, WSL

In a terminal that supports Bash, run:

```shell
bash 

If you are installing with Bun, you'll need to add `@moonrepo/cli` as a
[trusted dependency](https://bun.sh/docs/install/lifecycle#trusteddependencies).

:::info

When a global `moon` binary is executed, and the `@moonrepo/cli` binary exists within the
repository, the npm package version will be executed instead. We do this because the npm package
denotes the exact version the repository is pinned it.

:::

### Other

moon can also be downloaded and installed manually, by downloading an asset from
[https://github.com/moonrepo/moon/releases](https://github.com/moonrepo/moon/releases). Be sure to
rename the file after downloading, and apply the executable bit (`chmod +x`) on macOS and Linux.

## Upgrading

If using proto, moon can be upgraded using the following command:

```shell
proto install moon --pin
```

Otherwise, moon can be upgraded with the [`moon upgrade`](./commands/upgrade) command. However, this
will only upgrade moon if it was installed in `~/.moon/bin`.

```shell
moon upgrade
```

Otherwise, you can re-run the installers above and it will download, install, and overwrite with the
latest version.

## Canary releases

moon supports canary releases, which are built and published for every commit to our development
branches. These releases will include features and functionality that have not yet landed on master.
When using a canary release, you'll need to download and execute the binaries manually:

- Using our npm package
  [`@moonrepo/cli`](https://www.npmjs.com/package/@moonrepo/cli?activeTab=versions) under the
  `canary` tag. Releases are versioned by date.
- From a [GitHub prerelease](https://github.com/moonrepo/moon/releases/tag/canary) using the
  `canary` tag. This tag always represents the latest development release.

## Nightly releases

moon supports nightly releases, which are built and published once a day from the latest commit on
master. When using a nightly release, you'll need to download and execute the binaries manually.

- Using our npm package
  [`@moonrepo/cli`](https://www.npmjs.com/package/@moonrepo/cli?activeTab=versions) under the
  `nightly` tag. Releases are versioned by date.
- From a [GitHub prerelease](https://github.com/moonrepo/moon/releases/tag/nightly) using the
  `nightly` tag. This tag always represents the latest stable release.

## Next steps

---

## Introduction

import FeatureStatus from '@site/src/components/FeatureStatus';
import Label from '@site/src/ui/typography/Label';

moonrepo is a productivity platform that aims to eliminate pain points for both developers and
companies, by automating tiresome and complex workflows, and improving the overall developer
experience.

We currently achieve this through the following tools and services:

## moon

[moon](/moon) is a repository *m*anagement, *o*rganization, *o*rchestration, and *n*otification tool
for the web ecosystem, written in Rust. Many of the concepts within moon are heavily inspired from
Bazel and other popular build systems, but tailored for our
[supported languages](#supported-languages).

You can think of a moon as a tool that sits firmly in the middle between Bazel (high complexity,
full structure), and make/just/etc scripts (low complexity, no structure).

### Why use moon?

Working in a language's ecosystem can be very involved, especially when it comes to managing a
repository effectively. Which language version to use? Which dependency manager to use? How to use
packages? Or how to build packages? So on and so forth. moon aims to streamline this entire process
and provide a first-class developer experience.

- **Increased productivity** - With [Rust](https://www.rust-lang.org/) as our foundation, we can
  ensure robust speeds, high performance, and low memory usage. Instead of long builds blocking you,
  focus on your work.
- **Exceptional developer experience** - As veterans of developer tooling, we're well aware of the
  pain points and frustrations. Our goal is to mitigate and overcome these obstacles.
- **Incremental adoption** - At its core, moon has been designed to be adopted incrementally and is
  _not_ an "all at once adoption". Migrate project-by-project, or task-by-task, it's up to you!
- **Reduced tasks confusion** - Tasks (for example, `package.json` scripts) can become unwieldy,
  very quickly. No more duplicating the same task into every project, or reverse-engineering which
  root scripts to use. With moon, all you need to know is the project name, and a task name.
- **Ensure correct versions** - Whether it's a programming language or dependency manager, ensure
  the same version of each tool is the same across _every_ developer's environment. No more wasted
  hours of debugging.
- **Automation built-in** - When applicable, moon will automatically install dependencies
  (`node_modules`), or
  [sync project dependencies](/docs/config/toolchain#syncprojectworkspacedependencies), or even
  [sync TypeScript project references](/docs/config/toolchain#syncprojectreferences).
- And of course, the amazing list of [features](#features) below!

### Supported languages

moon's long-term vision is to robustly support multiple programming languages (and dependency
managers) so that a repository composed of projects with differing languages and tools can all work
in unison. This is a lofty vision that requires a massive amount of time and resources to achieve,
and as such, is not available on initial release, but will gradually be supported over time.

To help achieve this vision, language support is broken down into 4 tiers, allowing us to
incrementally integrate and improve them over time. The 4 tiers are as follows:

- &nbsp; &nbsp; **No direct integration** - Tool is not
  directly supported in moon, but can still be ran using the
  ["system" task toolchain](/docs/faq#can-we-run-other-languages), which expects the tool to exist
  in the current environment.
- &nbsp; &nbsp; **Project categorization** - Projects can
  configure their primary [language in `moon.yml`](/docs/config/project#language), and have a
  dedicated Rust crate for metadata.
- &nbsp; &nbsp; **Ecosystem platformization** - moon deeply
  integrates with the language's ecosystem by parsing manifests, lockfiles, and other semantic files
  to infer dependencies, tasks, and other necessary information.
- &nbsp; &nbsp; **Toolchain integration** - Language is
  directly supported in the toolchain, configured in
  [`.moon/toolchain.yml`](/docs/config/toolchain), and will automatically be downloaded and
  installed.

|                               | Tier 0 | Tier 1 | Tier 2 | Tier 3 |
| :---------------------------- | :----: | :----: | :----: | :----: |
| Bash/Batch                    |   🟢   |   🟢   |        |        |
| Bun (JavaScript, TypeScript)  |   🟢   |   🟢   |   🟢   |   🟢   |
| Deno (JavaScript, TypeScript) |   🟢   |   🟢   |   🟣   |   🟣   |
| Go                            |   🟢   |   🟢   |   🟢   |   🟢   |
| Node (JavaScript, TypeScript) |   🟢   |   🟢   |   🟢   |   🟢   |
| └─ npm, pnpm, yarn            |   🟢   |   ⚪️   |   🟢   |   🟢   |
| PHP                           |   🟢   |   🟢   |        |        |
| └─ Composer                   |   🟢   |   ⚪️   |        |        |
| Python                        |   🟢   |   🟢   |   🟣   |   🟣   |
| └─ Pip                        |   🟢   |   ⚪️   |   🟣   |        |
| Ruby                          |   🟢   |   🟢   |        |        |
| └─ Gems, Bundler              |   🟢   |   ⚪️   |        |        |
| Rust                          |   🟢   |   🟢   |   🟢   |   🟢   |
| └─ Cargo                      |   🟢   |   ⚪️   |   🟣   |   🟣   |
| Other (Kotlin, Java, C#, ...) |   🟢   |        |        |        |

- ⚪️ Not applicable
- 🟣 Partially supported (experimental)
- 🟢 Fully Supported

### Supported targets

Because moon is written in Rust, we only support targets that are explicitly compiled for, which are
currently:

| Operating system | Architecture | Target                       |
| :--------------- | :----------- | :--------------------------- |
| macOS 64-bit     | Intel        | `x86_64-apple-darwin`        |
| macOS 64-bit     | ARM          | `aarch64-apple-darwin`       |
| Linux 64-bit     | Intel GNU    | `x86_64-unknown-linux-gnu`   |
| Linux 64-bit     | Intel musl   | `x86_64-unknown-linux-musl`  |
| Linux 64-bit     | ARM GNU      | `aarch64-unknown-linux-gnu`  |
| Linux 64-bit     | ARM musl     | `aarch64-unknown-linux-musl` |
| Windows 64-bit   | Intel        | `x86_64-pc-windows-msvc`     |

### Features

#### Management

- **Smart hashing** - Collects inputs from multiple sources to ensure builds are deterministic and
  reproducible.
- **Remote caching** - Persists builds, hashes, and caches between teammates and CI/CD environments.
- **Integrated toolchain** - Automatically downloads and installs explicit versions of Node.js and
  other tools for consistency across the entire workspace or per project.
- **Multi-platform** - Runs on common development platforms: Linux, macOS, and Windows.

#### Organization

- **Project graph** - Generates a project graph for dependency and dependent relationships.
- **Code generation** - Easily scaffold new applications, libraries, tooling, and more!
- **Dependency workspaces** - Works alongside package manager workspaces so that projects have
  distinct dependency trees.
- **Code ownership** - Declare owners, maintainers, support channels, and more. Generate CODEOWNERS.

#### Orchestration

- **Dependency graph** - Generates a dependency graph to increase performance and reduce workloads.
- **Action pipeline** - Executes actions in parallel and in order using a thread pool and our
  dependency graph.
- **Action distribution**  - Distributes actions across
  multiple machines to increase throughput.
- **Incremental builds** - With our smart hashing, only rebuild projects that have been touched
  since the last build.

#### Notification

- **Flakiness detection** - Reduce flaky builds with automatic retries and passthrough settings.
- **Webhook events**  - Receive a webhook for every event in
  the pipeline. Useful for metrics gathering and insights.
- **Terminal notifications**  - Receives notifications in
  your chosen terminal when builds are successful... or are not.
- **Git hooks** - Manage Git hooks to enforce workflows and requirements for contributors.

## proto

[proto](/proto) is a version manager for your favorite programming languages.
[View proto documentation](/docs/proto).

---

## Migrate to moon

import NextSteps from '@site/src/components/NextSteps';
import LangPartials from '@site/src/components/LangPartials';

Now that we've talked about the workspace, projects, tasks, and more, we must talk about something
important... Should you embrace moon tasks? Or keep using language/ecosystem specific scripts? Or
both (incremental adoption)?

## Migrate to moon tasks

We suggest using moon tasks (of course), as they provide far more granular control and configurable
options than scripts, and a `moon.yml` is a better
[source of truth](./faq#what-should-be-considered-the-source-of-truth). Scripts aren't powerful
enough to scale for large codebases.

An example of what this may look like can be found below. This _may_ look like a lot, but it pays
dividends in the long run.

import MigrateBun from './__partials__/migrate/bun/migrate.mdx';
import MigrateDeno from './__partials__/migrate/deno/migrate.mdx';
import MigrateGo from './__partials__/migrate/go/migrate.mdx';
import MigrateNode from './__partials__/migrate/node/migrate.mdx';
import MigratePHP from './__partials__/migrate/php/migrate.mdx';
import MigratePython from './__partials__/migrate/python/migrate.mdx';
import MigrateRuby from './__partials__/migrate/ruby/migrate.mdx';
import MigrateRust from './__partials__/migrate/rust/migrate.mdx';

  
  
  
  
  
  
  
  

## Continue using scripts

import ScriptsBun from './__partials__/migrate/bun/scripts.mdx';
import ScriptsDeno from './__partials__/migrate/deno/scripts.mdx';
import ScriptsGo from './__partials__/migrate/go/scripts.mdx';
import ScriptsNode from './__partials__/migrate/node/scripts.mdx';
import ScriptsPHP from './__partials__/migrate/php/scripts.mdx';
import ScriptsPython from './__partials__/migrate/python/scripts.mdx';
import ScriptsRuby from './__partials__/migrate/ruby/scripts.mdx';
import ScriptsRust from './__partials__/migrate/rust/scripts.mdx';

  
  
  
  
  
  
  
  

## Next steps

By this point, you should have a better understanding behind moon's fundamentals! Why not adopt
incrementally next? Jump into [guides](./guides/ci) for advanced use cases or [concepts](./concepts)
for a deeper understanding.

---

## activate

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto activate ` command will activate proto for the current shell session, by exporting
environment variables and prepending `PATH` for each tool configured in the current directory.
Activation is ran each time the current directory changes using a shell hook.

:::info

Learn more about
[shell activation in the official workflow documentation](../workflows#shell-activation)!

:::

### Arguments

- `` - The shell to activate for.

### Options

- `--export` - Print the activate instructions in shell-specific syntax.
- `--json` - Print the activate instructions in JSON format.
- `--no-bin` - Do not include `~/.proto/bin` when appending `PATH`.
- `--no-shim` - Do not include `~/.proto/shims` when prepending `PATH`.
- `--no-init` - Do not trigger activation when initialized in the shell, and instead wait for a
  cd/prompt change. 

### Caveats

- Only tools that have a [version configured in `.prototools`](../config#pinning-versions) will be
  activated.
- Tool versions configured in the global `~/.proto/.prototools` are _not_ included by default. Pass
  `--config-mode all` during activation to include them.
  - Do note that this will worsen performance depending on the number of tools.

### Setup

The following activation steps should be added _after_ all environment variable and `PATH`
modifications have happened in your shell, typically at the end of your shell profile.

#### Bash

Add the following line to the end of your `~/.bashrc` or `~/.bash_profile`.

```shell
eval "$(proto activate bash)"
```

#### Elvish

Generate the hook:

```shell
proto activate elvish > ~/.elvish/lib/proto-hook.elv
```

Then add the following line to your `~/.elvish/rc.elv` file.

```shell
use proto-hook
```

#### Fish

Add the following line to the end of your `~/.config/fish/config.fish`.

```shell
proto activate fish | source
```

#### Murex

Add the following line to the end of your `~/.murex_profile`.

```shell
proto activate murex -> source
```

#### Nu

Generate the hook:

```shell
(proto activate nu) | save ~/.config/nushell/proto-hook.nu
```

Then add the following line to your `~/.config/nushell/config.nu` file.

```shell
use proto-hook.nu
```

#### Pwsh

Add the following line to the end of your profile (`$PROFILE`).

```shell
proto activate pwsh | Out-String | Invoke-Expression
```

#### Zsh

Add the following line to the end of your `~/.zshrc`.

```shell
eval "$(proto activate zsh)"
```

---

## alias

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto alias   ` (or `proto a`) command will define a custom alias that
maps to a specific version for the provided tool. Aliases can be used anywhere a version is
accepted.

```shell
$ proto alias node work 16.16
```

By default this will update the local [`./.prototools`](../config) file. Pass `--to` to customize
the location.

### Arguments

- `` - Type of tool.
- `` - Name of the alias. Supports alphanumeric chars.
- `` - Version to map to the alias.

## Options

- `--to` - [Location of `.prototools`](../config#locations) to update. Supports `global`, `local`,
  and `user`.

---

## bin

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto bin  [version]` command will return an absolute path to a tool's binary within the
toolchain. When a tool has not been installed, or a version cannot be resolved, the command will
exit with a failure.

```shell
$ proto bin node 16.10.0
/Users/example/.proto/tools/node/16.10.0/bin/node
```

This command can also return directories using the `--dir` option.

```shell
$ proto bin node 16.10.0 --dir exes
/Users/example/.proto/tools/node/16.10.0/bin

$ proto bin node 16.10.0 --dir globals
/Users/example/.proto/tools/node/globals/bin
```

### Arguments

- `` - Type of tool.
- `[version]` - Version of tool. If not provided, will attempt to
  [detect the version](../detection).

### Options

- `--all` - Return multiple paths, separated by newlines, instead of the first path.
  
- `--dir ` - Return a directory instead of of the main file. 
  - `exes` - Returns the executable's directory.
  - `globals` - Returns the globals/packages directory.
- `--bin` - When applicable, return the `~/.proto/bin` path.
- `--shim` - When applicable, return the `~/.proto/shims` path.

---

## clean

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto clean` command can be used to uninstall stale and unused tools, plugins, and more. By
default, it will remove items that haven't been used in the last 30 days.

```shell
$ proto clean
```

Furthermore, the command can be used to target a specific artifact type.

```shell
$ proto clean plugins
```

### Arguments

- `[target]` - Type of target. Accepts `cache`, `plugins`, `temp`, or `tools`.
  

### Options

- `--days` - Number of days before a tool is considered stale.
- `--json` - Print the clean result in JSON format. 
- `--yes` - Avoid and confirm all prompts.

---

## completions

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The `proto completions` command will generate proto command and argument completions for your
current shell. This command will write to stdout, which can then be redirected to a file of your
choice.

```shell
$ proto completions > ./path/to/write/to
```

### Options

- `--shell` - Shell to explicitly generate for.

### Examples

If using [bash-completion](https://github.com/scop/bash-completion).

```shell
mkdir -p ~/.bash_completion.d
proto completions > ~/.bash_completion.d/proto.sh
```

Otherwise write the file to a common location, and source it in your profile.

```shell
mkdir -p ~/.bash_completions
proto completions > ~/.bash_completions/proto.sh

# In your profile
source ~/.bash_completions/proto.sh
```

Write the file to Fish's completions directory.

```shell
mkdir -p ~/.config/fish/completions
proto completions > ~/.config/fish/completions/proto.fish
```

If using [oh-my-zsh](https://ohmyz.sh/) (the `_` prefix is required).

```shell
mkdir -p ~/.oh-my-zsh/completions
proto completions > ~/.oh-my-zsh/completions/_proto

# Reload shell (or restart terminal)
omz reload
```

---

## debug config

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto debug config` command will list all `.prototools` configuration files (in TOML format)
that have been loaded, in order of precedence, with the final merged configuration printed at the
end.

```
$ proto debug config

/Users/name/.proto/.prototools ───────────────────────────────────────────

  node = "20.0.0"
  npm = "bundled"

  [tools.node.aliases]
  stable = "~20"

  [settings]
  auto-clean = false

Final configuration ───────────────────────────────────────────────────────

  node = "20.0.0"
  npm = "bundled"

  [tools.node.aliases]
  stable = "~20"

  [plugins]
  node = "https://github.com/moonrepo/node-plugin/releases/download/v0.6.1/node_plugin.wasm"

  [settings]
  auto-clean = false
  auto-install = false
  detect-strategy = "first-available"

  [settings.http]
  allow-invalid-certs = false
  proxies = []
```

### Options

- `--json` - Print the list in JSON format.

---

## debug env

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto debug env` command will print information about your current proto environment. Primarily
the store location, relevant file paths, and environment variables.

```
$ proto debug env

Store ─────────────────────────────────────────────────────────────────────

  Root: /Users/name/.proto
  Bins: /Users/name/.proto/bin
  Shims: /Users/name/.proto/shims
  Plugins: /Users/name/.proto/plugins
  Tools: /Users/name/.proto/tools
  Temp: /Users/name/.proto/temp

Environment ───────────────────────────────────────────────────────────────

  Proto version: 0.44.0
  Operating system: macos
  Architecture: arm64
  Config sources:
    - /Users/name/Projects/example/.prototools
    - /Users/name/.proto/.prototools
  Virtual paths:
    /userhome = /Users/name
    /proto = /Users/name/.proto
    /cwd = /Users/name/Projects/example
  Environment variables:
    PROTO_APP_LOG = proto=info,schematic=info,starbase=info,warpgate=info,extism::pdk=info
    PROTO_HOME = /Users/name/.proto
    PROTO_OFFLINE_TIMEOUT = 750
    PROTO_VERSION = 0.44.0
```

### Options

- `--json` - Print the list in JSON format.

---

## diagnose

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto diagnose` command will diagnose your proto installation for any potential issues. Issues
are categorized into errors and warnings, with the former being a must fix, and the latter being a
maybe fix (depending on your usage of proto).

```
$ proto diagnose

Shell: zsh
Shell profile: /Users/name/.zshrc

Errors ────────────────────────────────────────────────────────────────────

  - Issue: Bin directory /Users/name/.proto/bin was found BEFORE the shims directory /Users/name/.proto/shims on PATH
    Resolution: Ensure the shims path comes before the bin path in your shell
    Comment: Runtime version detection will not work correctly unless shims are used
```

### Options

- `--shell` - The shell to diagnose (will detect automatically).
- `--json` - Print the diagnosis in JSON format.

---

## install

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto install` (or `proto i`) command can be used to install one or many tools.

### Installing all tools

The `proto install` command (without arguments) will download and install _all_ tools and plugins
from all parent [`.prototools`](../config) configuration files, and any
[versions detected](../detection) in the current working directory (if not defined in
`.prototools`).

```shell
$ proto install
```

> By default, this command _does not_ install tools for versions pinned in the global
> `~/.proto/.prototools` file. Pass `--config-mode all` to include them.

### Installing one tool

The `proto install  [version]` command will download and install a single tool by unpacking
their archive to `~/.proto/tools/`. If the tool has already been installed, the command will
exit early.

The command is also smart enough to resolve partial versions, so 1, 1.2, and 1.2.3 are all
acceptable. It even supports aliases when applicable, like `latest`, `next`, `beta`, etc. To install
a canary release, use `canary`.

```shell
$ proto install deno
$ proto install deno 1.31
$ proto install deno canary
```

#### Pinning the version

By default this command will only install the tool into `~/.proto/tools` but will not make the
binary available. If you would like to also pin the resolved version to a `.prototools` file, use
the `--pin` option.

```shell
# ./.prototools
$ proto install bun --pin
$ proto install bun --pin local

# ~/.proto/.prototools
$ proto install bun --pin global

# ~/.prototools
$ proto install bun --pin user
```

### Handling plugin hooks

Some tools run [post-install hooks](../tools) that support arbitrary arguments that can be passed
after `--`.

```shell
$ proto install go -- --no-gobin
```

### Arguments

- One tool
  - `[tool]` - Type of tool.
  - `[version]` - Version of tool. Defaults to a pinned version in `.prototools` or "latest".
  - `[-- ]` - Additional arguments to pass to post-install hooks.

### Options

- `--force` - Force install, even if already installed.
- `--update-lockfile` - Don't inherit a version from the lockfile and update the existing record.
  
- One tool
  - `--build` - Build from source if available. 
  - `--no-build` - Download a pre-built if available. 
  - `--pin` - Pin the resolved version and create a symlink in `~/.proto/bin`. Accepts a boolean
    (pins locally by default), or the string "global", or the string "local".

---

## list-remote

:::danger

This command was removed in v0.44, use [`proto versions`](./versions) instead!

:::

The `proto list-remote ` (or `proto lsr`) command will list available versions by resolving
versions from the tool's remote release manifest.

```shell
$ proto list-remote node
...
18.10.0
18.11.0
18.12.0
18.12.1
18.13.0
18.14.0
18.14.1
18.14.2
19.0.0
19.0.1
19.1.0
19.2.0
19.3.0
19.4.0
19.5.0
19.6.0
19.6.1
19.7.0
```

### Arguments

- `` - Type of tool.

### Options

- `--aliases` - Include aliases in the list.

---

## list

:::danger

This command was removed in v0.44, use [`proto versions`](./versions) instead!

:::

The `proto list ` (or `proto ls`) command will list installed versions by scanning the
manifest at `~/.proto/tools//manifest.json` for possible versions.

```shell
$ proto list node
16.16.0
18.2.0
19.4.0
```

### Arguments

- `` - Type of tool.

### Options

- `--aliases` - Include aliases in the list.

---

## outdated

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto outdated` command will load all [`.prototools`](../config) files and check for newer
(matching configured range) and latest versions of each configured tool. Will also include the
configuration file in which the version has been configured.

```
$ proto outdated

╭───────────────────────────────────────────────────────────────────────╮
│ Tool      Current Newest  Latest  Config                              │
│───────────────────────────────────────────────────────────────────────│
│ bun       1.1.42  1.1.42  1.1.42  /Users/name/.proto/.prototools      │
│ node      23.5.0  23.5.0  23.5.0  /Users/name/.proto/.prototools      │
│ npm       10.7.0  10.7.0  11.0.0  /Users/name/.proto/.prototools      │
│ rust      1.83.0  1.83.0  1.83.0  /Users/name/.proto/.prototools      │
│ yarn      3.6.3   3.8.7   4.5.1   /Users/name/.proto/.prototools      │
╰───────────────────────────────────────────────────────────────────────╯
```

> By default, this command _does not_ check tools for versions pinned in the global
> `~/.proto/.prototools` file. Pass `--config-mode all` to include them.

### Options

- `--json` - Print the list in JSON format.
- `--latest` - When updating versions with `--update`, use the latest version instead of newest.
- `--update` - Update and write newest/latest versions to their respective configuration.
- `--yes` - Avoid and confirm all prompts.

---

## pin

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto pin  ` command will pin a version (or alias) of a tool. This version will
be used when attempting to [detect a version](../detection).

```shell
$ proto pin go 1.20
```

By default this will update the local [`./.prototools`](../config) file. Pass `--to` to customize
the location.

### Arguments

- `` - Type of tool.
- `` - Version of tool.

### Options

- `--resolve` - Resolve the version to a fully-qualified semantic version before pinning.
- `--to` - [Location of `.prototools`](../config#locations) to update. Supports `global`, `local`,
  and `user`.

---

## plugin add

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto plugin add  ` command will add the provided ID and plugin locator string to
the `[plugins]` section of a chosen `.prototools`.

```shell
$ proto plugin add node "https://github.com/moonrepo/node-plugin/releases/latest/download/node_plugin.wasm"
```

> Learn more about [plugin locator strings](../../plugins#enabling-plugins).

### Arguments

- `` - ID of the tool.
- `` - How to locate the plugin.

### Options

- `--to` - [Location of `.prototools`](../../config#locations) to update.

---

## plugin info

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto plugin info ` command will display information about a tool and its plugin.

```
$ proto plugin info node

Plugin ─────────────────────────────────

  ID: node
  Name: Node.js
  Type: Language
  Version: 0.13.0
  Source URL: https://github.com/moonrepo/plugins/releases/download/node_tool-v0.13.0/node_tool.wasm

Inventory ──────────────────────────────

  Detected version: 23.5.0
  Fallback version: 23.5.0
  Store directory: /Users/name/.proto/tools/node
  Executable file: /Users/name/.proto/tools/node/23.5.0/bin/node
  Executables directory: /Users/name/.proto/tools/node/23.5.0/bin
  Global packages directory: /Users/name/.proto/tools/node/globals/bin
  Shims:
    - /Users/name/.proto/shims/node
  Binaries:
    - /Users/name/.proto/bin/node
    - /Users/name/.proto/bin/node-20
    - /Users/name/.proto/bin/node-20.15
    - /Users/name/.proto/bin/node-20.8
    - /Users/name/.proto/bin/node-23
    - /Users/name/.proto/bin/node-23.4
    - /Users/name/.proto/bin/node-23.5
  Installed versions:
    20.8.0 - installed 12/19/24, last used 12/19/24
    20.15.0 - installed 12/25/24, last used 12/25/24
    23.4.0 - installed 12/19/24, last used 12/19/24
    23.5.0 - installed 12/25/24, last used 12/25/24, fallback version
  Remote aliases:
    argon = 4.9.1
    boron = 6.17.1
    carbon = 8.17.0
    dubnium = 10.24.1
    erbium = 12.22.12
    fermium = 14.21.3
    gallium = 16.20.2
    hydrogen = 18.20.5
    iron = 20.18.1
    jod = 22.12.0
    latest = 23.5.0
    stable = 22.12.0

Configuration ──────────────────────────

  Local aliases:
    example = 19.0.0
  Environment variables: —
  Settings: —
```

### Arguments

- `` - ID of tool.

### Options

- `--json` - Print the info in JSON format.

---

## plugin list

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto plugin list [...id]` command will list all available and configured plugins, for both
third-party and built-in tools. Will load all `./.prototools` traversing upwards, and the
`~/.proto/.prototools` file.

Furthermore, it can list tool information, along with their installed versions, relevant timestamps,
available aliases, and store location.

```
$ proto plugin list --versions

Bun ────────────────────────────────────

  ID: bun
  Source URL: https://github.com/moonrepo/plugins/releases/download/bun_tool-v0.14.0/bun_tool.wasm
  Store directory: /Users/miles/.proto/tools/bun
  Versions:
    1.1.42 - installed 12/25/24, fallback version

Deno ───────────────────────────────────

  ID: deno
  Source URL: https://github.com/moonrepo/plugins/releases/download/deno_tool-v0.13.0/deno_tool.wasm
  Store directory: /Users/miles/.proto/tools/deno
  Versions:
    1.30.0 - installed 02/01/24, last used 11/28/24
    1.40.0 - installed 02/01/24, last used 12/09/24
    1.43.1 - installed 12/25/24, fallback version

Go ─────────────────────────────────────

  ID: go
  Source URL: https://github.com/moonrepo/plugins/releases/download/go_tool-v0.14.0/go_tool.wasm
  Store directory: /Users/miles/.proto/tools/go
  Versions:
    1.18.0 - installed 12/25/24, fallback version
    1.19.0 - installed 12/22/24
    1.20.12 - installed 12/09/23
    1.23.4 - installed 12/24/24
```

A list of tool IDs can be provided to filter the output list.

```shell
$ proto plugin list node npm
```

### Arguments

- `[id...]` - IDs of tools.

### Options

- `--aliases` - Print the list with resolved aliases.
- `--versions` - Print the list with installed versions.
- `--json` - Print the list in JSON format.

---

## plugin remove

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto plugin remove ` command will remove the provided tool ID from the `[plugins]` section
of the chosen (`.prototools`).

```shell
$ proto plugin remove node
```

> Built-in plugins _cannot_ be removed!

### Arguments

- `` - ID of the tool.

### Options

- `--from` - [Location of `.prototools`](../../config#locations) to update.

---

## plugin search

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto plugin search ` command will search for plugins provided by the community, based
on the provided query string. Built-in plugins _are not_ searchable.

```
$ proto plugin search moon

Search results for: moon
Learn more about plugins: https://moonrepo.dev/docs/proto/plugins
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Plugin      Author    Format Description             Locator                                                             │
│──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────│
│ moon        moonrepo  TOML   moon is a multi-        https://raw.githubusercontent.com/moonrepo/moon/master/proto-       │
│                              language build system   plugin.toml                                                         │
│                              and codebase management                                                                     │
│                              tool.                                                                                       │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Arguments

- `` - Query string to match against.

### Options

- `--json` - Print the results in JSON format.

---

## regen

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto regen` command can be used to regenerate all shims in the `~/.proto/shims` directory.
This command will also clean the shims directory before regenerating, in an effort to remove
unexpected or broken shims.

```shell
$ proto regen
```

By default this will only regenerate shims. If you want to regenerate bins in `~/.proto/bin` as
well, pass the `--bin` flag. This will also clean the bins directory before regenerating.

```shell
$ proto regen --bin
```

> Only versions pinned in `~/.proto/.prototools` will be linked as bins.

## Options

- `--bin` - Also recreate `~/.proto/bin` symlinks.

---

## run

The `proto run  [version]` (or `proto r`) command will run a tool after
[detecting a version](../detection) from the environment.

```shell
# Run and detect version from environment
$ proto run bun

# Run with explicit version
$ proto run bun 0.5.3

# Run with version from environment variable
$ PROTO_BUN_VERSION=0.5.3 proto run bun
```

Arguments can be passed to the underlying tool binary by providing additional arguments after `--`.

```shell
$ proto run bun -- run ./script.ts

# When using the binary on PATH
$ bun run ./script.ts
```

### Arguments

- `` - Type of tool.
- `[version]` - Version of tool. If not provided, will attempt to detect the version from the
  environment.

---

## setup

The `proto setup` command will setup proto in your current shell by modifying an applicable profile
file and appending proto's bin directory to `PATH`. If a shell could not be detected, you'll be
prompted to select one.

```shell
$ proto setup
```

During setup, the following profiles will be searched or prompted for.

- Bash
  - `~/.bash_profile`
  - `~/.bashrc`
  - `~/.profile`
- Elvish
  - `~/.elvish/rc.elv`
  - `~/.config/elvish/rc.elv`
- Fish
  - `~/.config/fish/config.fish`
- Ion
  - `~/.config/ion/initrc`
- Murex
  - `~/.murex_preload`
  - `~/.murex_profile`
- Nu
  - `~/.config/nushell/env.nu`
  - `~/.config/nushell/config.nu`
- PowerShell
  - Windows
    - `~\Documents\PowerShell\Microsoft.PowerShell_profile.ps1`
    - `~\Documents\PowerShell\Profile.ps1`
  - Unix
    - `~/.config/powershell/Microsoft.PowerShell_profile.ps1`
    - `~/.config/powershell/profile.ps1`
- Xonsh
  - `~/.config/xonsh/rc.xsh`
  - `~/.xonshrc`
- Zsh
  - `~/.zprofile`
  - `~/.zshenv`
  - `~/.zshrc`

### Windows support

In addition to updating a shell profile file (most likely PowerShell), we'll also modify the `PATH`
(or `Path`) system environment variable, by prepending the `~/.proto/shims` and `~/.proto/bin`
paths.

If you would like to opt-out of this behavior, pass the `--no-modify-path` flag.

### Options

- `--shell` - Shell to explicitly setup for.
- `--no-modify-profile` / `PROTO_NO_MODIFY_PROFILE` - Don't update a shell profile file.
- `--no-modify-path` / `PROTO_NO_MODIFY_PATH` - Don't update the system `PATH` environment variable
  (Windows only).
- `--yes` - Avoid interactive prompts and use defaults.

---

## status

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto status` command will list all tools that are currently active for a target directory,
what versions of those tools are resolved to, and the configuration file in which they are defined.

```
$ proto status
╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Tool      Configured Resolved  Installed                           Config                             │
│───────────────────────────────────────────────────────────────────────────────────────────────────────│
│ bun       1.1.42     1.1.42    /Users/name/.proto/tools/          /Users/name/.proto/.prototools      │
│                                bun/1.1.42                                                             │
│ deno      1.43.1     1.43.1    /Users/name/.proto/tools/          /Users/name/.proto/.prototools      │
│                                deno/1.43.1                                                            │
│ node      23.5.0     23.5.0    /Users/name/.proto/tools/          /Users/name/.proto/.prototools      │
│                                node/23.5.0                                                            │
│ npm       ~10.7      10.7.0    /Users/name/.proto/tools/          /Users/name/.proto/.prototools      │
│                                npm/10.7.0                                                             │
│ python    3.12.0     3.12.0    /Users/name/.proto/tools/          /Users/name/.proto/.prototools      │
│                                python/3.12.0                                                          │
│ yarn      3.6.3      3.6.3     /Users/name/.proto/tools/          /Users/name/.proto/.prototools      │
│                                yarn/3.6.3                                                             │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯

```

> By default, this command _does not_ check tools for versions pinned in the global
> `~/.proto/.prototools` file. Pass `--config-mode all` to include them.

### Options

- `--json` - Print the list in JSON format.

---

## unalias

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto unalias  ` (or `proto ua`) command will remove a custom alias for the
provided tool.

```shell
$ proto unalias node work
```

By default this will update the local [`./.prototools`](../config) file. Pass `--from` to customize
the location.

### Arguments

- `` - Type of tool.
- `` - Name of the alias. Supports alphanumeric chars.

## Options

- `--from` - [Location of `.prototools`](../config#locations) to update. Supports `global`, `local`,
  and `user`.

---

## uninstall

The `proto uninstall  [version]` (or `proto ui`) command will uninstall and remove a tool from
`~/.proto/tools/`. If the tool has not been installed, the command will exit early.

```shell
# Remove a specific version
$ proto uninstall deno 1.31

# Remove all versions
$ proto uninstall deno
```

### Arguments

- `` - Type of tool.
- `[version]` - Version of tool.

---

## unpin

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto unpin ` command will unpin a version of a tool.

```shell
$ proto unpin go
```

By default this will update the local [`./.prototools`](../config) file. Pass `--from` to customize
the location.

### Arguments

- `` - Type of tool.

### Options

- `--from` - [Location of `.prototools`](../config#locations) to update. Supports `global`, `local`,
  and `user`.

---

## upgrade

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto upgrade` (or `proto up`) command can be used to upgrade your current proto binary to the
latest version, or check if you're currently outdated.

```shell
$ proto upgrade

# Up/downgrade to a specific version
$ proto upgrade 0.39.0
```

:::info

The previous binary will be moved to `~/.proto/tools/proto/`, while the new binary will be
installed to `~/.proto/bin`.

:::

### Arguments

- `` - The version of proto to explicitly upgrade or downgrade to.
  

### Options

- `--check` - Check if there's a new version without executing the upgrade.
- `--json` - Print the upgrade information as JSON.

---

## use

:::danger

This command has been deprecated and its functionality was merged into [`proto install`](./install)
in v0.39. Use that command instead!

:::

The `proto use` (or `proto u`) command will download and install _all_ tools and plugins from all
parent [`.prototools`](../config) configuration files, and any [versions detected](../detection) in
the current working directory (if not defined in `.prototools`).

```shell
$ proto use
```

> This command _does not_ install tools for versions pinned in the global `~/.proto/.prototools`
> file.

---

## versions

import VersionLabel from '@site/src/components/Docs/VersionLabel';

The `proto versions ` command will list available versions by resolving versions from the
tool's remote release manifest. Furthermore, if a version has been installed locally, it will be
denoted with a timestamp.

```shell
$ proto versions node
...
22.0.0
22.1.0
22.2.0
22.3.0
22.4.0
22.4.1
22.5.0 - installed 12/25/24
22.5.1
22.6.0
22.7.0
22.8.0
22.9.0
22.10.0
22.11.0
22.12.0
23.0.0
23.1.0
23.2.0
23.3.0
23.4.0 - installed 12/19/24
23.5.0 - installed 12/25/24
```

### Arguments

- `` - Type of tool.

### Options

- `--aliases` - Include aliases in the list.
- `--installed` - Only display installed versions.
- `--json` - Print the versions and aliases in JSON format.

---

## Configuration

import VersionLabel from '@site/src/components/Docs/VersionLabel';

We support configuration at both the project-level and user-level using a
[TOML](https://toml.io/en/) based `.prototools` file. This file can be used to pin versions of
tools, provide tool specific configuration, enable new tools via plugins, define proto settings, and
more.

## Locations

proto supports 3 locations in which a `.prototools` file can exist. These locations are used
throughout the command line and proto's own settings.

- `local` -> `./.prototools` (current directory)
- `global` -> `~/.proto/.prototools`
- `user` -> `~/.prototools`

> Local is a bit of a misnomer as a `.prototools` file can theoretically exist in any directory, but
> when reading/writing to a file, `local` refers to the current working directory.

### Where to configure?

With so many locations to store proto configuration, the question of where to store certain
configurations become blurred, especially when [resolution](#resolution-mode) comes into play. We
suggest the following locations:

- Default/fallback [versions](#pinning-versions) of tools -> `global`
- Project specific [versions](#pinning-versions) of tools -> `local`
- Project specific [settings](#settings) -> `local`
- Shared/developer [settings](#settings) -> `user`
- Non-project related -> `user`

## Resolution mode

When a `proto` command or shim is ran, we must find and load all applicable `.prototools` files. We
then deeply merge all of these configuration files into a final configuration object, with the
current directory taking highest precedence.

The order in which to resolve configuration can be defined using the `--config-mode` (`-c`) command
line option, or the `PROTO_CONFIG_MODE` environment variable. The following 4 modes are supported:

### `global`

In this mode, proto will _only_ load the `~/.proto/.prototools` file. This "global" file acts as
configuration at the user-level and allows for fallback settings.

```text
~/.proto/.prototools
```

### `local`

In this mode, proto will _only_ load the `.prototools` file in the current directory.

```text
./.prototools
```

### `upwards`

In this mode, proto will traverse upwards starting from the current directory, and load
`.prototools` within each directory, until we reach the system root or the user directory (`~`),
whichever comes first.

```text
~/Projects/app/.prototools (cwd)
~/Projects/.prototools
~/.prototools
```

> This is the default mode for the [`activate`](./commands/activate),
> [`install`](./commands/install), [`outdated`](./commands/outdated), and
> [`status`](./commands/status) commands.

### `upwards-global` / `all`

This mode works exactly like [`upwards`](#upwards) but with the functionality of [`global`](#global)
as well. The global `~/.proto/.prototools` file is appended as the final entry.

```text
~/Projects/app/.prototools (cwd)
~/Projects/.prototools
~/.prototools
~/.proto/.prototools
```

> This is the default mode for all other commands not listed above in `upwards`.

## Environment mode

We also support environment specific configuration, such as `.prototools.production` or
`.prototools.development`, when the `PROTO_ENV` environment variable is set. This is useful for
defining environment specific aliases, or tool specific configuration.

These environment aware settings take precedence over the default `.prototools` file, for the
directory it's located in, and are merged in the same way as the default configuration. For example,
the lookup order would be the following when `PROTO_ENV=production`:

```text
~/Projects/.prototools.production
~/Projects/.prototools
~/.prototools.production
~/.prototools
~/.proto/.prototools
```

> The global `~/.proto/.prototools` file does not support environment modes.

## Pinning versions

proto supports pinning versions of tools on a per-directory basis through our `.prototools`
configuration file. This file takes precedence during [version detection](./detection) and can be
created/updated with [`proto pin`](./commands/pin).

At its most basic level, you can map tools to specific versions, for the directory the file is
located in. A [version](./tool-spec) can either be a fully-qualified version, a partial version, a
range or requirement, or an alias.

```toml title=".prototools"
node = "16.16.0"
npm = "9"
go = "~1.20"
rust = "stable"
```

### Lock `proto` version

You can also pin the version of proto that you want all tools to execute with by adding a `proto`
version entry. This approach uses shims and dynamic version detection like other tools.

```toml title=".prototools"
proto = "0.38.0"
```

## Available settings

### `[env]`

This setting is a map of environment variables that will be applied to _all_ tools when they are
executed, or when [`proto activate`](./commands/activate) is ran in a shell profile. Variables
defined here _will not_ override existing environment variables (either passed on the command line,
or inherited from the shell).

```toml title=".prototools"
[env]
DEBUG = "*"
```

Additionally, `false` can be provided as a value, which will _remove_ the environment variable. This
is useful for removing inherited shell variables.

```toml title=".prototools"
[env]
DEBUG = false
```

Variables also support substitution using the syntax `${VAR_NAME}`. When using substitution,
variables in the current process and merged `[env]` can be referenced. Recursive substitution is not
supported!

> This functionality enables per-directory environment variables!

#### `file`

This is a special field that points to a dotenv file, relative from the current configuration file,
that will be loaded into the environment variables mapping. Variables defined in a dotenv file will
be loaded _before_ variables manually defined within `[env]`.

This feature utilizes the [dotenvy](https://github.com/allan2/dotenvy) crate for parsing dotfiles.

```toml title=".prototools"
[env]
file = ".env"
```

### `[settings]`

#### `auto-install`

When enabled, will automatically install a missin version of a tool when
[`proto run`](./commands/run) is ran, instead of erroring. Defaults to `false` or
`PROTO_AUTO_INSTALL`.

```toml title=".prototools"
[settings]
auto-install = true
```

:::warning

This functionality requires shims (not activation) and will only work after a tool has been
installed at least once. This is because the shim executable handles the interception and the shim
is created after a tool is installed.

:::

#### `auto-clean`

When enabled, will automatically clean up the proto store in the background, by removing unused
tools and outdated plugins. Defaults to `false` or `PROTO_AUTO_CLEAN`.

```toml title=".prototools"
[settings]
auto-clean = true
```

#### `builtin-plugins`

Can be used to customize the [built-in plugins](./tools#built-in) within proto. Can disable all
built-ins by passing `false`, or enabling a select few by name. Defaults to `true`, which enables
all.

```toml title=".prototools"
[settings]
# Disable all
builtin-plugins = false
# Enable some
builtin-plugins = ["node", "bun"]
```

#### `cache-duration`

The duration in seconds in which to cache downloaded plugins. Defaults to 30 days.

```toml title=".prototools"
[settings]
cache-duration = 3600
```

#### `detect-strategy`

The strategy to use when [detecting versions](./detection). Defaults to `first-available` or
`PROTO_DETECT_STRATEGY`.

- `first-available` - Will use the first available version that is found. Either from `.prototools`
  or a tool specific file (`.nvmrc`, etc).
- `prefer-prototools` - Prefer a `.prototools` version, even if found in a parent directory. If none
  found, falls back to tool specific file.
- `only-prototools` - Only use a version defined in `.prototools`. 

```toml title=".prototools"
[settings]
detect-strategy = "prefer-prototools"
```

#### `pin-latest`

When defined and a tool is installed with the "latest" alias, will automatically pin the resolved
version to the configured location. Defaults to disabled or `PROTO_PIN_LATEST`.

- `global` - Pins globally to `~/.proto/.prototools`.
- `local` - Pins locally to `./.prototools` in current directory.
- `user` - Pins to the user's `~/.prototools` in their home directory.
  

```toml title=".prototools"
[settings]
pin-latest = "local"
```

#### `telemetry`

When enabled, we collect anonymous usage statistics for tool installs and uninstalls. This helps us
prioritize which tools to support, what tools or their versions may be broken, the plugins currently
in use, and more. Defaults to `true`.

```toml title=".prototools"
[settings]
telemetry = false
```

> The data we track is publicly available and
> [can be found here](https://github.com/moonrepo/proto/blob/master/legacy/cli/src/telemetry.rs).

#### `unstable-lockfile`

When enabled, will create a `.protolock` file relative to this configuration file. The lockfile will
record and lock all tools, their versions, and checksums from the configuration file, ensuring
consistency across machines, and reliability.

```toml title=".prototools"
[settings]
unstable-lockfile = true
```

#### `unstable-registries`

A list of OCI registries to query for plugins by
[reference](https://oras.land/docs/concepts/reference). Registries will be queried in the order they
are configured. Each registry object supports the following fields:

- `registry` - The registry host, e.g. `ghcr.io`.
- `namespace` - The namespace (or organization) that the plugin belongs to.

```toml title=".prototools"
[settings]
unstable-registries = [
  { registry: "ghcr.io", namespace: "moonrepo" }
]
```

#### `url-rewrites`

Provides a mechanism for rewriting most URLs used by proto, such as those used for downloading
tools. This setting accepts a map of [Rust regular expressions](https://docs.rs/regex/latest/regex/)
to [replacement strings](https://docs.rs/regex/latest/regex/struct.Regex.html#method.replace). When
a URL is rewritten, all entries in the map are applied in order, and all matches are replaced.

```toml title=".prototools"
[settings.url-rewrites]
"github.com/(\\w+)/(\\w+)" = "gh-mirror.corp.com/$1/$2"
"mo+n" = "lunar"
```

The following types of URLs are rewritten:

- Tool download/checksum URLs (even from third-party plugins)
- Plugin download URLs
- Build script URLs
- Archive URLs

The following are _not_ rewritten:

- Git repository URLs
- proto version check/telemtry URLs

### `[settings.build]`

Can be used to customize the build from source flow.

#### `exclude-packages`

Configures a list of packages that should be excluded during installation.

```toml title=".prototools"
[settings.build]
exclude-packages = ["git", "python3", "libssl-dev"]
```

#### `install-system-packages`

When enabled, will install packages required for building using the system package manager. Defaults
to `true`.

```toml title=".prototools"
[settings.build]
install-system-packages = false
```

#### `system-package-manager`

Customize the system package manager to use when installing system packages and their dependencies.
By default we attempt to detect the package manager to use from the environment.

This setting accepts a map, where the key is the name of the
[operating system](https://doc.rust-lang.org/std/env/consts/constant.OS.html), and the value is the
[package manager](https://docs.rs/system_env/latest/system_env/enum.SystemPackageManager.html) to
use. Both the key and value are in kebab-case.

```toml title=".prototools"
[settings.build.system-package-manager]
windows = "choco"
```

#### `write-log-file`

When a build has completed, write a log file to the current directory. This is always `true` when a
build fails, but `false` otherwise.

```toml title=".prototools"
[settings.build]
write-log-file = true
```

### `[settings.http]`

Can be used to customize the HTTP client used by proto, primarily for requesting files to download,
available versions, and more.

#### `allow-invalid-certs`

When enabled, will allow invalid certificates instead of failing. This is an _escape hatch_ and
should only be used if other settings have failed. Be sure you know what you're doing! Defaults to
`false`.

```toml title=".prototools"
[settings.http]
allow-invalid-certs = true
```

#### `proxies`

A list of proxy URLs to use for requests. As an alternative, the `HTTP_PROXY` and `HTTPS_PROXY`
environment variables can be set. URLs that start with `http://` will be considered insecure, while
`https://` will be secure.

```toml title=".prototools"
[settings.http]
proxies = ["https://internal.proxy", "https://corp.net/proxy"]
```

#### `secure-proxies`

A list of proxy URLs that will be considered secure, regardless of the HTTP protocol.

```toml title=".prototools"
[settings.http]
secure-proxies = ["http://internal.proxy", "http://corp.net/proxy"]
```

#### `root-cert`

The path to a root certificate to use for requests. This is useful for overriding the native
certificate, or for using a self-signed certificate, especially when in a corporate/internal
environment. Supports `pem` and `der` files.

```toml title=".prototools"
[settings.http]
root-cert = "/path/to/root/cert.pem"
```

### `[settings.offline]`

Can be used to customize how we detect an internet connection for offline based logic. These
settings are useful if you're behind a VPN or corporate proxy.

#### `custom-hosts`

A list of custom hosts to ping. Will be appended to our
[default list of hosts](#override-default-hosts) and will be ran last.

```toml title=".prototools"
[settings.offline]
custom-hosts = ["proxy.corp.domain.com:80"]
```

#### `override-default-hosts`

If our default hosts are blocked or are too slow, you can disable pinging them by setting this
option to true. Our default hosts are Google DNS, Cloudflare DNS, and then Google and Mozilla hosts.

This should be used in parallel with [`custom-hosts`](#custom-hosts).

```toml title=".prototools"
[settings.offline]
override-default-hosts = true
```

#### `timeout`

The timeout in milliseconds to wait for a ping against a host to resolve. Default timeout is 750ms.

```toml title=".prototools"
[settings.offline]
timeout = 500
```

### `[plugins]`

Additional [plugins](./plugins) can be configured with the `[plugins]` section.
[Learn more about this syntax](./plugins#enabling-plugins).

```toml title=".prototools"
[plugins]
my-tool = "https://raw.githubusercontent.com/my/tool/master/proto-plugin.toml"
```

Once configured, you can run a plugin as if it was a built-in tool:

```shell
$ proto install my-tool
```

## Tool specific settings

### `[tools.*]`

Tools support custom configuration that will be passed to their WASM plugin, which can be used to
control the business logic within the plugin. Please refer to the [official documentation](./tools)
of each tool (typically on their repository) for a list of available settings.

As an example, let's configure [Node.js](https://github.com/moonrepo/node-plugin) (using the `node`
identifier).

```toml title=".prototools"
npm = "bundled" # use bundled npm instead of specific version

[tools.node]
bundled-npm = true

[tools.npm]
shared-globals-dir = true
```

#### `backend`

The [registry backend](./tool-spec#backends) to utilize when downloading, installing, and running
the tool. Supports the following:

- [`asdf`](https://asdf-vm.com/)

```toml title=".prototools"
[tools.node]
backend = "asdf"
```

### `[tools.*.aliases]`

Aliases are custom and unique labels that map to a specific version, and can be configured manually
within `.prototools`, or by calling the [`proto alias`](./commands/alias) command.

```toml title=".prototools"
[tools.node.aliases]
work = "18"
oss = "20"
```

### `[tools.*.env]`

This setting is a map of environment variables for a specific tool, and will be applied when that
tool is executed, or when [`proto activate`](./commands/activate) is ran in a shell profile. These
variables will override those defined in `[env]`. Refer to [`[env]`](#env) for usage examples.

```toml title=".prototools"
[tools.node.env]
NODE_ENV = "production"
```

#### `file`

Like [`[env].file`](#file), this is a path to a dotenv file, relative from the current configuration
file, that will be loaded into the environment variables mapping for this specific tool.

```toml title=".prototools"
[tools.node.env]
file = "frontend/.env"
```

## GitHub Action

To streamline GitHub CI workflows, we provide the
[`moonrepo/setup-toolchain`](https://github.com/moonrepo/setup-toolchain) action, which can be used
to install `proto` globally, and cache the toolchain found at `~/.proto`.

```yaml title=".github/workflows/ci.yml"
# ...
jobs:
  ci:
    name: 'CI'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: 'actions/checkout@v4'
      - uses: 'moonrepo/setup-toolchain@v0'
        with:
          auto-install: true
```

---

## Version detection

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';

The most powerful feature in proto is its contextual version detection, that is triggered with
[`proto run`](./commands/run), [`proto bin`](./commands/bin), or when a shim is executed. So what
does this mean exactly? Before a tool in proto's toolchain can be executed, we need to determine the
version of the tool to execute with. If a detected version exists locally, we proceed using that
binary, otherwise we fail with a missing installation error.

When detecting a version, the following steps are checked, in the order as listed:

#### 1. Version is explicitly passed as a command line argument

```
$ proto run node 18.0.0
```

#### 2. Version is provided with the `PROTO_*_VERSION` environment variable

```
$ PROTO_NODE_VERSION=18.0.0 proto run node
```

#### 3. Version is located by traversing the file system

This step will attempt to find a configuration or manifest file in the current working directory,
and traverse upwards through parent directories (stops at the user's home directory) until a file is
found.

##### 3.1. Version is defined locally in `.prototools`

A `.prototools` file was found and a version entry exists for the current tool. This is also known
as a "local version" and can be created with [`proto pin`](./commands/pin).

```toml title=".prototools"
node = "18.0.0"
```

##### 3.2. Version is defined in the tool's ecosystem

Depending on the tool, a version is extracted from a found file unique to that tool's ecosystem.
This includes version manager configs (`.nvmrc`, etc), manifest files (`package.json`, etc), and
more.

```text title=".nvmrc"
18.0.0
```

#### 4. Version is defined globally

As the last check, we look for a "global version" that was pinned with
[`proto pin --global`](./commands/pin) or [`proto install --pin`](./commands/install). This version
is stored at `~/.proto/.prototools`.

#### 5. Version _could not_ be detected

If all the previous steps have failed, then we could not detect an applicable version, and the
process will fail.

---

## FAQ

## General

### Where did the name "proto" come from?

We wanted to keep with the space theme, and spent quite some time digging through Wikipedia and
ultimately landed on the page for [protostar](https://en.wikipedia.org/wiki/Protostar) (this is why
our logo's a star). We really liked the definition of protostar, as it basically means "the
beginning phase of a star". Even the the prefix proto means "first" or "earliest form of".

This was great as that's the impression we had in mind for our tool. proto is the first piece
required for setting up your developer environment. The toolchain is the first layer in the
foundation.

From an aesthetic standpoint, proto's typography works well with moon, as most of the letters are
circle shaped. Double points for proto having two o's like the other products!

### Are you worried about confusion with other tools like protobufs?

Nah.

### What is a tool?

A tool in the context of proto is either a language, dependency/package manager (typically for a
language), or third-party CLI. The tool is something that can be downloaded and installed _by
version_ onto a machine.

Furthermore, a tool should have a primary executable file that can be executed with `proto run` or
through proto's shims. Additionally, a tool can also provide secondary executable files. For
example, `npm` (the primary) also provides `npx` and `node-gyp` (secondaries).

### What is a backend?

A backend is a special type of tool that provides additional integration with 3rd-party plugins,
greatly expanding what can be installed and managed with proto.

### What is a plugin?

A plugin is a WASM (or JSON, TOML, YAML) file for a tool or backend.

The terms tool and plugin are often used interchangeably, but plugin primarily refers to the WASM
portion of a tool, while tool refers to the entire package: metadata, business logic, branding, so
on an so forth.

### Will you support more languages?

Yes! We'd love to support as many as possible, and if you'd like to help, join our Discord
community! Feel free to create a [plugin](./plugins) in the mean time.

### Will you support other kinds of tools?

No, we will only support languages, dependency managers, and CLIs, which should be enough. However,
you can create a [plugin](./plugins) to support other kinds of tools.

### Do you support "build from source"?

As of version 0.45, we do! Simple pass `--build` to `proto install`. However, building from source
is a complicated process and is unique per tool, so not all tools support it.

### How to run a canary release after installing it?

Once a tool has been installed with `canary`, the canary version can be explicitly referenced using
our [version detection rules](./detection). The easiest approach is to prefix the shim with an
environment variable:

```shell
$ PROTO_BUN_VERSION=canary bun ./index.ts
```

Or to explicitly configure the version in [`.prototools`](./config):

```toml
bun = "canary"
```

### What kind of features are supported for HTTP requests?

proto makes a lot of HTTP requests, for information such as available versions/releases, and for
downloading the blobs/archives themselves. Because of this, we do our best to support all kinds of
internet connections, proxy and intranet usage, and more, through the following:

- All GET and HEAD requests are cached to `~/.proto/cache/requests` based on the
  [HTTP cache semantics](https://github.com/kornelski/rusty-http-cache-semantics) and relevant RFCs.
- We support the
  [netrc file format](https://www.gnu.org/software/inetutils/manual/html_node/The-_002enetrc-file.html)
  and will automatically load `~/.netrc` if it exists.
- We support an offline mode that will short-circuit certain workflows if there's no internet
  connection. We check for a connection by pinging DNS endpoints, but this can be configured with
  [`[settings.offline]`](./config#settingsoffline).
- We attempt to automatically load root and system certifications so that secure connections work
  correctly. This can be configured with [`[settings.http]`](./config#settingshttp).

## Troubleshooting

### Network requests keep failing, how can I bypass?

When a tool is executed, we validate the version to ensure it's correct. We achieve this by making
network requests to a remote service to gather the list of valid versions. If you're having network
issues, or the request is timing out, you can bypass these checks with the following:

- Pass a fully-qualified version as an environment variable. The version must be installed for this
  to work.

  ```shell
  PROTO_NODE_VERSION=20.0.0 node --version
  ```

  If executing a Node.js package manager, you'll need to set versions for both Node.js and the
  manager. This is required since manager's execute `node` processes under the hood.

  ```shell
  PROTO_NODE_VERSION=20.0.0 PROTO_NPM_VERSION=10.0.0 npm --version
  ```

- Pass the `PROTO_BYPASS_VERSION_CHECK` environment variable. This will bypass the network request
  to load versions, but does not bypass other requests. However, this is typically enough.

  ```shell
  PROTO_BYPASS_VERSION_CHECK=1 node --version
  ```

---

## What is proto?

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import ToolsGrid from '@site/src/components/Products/Proto/ToolsGrid';

proto is a pluggable version manager, a unified toolchain.

If you're unfamiliar with the concept of a toolchain, a toolchain is a collection of tools that are
downloaded, installed, and managed by version through a single interface. In the context of proto's
toolchain, a tool is either a programming language, a dependency/package manager for a language, or
a custom implementation provided by a plugin. It's the next step in the version manager evolution.

## Features

- Lightspeed! With Rust and WASM, we can guarantee exceptional performance.
- Multi-language. A single CLI for managing versions for all of your languages.
- Cross-platform, for a consistent experience across machines and teams.
- [Contextual version detection](./proto/detection), ensuring the correct version of a tool is
  always used.
- Checksum verification, ensuring a tool came from a trusted source.
- Detects and infers from a language's ecosystem for maximum compatibility.
- [Pluggable architecture](./proto/plugins), allowing for custom tooling.

## Why proto?

proto was designed to be a modern and holistic version manager for all of your favorite programming
languages. We believe a single tool that works the same across every language is better than
multiple ad-hoc tools. While we only support a handful of languages today, we aim to support many
more in the future!

:::success

proto powers [moon](/moon)'s toolchain, enabling a single source of truth for both tools!

:::

## How does it work?

The toolchain is a `.proto` directory within the current user's home directory, e.g., `~/.proto`.

The first step in a tool's life-cycle is being downloaded to `~/.proto/temp`. Downloads are
typically an archive that can be unpacked into a target directory. Once downloaded, we verify the
downloaded file by running a checksum. If this check fails for _any reason_, the tool is unusable,
and the process is aborted.

After a successful verification, the last step in the tool's life-cycle can begin, installation.
Depending on the type of download, the installation process may differ. For archives, we unpack the
tool to `~/.proto/tools//`. In the future, we'll support building from source.

From here, we make these tools globally available by prepending `~/.proto/shims` and `~/.proto/bin`
to `PATH` (typically as part of your shell profile). Continue reading for more about these folders.

## Supported tools

The following tools are [officially supported](./proto/tools) in proto via moonrepo. Additional
tools can be supported through [third-party plugins](./proto/plugins).

## Supported targets

Because proto is written in Rust, we only support targets that are explicitly compiled for, which
are currently:

| Operating system | Architecture | Target                       |
| :--------------- | :----------- | :--------------------------- |
| macOS 64-bit     | Intel        | `x86_64-apple-darwin`        |
| macOS 64-bit     | ARM          | `aarch64-apple-darwin`       |
| Linux 64-bit     | Intel GNU    | `x86_64-unknown-linux-gnu`   |
| Linux 64-bit     | Intel musl   | `x86_64-unknown-linux-musl`  |
| Linux 64-bit     | ARM GNU      | `aarch64-unknown-linux-gnu`  |
| Linux 64-bit     | ARM musl     | `aarch64-unknown-linux-musl` |
| Windows 64-bit   | Intel        | `x86_64-pc-windows-msvc`     |

---

## Install proto

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';

The following guide can be used to install proto into your environment.

## Requirements

- Git - for fetching available versions/tags
- tar, unzip, gz, xz - for unpacking archives

```shell
# macOS
brew install git unzip gzip xz

# Ubuntu / Debian
apt-get install git unzip gzip xz-utils

# RHEL-based / Fedora
dnf install git unzip gzip xz
```

## Installing

The entirety of proto is packaged and shipped as 2 binaries. It works on _most_ operating systems,
and does not require any external dependencies. For convenience, we provide the following scripts to
download and install proto.

:::info

The install location can be customized with the `PROTO_HOME` environment variable. If not provided,
the default location is `~/.proto`.

:::

### Linux, macOS, WSL

In a terminal that supports Bash, run the following command. This will download and install proto,
then open an interactive prompt to complete the installation.

```shell
bash 
          Learn about .prototools
        
      ),
      url: './config',
    },
  ]}
/>

---

## Non-WASM plugin

import VersionLabel from '@site/src/components/Docs/VersionLabel';
import NonWasmTabs from '@site/src/components/NonWasmTabs';

The non-WASM plugin is by design, very simple. It's a JSON, TOML, or YAML file that describes a
schema for the tool, how it should be installed, and how it should be invoked. Since this is a
static configuration file, it does not support any logic or complex behavior, and is merely for
simple and common use cases, like CLIs.

:::info

JSON and YAML support was added in proto v0.42.

:::

## Create a plugin

Let's start by creating a new plugin, and defining the `name` and `type` fields. The type can either
be `language`, `dependency-manager`, `package-manager`, or `cli`. For this example, we'll create a
plugin for our fake product called Protostar, a CLI tool.

### Platform variations

Native tools are often platform specific, and proto supports this by allowing you to define
variations based on operating system using the `[platform]` section. For non-native tools, this
section can typically be skipped.

This section requires a mapping of Rust
[`OS` strings](https://doc.rust-lang.org/std/env/consts/constant.OS.html) to platform settings. The
following settings are available:

- `archs` - A list of architectures supported for this platform. If not provided, supports all
  archs.
- `archive-prefix` - If the tool is distributed as an archive (zip, tar, etc), this is the name of
  the direct folder within the archive that contains the tool, and will be removed when unpacking
  the archive. If there is no prefix folder within the archive, this setting can be omitted.
- `exes-dir` - A relative path to a directory that contains pre-installed executables.
- `exe-path` - The path to the main executable binary within the archive (without the prefix). If
  the tool is distributed as a single binary, this setting can be typically omitted.
- `checksum-file` - Name of the checksum file to verify the downloaded file with. If the tool does
  not support checksum verification, this setting can be omitted.
- `download-file` (required) - Name of the file to download.
  [Learn more about downloading](#downloading-and-installing).

You may have noticed tokens above, like `{arch}`. These are special tokens that are replaced with a
dynamic value at runtime, based on the current host machine executing the code. The following tokens
are available:

- `{version}` - The currently resolved version, as a fully-qualified semantic or calendar version.
- `{versionMajor}` / `{versionYear}` - Only the major version. 
- `{versionMinor}` / `{versionMonth}` - Only the minor version. 
- `{versionPatch}` / `{versionDay}` - Only the patch version. 
- `{versionPrerelease}` - The prerelease identifier, if applicable. Returns an empty string
  otherwise. 
- `{versionBuild}` - The build identifier, if applicable. Returns an empty string otherwise.
  
- `{arch}` - The architecture of the host machine, like `x86_64`. These values map to Rust's
  [`ARCH` constant](https://doc.rust-lang.org/std/env/consts/constant.ARCH.html), but can be
  customized with [`install.arch`](#downloading-and-installing).
- `{os}` - The operating system of the host machine, like `windows`. These values map to Rust's
  [`OS` constant](https://doc.rust-lang.org/std/env/consts/constant.OS.html).
- `{libc}` - For Linux machines, this is the current libc implementation, either `gnu` or `musl`.
  

### Downloading and installing

A non-WASM plugin _only_ supports downloading pre-built tools, typically as an archive, and does
_not_ support building from source. The `[install]` section can be used to configure how the tool
should be downloaded and installed into the toolchain. The following settings are available:

- `arch` - A mapping of Rust
  [`ARCH` strings](https://doc.rust-lang.org/std/env/consts/constant.ARCH.html) to custom values for
  the `{arch}` token. This is useful if the tool has different terminology.
- `libc` - A mapping of custom values for the `{libc}` token.
- `checksum-url` - A secure URL to download the checksum file for verification. If the tool does not
  support checksum verification, this setting can be omitted.
- `checksum-url-canary` - A URL for canary releases.
- `checksum-public-key` - Public key used for verifying checksums. Only used for `.minisig` files.
- `download-url` (required) - A secure URL to download the tool/archive.
- `download-url-canary` - A URL for canary releases.
- `primary` - Configures the primary executable.
- `secondary` - Configures secondary executables.

The URL settings support `{checksum_file}` and `{download_file}` tokens, which will be replaced with
the values from the `[platform]` section.

#### Executables

The available executables (bins and shims) can be customized with the `[install.exes]` section,
which is required. This setting requires a map, where the key is the executable file name, and the
value is an object of the following options:

- `exe-path` - The file to execute, relative from the tool directory. On Windows, the `.exe`
  extension will automatically be appended. If you need more control over platform variance, use
  `[platform.*.exe-path]` instead.
- `no-bin` - Do not symlink a binary in `~/.proto/bin`.
- `no-shim`- Do not generate a shim in `~/.proto/shims`.
- `parent-exe-name` - Name of a parent executable required to execute the executable path. For
  example, `node` is required for `.js` files.
- `primary` - Is the main executable in the tool. There can only be 1 primary!
  
- `shim-before-args` - Custom args to prepend to user-provided args within the generated shim.
- `shim-after-args` - Custom args to append to user-provided args within the generated shim.
- `shim-env-vars` - Custom environment variables to set when executing the shim.

This field supports both the required primary executable, and optional secondary executables. The
primary executable must be marked with `primary = true`.

#### Global packages

The `[packages]` sections can be configured that provides information about where global packages
are stored.

- `globals-lookup-dirs` - A list of directories where global binaries are stored. This setting
  supports interpolating environment variables via the syntax `$ENV_VAR`.
- `globals-prefix` - A string that all package names are prefixed with. For example, Cargo/Rust
  binaries are prefixed with `cargo-`.

### Resolving versions

Now that the tool can be downloaded and installed, we must configure how to resolve available
versions. Resolving is configured through the `[resolve]` section, which supports 2 patterns to
resolve with: Git tags or a JSON manifest.

#### Git tags

To resolve a list of available versions using Git tags, the following settings are available:

- `git-url` (required) - The remote URL to fetch tags from.

#### JSON manifest

To resolve a list of available versions using a JSON manifest, the following settings are available:

- `manifest-url` (required) - A URL that returns a JSON response of all versions. This response
  _must be_ an array of strings, or an array of objects.
- `manifest-version-key` - If the response is an array of objects, this is the key to extract the
  version from. If the response is an array of strings, this setting can be omitted. Defaults to
  `version`.

#### Versions and aliases

As an alternative, we also support a static configuration of explicit versions and aliases. This is
useful if you have an internal tool that is relatively stable, or does not provide a means in which
to extract version information.

- `versions` - A list of versions.
- `aliases` - A mapping of alias names to versions.

#### Version patterns

When a version is found, either from a git tag or manifest key, we attempt to parse it into a
[valid version](./tool-spec) using a Rust based regex pattern and the `version-pattern` setting.

This pattern uses named regex capture groups (`(?...)`) to build the version, and to support
found versions that are not fully-qualified (they may be missing patch or minor versions). The
following groups are supported:

- `major` / `year` - The major version number. Defaults to `0` if missing.
- `minor` / `month` - The minor version number. Defaults to `0` if missing.
- `patch` / `day` - The patch version number. Defaults to `0` if missing.
- `pre` - The pre-release identifier, like "rc.0" or "alpha.0". Supports an optional leading `-`.
  Does nothing if missing.
- `build` - The build metadata, like a timestamp. Supports an optional leading `+`. Does nothing if
  missing.

\\d+)\\.(?\\d+)\\.(?\\d+))',
    },
  }}
/>

> If no named capture groups are found, the match at index `1` is used as the version.

### Detecting versions

And lastly, we can configure how to [detect a version](./detection) contextually at runtime, using
the `[detect]` setting. At this time, we only support 1 setting:

- `version-files` - A list of version files to extract from. The contents of these files can _only_
  be the version string itself.

---

## Plugins

proto supports a pluggable architecture as a means for consumers to integrate and manage custom
tools (languages, CLIs, etc) within proto's toolchain. It's not possible for proto to support
_everything_ in core directly, so plugins are a way for the community to extend the toolchain to
their needs.

## Enabling plugins

Plugins can be enabled by configuring them in [`.prototools`](./config#plugins) files, within the
`[plugins]` section. The map key is the plugin name _in kebab-case_, which is used as the
binary/tool name in proto, and also the name for configuration and cache purposes. The map value is
a [plugin locator string](../guides/wasm-plugins#configuring-plugin-locations) that defines a
protocol and source location.

```toml title=".prototools"
[plugins]
 = "://"
```

## Creating plugins

To ease the plugin development process, proto supports 2 types of plugins, a
[non-WASM configuration based plugin](./non-wasm-plugin) for basic use cases, and a
[WASM based plugin](./wasm-plugin) for advanced use cases.

## Publish a plugin

proto's registry is currently powered by static JSON files located in our official
[proto repository](https://github.com/moonrepo/proto/tree/master/registry). View that link for
information on how to publish a plugin.

---

## Tool specification

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import VersionLabel from '@site/src/components/Docs/VersionLabel';

Since proto is a toolchain for multiple tools, each with differing version formats, we must align
them on a standard specification that can resolve and store safely. To handle this, we've
implemented our own solution called the tool and version specification. This specification currently
supports semantic and calendar based versions, each with their own guidelines and caveats.

:::info

If you're implementing a plugin for a specific tool that has a different version format, you'll need
to re-format it into one of the specifications below.

:::

## Backends

A backend is an internal system that allows proto to use plugins from 3rd-party package/version
managers within proto, greatly expanding the amount of tools that proto can install and support.
This functionality is achieved through special WASM plugins under the hood.

To make use of a backend, prefix the version in `.prototools` with the backend's unique identifier.
For example, we can install Zig via asdf.

```toml title=".prototools"
zig = "asdf:0.13.0"
```

The approach above only utilizes the backend for that specific version. If you want to utilize the
backend for all versions (without using the version prefix), you can use the
[`tools.*.backend`](./config#backend) setting.

```toml title=".prototools"
zig = "0.13.0"

[tools.zig]
backend = "asdf"
```

### `asdf`

The `asdf` backend will utilize the [asdf version manager](https://asdf-vm.com/) for downloading and
installing a tool, loading versions, and locating executables. This backend implementation _does
not_ use the `asdf` binary itself, and instead emulates the environment as best we can. Because of
this, some tools may not be usable through proto.

```toml title=".prototools"
 = "asdf:20"
```

By default, the ID pinned in `.prototools` is the
[asdf shortname](https://asdf-vm.com/plugins/create.html#plugin-shortname-index) used when cloning a
repository. If the ID is different than the shortname (`node` vs `nodejs`), you can configure the
`asdf-shortname` setting.

```toml title=".prototools"
node = "asdf:20"

[tools.node]
asdf-shortname = "nodejs"
```

The following settings are supported:

- `asdf-shortname` (string) - The name of the [asdf plugin](https://github.com/asdf-vm/asdf-plugins)
  if different than the configured ID.
- `asdf-repository` (string) - The Git repository URL in which to locate
  [scripts](https://asdf-vm.com/plugins/create.html#scripts-overview). If not defined, is extracted
  from the shortname plugin index.
- `exes` (string[]) - List of executable file names (relative from `bin`) to be linked as a
  shim/bin. If not defined, we'll automatically scan the `bin` directory.

## Semantic versions

The most common format is [semver](https://semver.org/), also known as a semantic version. This
format requires major, minor, and patch numbers, with optional pre-release and build metadata.

```toml title=".prototools"
tool = "1.2.3"
```

### Syntax

- `..` - 1.2.3
- `..-` - 1.2.3-alpha.0
- `..-+` - 1.2.3-alpha.0+nightly456
- `..+` - 1.2.3+nightly456

### Guidelines

- major, minor, patch - `0-9` of any length
- pre, build - `a-z`, `0-9`, `-`, `.`

> [Learn more about this format!](https://semver.org/#backusnaur-form-grammar-for-valid-semver-versions)

## Calendar versions

Another popular format is [calver](https://calver.org/), also known as a calendar version, which
uses the calendar year, month, and day as version numbers. This format also supports pre-release and
build metadata, but with different syntax than semver.

```toml title=".prototools"
tool = "2025-02-26"
```

### Syntax

- `-` - 2024-02
- `--` - 2024-02-26
- `--.` - 2024-02-26.123
- `--_` - 2024-02-26_123
- `--.-` - 2024-02-26.123-alpha.0
- `--_-` - 2024-02-26_123-alpha.0
- `---` - 2024-02-26-alpha.0

### Guidelines

- year - `0-9` of 1-4 length
  - If the year is not YYYY format, it will use the year 2000 as the base. For example, `24` becomes
    `2024`, and `124` becomes `2124`.
- month - `0-9` of 1-2 length
  - Supports with and without a leading zero (`02` vs `2`).
  - Does not support invalid months (`0` or `13`).
- day - `0-9` of 1-2 length
  - Can be omitted, even with build/pre.
  - Supports with and without a leading zero (`02` vs `2`).
  - Does not support invalid days (`0` or `32`).
- build - `0-9` of any length
  - Also known as a "micro" number.
  - The leading dot `.` format is preferred.
- pre - `a-z`, `0-9`, `-`, `.`

> [Learn more about this format!](https://calver.org/#scheme)

## Requirements and ranges

Besides an explicit version, we also support partial versions known as version requirements or
version ranges. These are quite complex as we need to support both semver and calver in unison, as
well as support partial/incomplete numbers (missing patch/day, missing minor/month, etc). We do our
best to support as many combinations as possible.

```toml title=".prototools"
tool-a = "^1"
tool-b = "~2.1"
tool-c = ">=2000-10"
```

### Syntax

- Requirement - `[]` - `1.2.3`, `>4.5`, `~3`, `^2000-10`, etc
- AND range - `[,]  ...` - `>=1,  ||  ...` - `^1.2 || ^2.3`, `~2000-10 || ~2010-2`, etc

### Guidelines

- op - `=`, `>`, `>=`, `<=`, `<`, `~`, `^`
  - If omitted, defaults to `~` when not in a range.
- pattern
  - Dot-separated semver, with optional major and patch numbers.
  - Dash-separated calver, with optional month and day numbers.
  - Pre-release and build metadata are only supported when suffixed to full versions.

---

## Supported tools

import Button from '@site/src/ui/Button';
import ToolCards from '@site/src/components/Products/Proto/ToolCards';
import { BUILT_IN_TOOLS, THIRD_PARTY_TOOLS } from '@site/src/data/proto-tools';

## Built-in

The following tools are supported natively in proto's toolchain.

## Third-party

Additional tools can be supported through [plugins](./plugins).

---

## WASM plugin

import VersionLabel from '@site/src/components/Docs/VersionLabel';

If you want more control over how your tool works, a WASM plugin is the way to go.

:::success

Refer to our [official WASM guide](../guides/wasm-plugins) for more information on how our WASM
plugins work, critical concepts to know, and more. Once you have a good understanding, you may
continue this proto specific guide.

:::

## Concepts

The following concepts are unique to proto, but be sure to also read about the general concepts in
our [WASM plugins guide](../guides/wasm-plugins#concepts).

### Tool context

For plugin functions, we provide what we call the tool context, which is information that is
constantly changing depending on the current step or state of proto's execution. The context cannot
be accessed with a stand-alone function, and is instead passed as a `context` field in the input of
many plugin functions.

```rust
#[plugin_fn]
pub fn download_prebuilt(Json(input): Json) -> FnResult> {
    let version = input.context.version;
    // ...
}
```

The following fields are available on the
[context object](https://docs.rs/proto_pdk/latest/proto_pdk/struct.ToolContext.html):

- `proto_version` - The version of proto executing the plugin. Note that this version may be for the
  [`proto_core` crate](https://crates.io/crates/proto_core), and not the CLI. Patch numbers will
  drift, but major and minor numbers should be in sync.
- `temp_dir` - A virtual path to a temporary directory unique to this tool.
  
- `tool_dir` - A virtual path to the tool's directory for the current version.
- `version` - The current version or alias. If not resolved, will be "latest".

:::caution

The `version` field is either a fully-qualified version (1.2.3), an alias ("latest", "stable"), or
canary ("canary"). Be sure to account for all these variations when implementing plugin functions!

:::

### Tool configuration

Users can configure tools through the [`[tools.*]`](./config#tools) section of their `.prototools`,
which can then be accessed within the WASM plugin using the
[`get_tool_config`](https://docs.rs/proto_pdk/latest/proto_pdk/fn.get_tool_config.html) function.

```rust
let config = get_tool_config::()?;
config.bundled_npm;
```

This function requires a struct to deserialize into. It should implement `Default`, enable serde
defaults, and map keys from `kebab-case`. If you want to error on unknown settings, also enable
`deny_unknown_fields`.

```rust
#[derive(Debug, Default, serde::Deserialize)]
#[serde(default, deny_unknown_fields, rename_all = "kebab-case")]
struct NodeConfig {
    pub bundled_npm: bool,
    pub intercept_globals: bool,
}
```

## Creating a plugin

:::success

Refer to our [official WASM guide](../guides/wasm-plugins#creating-a-plugin) for steps on how to
create a Rust based plugin.

:::

## Implementing plugin functions

Plugins are powered by a set of functions that are called from the host, and are annotated with
`#[plugin_fn]`.

### Registering metadata

The first step in a plugin's life-cycle is to register metadata about the plugin with the
`register_tool` function. This function is called immediately after a plugin is loaded at runtime,
and must return a human-readable name and plugin type.

```rust
#[plugin_fn]
pub fn register_tool(_: ()) -> FnResult> {
    Ok(Json(RegisterToolOutput {
        name: "Node.js".into(),
        type_of: PluginType::Language,
        minimum_proto_version: Some(Version::new(0, 42, 0)),
        plugin_version: Version::parse(env!("CARGO_PKG_VERSION")).ok(),
        ..RegisterToolOutput::default()
    }))
}
```

This function also receives the plugin ID as input, allowing for conditional logic based on the ID.
The ID is the [key the plugin was configured with](./plugins#enabling-plugins), and what is passed
to `proto` commands (e.g. `proto install `).

```rust
#[plugin_fn]
pub fn register_tool(Json(input): Json) -> FnResult> {
  input.id
  // ...
}
```

#### Configuration schema

If you are using [tool configuration](#tool-configuration), you can register the shape of the
configuration using the [`schematic`](https://crates.io/crates/schematic) crate. This shape will be
used to generate outputs such as JSON schemas, or TypeScript types.

```rust
#[plugin_fn]
pub fn register_tool(_: ()) -> FnResult> {
    Ok(Json(RegisterToolOutput {
        // ...
        config_schema: Some(schematic::SchemaBuilder::generate::()),
    }))
}
```

Schematic is a heavy library, so we suggest adding the dependency like so:

```toml
[dependencies]
schematic = { version = "*", default-features = false, features = ["schema"] }
```

### Downloading pre-builts

Our plugin layer _only_ supports downloading pre-built tools, typically as an archive, and does
_not_ support building from source. The `download_prebuilt` function _must_ be defined, whichs
configures how the tool should be downloaded and installed.

The following fields are available:

- `archive_prefix` - If the tool is distributed as an archive (zip, tar, etc), this is the name of
  the direct folder within the archive that contains the tool, and will be removed when unpacking
  the archive. If there is no prefix folder within the archive, this setting can be omitted.
- `download_url` (required) - A secure URL to download the tool/archive.
- `download_name` - File name of the archive to download. If not provided, will attempt to extract
  it from the URL.
- `checksum` - The checksum hash itself. Will be used if no other option was provided.
  
- `checksum_url` - A secure URL to download the checksum file for verification. If the tool does not
  support checksum verification, this setting can be omitted.
- `checksum_public_key` - Public key used for verifying checksums. Only used for `.minisig` files.

```rust
#[plugin_fn]
pub fn download_prebuilt(Json(input): Json) -> FnResult> {
     let env = get_host_environment()?;

    check_supported_os_and_arch(
        NAME,
        &env,
        permutations! [
            HostOS::Linux => [HostArch::X64, HostArch::Arm64, HostArch::Arm, HostArch::Powerpc64, HostArch::S390x],
            HostOS::MacOS => [HostArch::X64, HostArch::Arm64],
            HostOS::Windows => [HostArch::X64, HostArch::X86, HostArch::Arm64],
        ],
    )?;

    let version = input.context.version;
    let arch = env.arch;
    let os = env.os;

    let prefix = match os {
        HostOS::Linux => format!("node-v{version}-linux-{arch}"),
        HostOS::MacOS => format!("node-v{version}-darwin-{arch}"),
        HostOS::Windows => format!("node-v{version}-win-{arch}"),
        other => {
            return Err(PluginError::UnsupportedPlatform("Node.js".into(), other.into()))?;
        }
    };

    let filename = if os == HostOS::Windows {
        format!("{prefix}.zip")
    } else {
        format!("{prefix}.tar.xz")
    };

    Ok(Json(DownloadPrebuiltOutput {
        archive_prefix: Some(prefix),
        download_url: format!("https://nodejs.org/dist/v{version}/{filename}"),
        download_name: Some(filename),
        checksum_url: Some(format!("https://nodejs.org/dist/v{version}/SHASUMS256.txt")),
        ..DownloadPrebuiltOutput::default()
    }))
}
```

#### Unpacking an archive

Our plugin layer will do its best to detect file extensions, unpack the downloaded file (if an
archive), and install the tool to the correct directory. However, we're unable to account for _all_
edge cases, so for situations where the install params above are not sufficient, you may define an
`unpack_archive` function.

This function receives an input with the following fields:

- `input_file` - Virtual path to the downloaded file. Maps to `~/.proto/temp//`.
- `output_dir` - Virtual directory to unpack the archive into, or copy the binary to. Maps to
  `~/.proto/tools//`.

```rust
#[plugin_fn]
pub fn unpack_archive(Json(input): Json) -> FnResult {
    untar(input.input_file, input.output_dir)?;
    Ok(())
}
```

### Locating executables

Even though a tool has been installed, we must inform proto of where to find executables. This can
be achieved with the required `locate_executables` function. The `exes` field defines the location
of the executables, relative from the installation directory.

```rust
#[plugin_fn]
pub fn locate_executables(
    Json(_): Json,
) -> FnResult> {
    let env = get_host_environment()?;

    Ok(Json(LocateExecutablesOutput {
        exes: HashMap::from_iter([
            // Primary
            (
                "node".into(),
                ExecutableConfig::new_primary(
                    // Helper that chooses between distinct Unix or Windows values
                    env.os.for_native("bin/node", "node.exe"),
                    // Or the same value with optional Windows extension
                    // env.os.get_file_name("node", "exe")
                )
            ),
            // Secondary
            (
                "corepack".into(),
                ExecutableConfig::new(env.os.for_native("bin/corepack", "corepack.exe"))
            ),
        ]),
        ..LocateExecutablesOutput::default()
    }))
}
```

> The main executable of the tool must be marked as primary, either with
> `ExecutableConfig::new_primary`, or setting the `ExecutableConfig.primary` field to true.

Furthermore, the `locate_executables` function can define a list of lookups for the globals
installation directory. proto will loop through each lookup, and return the first directory that
exists on the current file system. proto will also expand environment variables in the format of
`$VAR_NAME`. If a variable is not defined, or has an empty value, the lookup will be skipped. To
demonstrate this, we'll use [Deno](https://deno.land/manual@v1.35.0/tools/script_installer).

```rust
#[plugin_fn]
pub fn locate_executables(
    Json(_): Json,
) -> FnResult> {
    let env = get_host_environment()?;

    Ok(Json(LocateExecutablesOutput {
        globals_lookup_dirs: vec!["$DENO_INSTALL_ROOT/bin".into(), "$HOME/.deno/bin".into()],
        // ...
        ..LocateExecutablesOutput::default()
    }))
}
```

### Loading and resolving versions

Now that the tool can be downloaded and installed, we must configure how to resolve available
versions to actually be installed. To provide a list of versions and language specific aliases, the
`load_versions` function must be defined.

```rust
#[plugin_fn]
pub fn load_versions(Json(_): Json) -> FnResult> {
    let mut output = LoadVersionsOutput::default();
    let response: Vec = fetch_json("https://nodejs.org/dist/index.json")?;

    for (index, item) in response.iter().enumerate() {
        let version = VersionSpec::parse(&item.version[1..])?; // Starts with v

        if index == 0 {
            output.latest = Some(version.clone());
        }

        output.versions.push(version);
    }

    Ok(Json(output))
}
```

Furthermore, we support an optional function named `resolve_version`, that can be defined to
intercept the version resolution process. This function receives an input with an initial candidate,
either an alias or version, and can replace it with a new candidate. The candidate must be a valid
alias or version as defined in `load_versions`.

```rust
#[plugin_fn]
pub fn resolve_version(
    Json(input): Json,
) -> FnResult> {
    let mut output = ResolveVersionOutput::default();

    if let UnresolvedVersionSpec::Alias(alias) = input.initial {
        let candidate = if alias == "node" {
            "latest"
        } else if alias == "lts-*" || alias == "lts/*" {
            "stable"
        } else if alias.starts_with("lts-") || alias.starts_with("lts/") {
            &alias[4..]
        } else {
            return Ok(Json(output));
        };

        output.candidate = Some(UnresolvedVersionSpec::Alias(candidate.to_owned()));
    }

    Ok(Json(output))
}

```

### Detecting versions

And lastly, we can configure how to [detect a version](./detection) contextually at runtime, using
the `detect_version_files` function and optional `parse_version_file` function. The
`detect_version_files` function can return a list of files to locate within a directory.

```rust
#[plugin_fn]
pub fn detect_version_files(input: Json) -> FnResult> {
    Ok(Json(DetectVersionOutput {
        files: vec![
            ".nvmrc".into(),
            ".node-version".into(),
            "package.json".into(),
        ],
        ignore: vec!["node_modules".into()],
    }))
}
```

By default our plugin layer will assume the version file's contents contain the literal version, and
nothing else, like "1.2.3". If any of the files in the `detect_version_files` list require custom
parsing (for example, `package.json` above), you can define the `parse_version_file` function.

This function receives the file name and contents as input, and must return the parsed version (if
applicable).

```rust
#[plugin_fn]
pub fn parse_version_file(Json(input): Json) -> FnResult> {
    let mut version = None;

    if input.file == "package.json" {
        let json: PackageJson = serde_json::from_str(&input.content)?;

        if let Some(engines) = json.engines {
            if let Some(constraint) = engines.get("node") {
                version = Some(UnresolvedVersionSpec::parse(constraint)?);
            }
        }
    } else {
        version = Some(UnresolvedVersionSpec::parse(input.content.trim())?);
    }

    Ok(Json(ParseVersionFileOutput { version }))
}
```

## Testing

The best way to test the plugin is to execute it through `proto` directly. To do this, you'll need
to configure a `.prototools` file at the root of your plugin's repository that maps the plugin to a
debug build:

```toml
[plugins]
 = "file://./target/wasm32-wasip1/debug/.wasm"
```

And everytime you make a change to the plugin, you'll need to rebuild it with:

```shell
cargo build --target wasm32-wasip1
```

With these 2 pieces in place, you can now execute `proto` commands. Be sure you're running them from
the directory with the `.prototools` file, and that you're passing `--log trace`. Logs are extremely
helpful for figuring out what's going on.

```shell
proto --log trace install 
proto --log trace list-remote 
...
```

### Unit tests

Testing WASM plugins is a bit tricky, but we've taken it upon ourselves to streamline this process
as much as possible with built-in test utilities, and Rust macros for generating common test cases.
To begin, install all necessary development dependencies:

```shell
cargo add --dev proto_pdk_test_utils starbase_sandbox tokio
```

And as mentioned above, everytime you make a change to the plugin, you'll need to rebuild it with:

```shell
cargo build --target wasm32-wasip1
```

#### Testing plugin functions

The common test case is simply calling plugin functions with a provided input and asserting the
output is correct. This can be achieved by creating a plugin instance with `create_plugin` and
calling the appropriate method.

```rust
use proto_pdk_test_utils::*;
use starbase_sandbox::create_empty_sandbox;

#[tokio::test(flavor = "multi_thread")]
async fn registers_metadata() {
    let sandbox = create_empty_proto_sandbox();
    let plugin = sandbox.create_plugin("id").await;

    assert_eq!(
        plugin.register_tool(RegisterToolInput::default()).await,
        RegisterToolOutput {
            name: "Name".into(),
            ..RegisterToolOutput::default()
        }
    );
}
```

:::info

We suggest using this pattern for static functions that return a deterministic output from a
provided input, and not for dynamic functions that make HTTP requests or execute host commands.

:::

#### Generating cases from macros

To reduce the burden of writing custom tests for common flows, like downloading a pre-built,
resolving versions, and generating shims, we provide a set of Rust decl macros that will generate
the tests for you.

To test downloading and installing, use `generate_download_install_tests!`. This macro requires a
plugin ID and a real version to test with.

```rust
use proto_pdk_test_utils::*;

generate_download_install_tests!("id", "1.2.3");
```

To test version resolving, use `generate_resolve_versions_tests!`. This macro requires a plugin ID,
and a mapping of version/aliases assertions to expectations.

```rust
generate_resolve_versions_tests!("id", {
    "0.4" => "0.4.12",
    "0.5.1" => "0.5.1",
    "stable" => "1.0.0",
});
```

To test installing and uninstalling globals, use `generate_globals_test!`. This macro requires a
plugin ID, the dependency to install, and an optional environment variable to the globals directory.

```rust
// Doesn't support all use cases! If this doesn't work, implement a test case manually.
generate_globals_test!("id", "dependency", "GLOBAL_INSTALL_ROOT");
```

And lastly, to test shims, use `generate_shims_test!`. This requires a plugin ID and a list of shim
file names. This macro generates snapshots using [Insta](https://insta.rs/).

```rust
generate_shims_test!("id", ["primary", "secondary"]);
```

## Building and publishing

:::success

Refer to our [official WASM guide](../guides/wasm-plugins#building-and-publishing) for steps on how
to build and publish your plugin.

:::

## Resources

Some helpful resources for learning about and building plugins.

- [Official proto WASM plugins](https://github.com/moonrepo/plugins)
- Plugin development kit
  - [`proto_pdk` docs](https://docs.rs/proto_pdk/)
  - [`proto_pdk_test_utils` docs](https://docs.rs/proto_pdk_test_utils/)

---

## Workflows

import VersionLabel from '@site/src/components/Docs/VersionLabel';

With proto, we provide multiple workflows for everyday use for you to choose from. They can be used
individually, or together, it's up to you!

## Shims

proto is primarily powered by the industry standard concept of shims. For each tool installed in
proto, a shim file will exist at `~/.proto/shims` for the primary executable, and some secondary
executables. Shims _are not_ symlinks to the tool's binary, but are thin wrappers around
[`proto run`](./commands/run), enabling [runtime version detection](./detection) on every
invocation! For example, these are equivalent:

```shell
$ proto run node -- --version
20.0.0

$ node --version
20.0.0

$ which node
~/.proto/shims/node
```

### Setup

To make use of shims, prepend the `~/.proto/shims` directory to `PATH` in your shell profile. This
_must come before_ the [bin directory](#binary-linking) if using both.

If you're using or plan to use [shell activation](#shell-activation), the `PATH` configuration
happens automatically, but shell activation will only work if the `proto` command is accessible,
which requires `~/.proto/bin` to be in your `PATH`.

## Binary linking

Alternatively, we also support a non-shim based approach, which creates symlinks to a versioned
tool's primary and secondary executables. For each tool installed in proto, a symlink will exist at
`~/.proto/bin`.

```shell
$ node --version
23.1.0

$ which node
~/.proto/bin/node -> ~/.proto/tools/node/23.1.0/bin/node
```

When a tool is installed into proto, we symlink many binaries based on all the versions that are
installed in the toolchain. The primary binary will always point to the highest installed version,
while we also create binaries for the highest major, and highest major + minor combinations. For
example:

- `~/.proto/bin/node` - Points to the highest version.
- `~/.proto/bin/node-` - Points to the highest version within that major range (`~major`). Is
  created for each separate major version, for example: `node-20`, `node-22`.
- `~/.proto/bin/node-.` - Points to the highest version within that major + minor
  range (`~major.minor`). Is created for each separate major + minor version, for example:
  `node-20.1`, `node-22.4`.
- `~/.proto/bin/node-canary` - Points to a canary install, if it exists.

```shell
$ node-22 --version
22.5.1

$ which node-22
~/.proto/bin/node-22 -> ~/.proto/tools/node/22.5.1/bin/node
```

:::info

Not all tools support symlinking a binary, as not all files are executable. For example, most
Node.js package managers currently do not support this, as JavaScript files are not executable
(especially on Windows). Shims are required for these tools.

:::

### Setup

To make use of bins, prepend the `~/.proto/bin` directory to `PATH` in your shell profile. This
_must come after_ the [shim directory](#shims) if using shims.

If you're using or plan to use [shell activation](#shell-activation), the `PATH` configuration
happens automatically, but shell activation will only work if the `proto` command is accessible,
which requires `~/.proto/bin` to be in your `PATH`.

:::warning

This directory must always exist in `PATH`, as the official proto binaries `~/.proto/bin/proto` and
`~/.proto/bin/proto-shim` are located here. If you move those binaries to another location, you can
omit `~/.proto/bin` from `PATH` if you like.

:::

## Shell activation

Our last workflow is what we call shell activation (or shell hooks), and it's where the proto
environment is setup/reset every time you change directories. If you're coming from another version
manager, you may be familiar with this kind of workflow.

So how does this work exactly? In your shell profile, you'll evaluate a call to
[`proto activate `](./commands/activate), which generates a bunch of shell specific syntax
that registers a hook for "run this code when the current directory or prompt line changes". Once
this hook is registered and you run `cd` (for example), proto will...

- Load all `.prototools` files
- Extract tools with a [configured version](./config#pinning-versions)
- For each tool:
  - Load associated WASM plugin
  - Export environment variables based on [`[env]`](./config#env) and
    [`[tools.*.env]`](./config#toolsenv)
  - Prepend `PATH` with tool-specific directories (like local and global executables) for the
    detected version

```shell
$ cd /some/path && node --version
20.0.0

$ cd /another/path && node --version
18.0.0
```

### Setup

View the [`proto activate`](./commands/activate#setup) documentation for information on how to setup
your shell profile for this workflow.

## Comparison

The workflows above may come across as information overload, so we've provided the following
comparison table outlining the features each workflow supports.

|                                | Shims                  | Bins | Activate                       |
| ------------------------------ | ---------------------- | ---- | ------------------------------ |
| Runtime version detection      | 🟢                     | 🔴   | 🟠 only when the hook triggers |
| Supports multiple versions     | 🟢                     | 🟢   | 🟢                             |
| Fixed to a single version      | 🟠 with arg or env var | 🟢   | 🟠 if not using shims          |
| Includes all tool executables  | 🔴                     | 🔴   | 🟢                             |
| Includes tool globals/packages | 🔴                     | 🔴   | 🟢                             |
| Exports environment variables  | 🔴                     | 🔴   | 🟢                             |
| Prepends `PATH`                | 🔴                     | 🔴   | 🟢                             |
| Can pin proto's version        | 🔴                     | 🔴   | 🟢                             |

---

## Run a task

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';

Even though we've [created a task](./create-task), it's not useful unless we _run it_, which is done
with the [`moon run `](./commands/run) command. This command requires a single argument, a
[primary target](./concepts/target), which is the pairing of a scope and task name. In the example
below, our project is `app`, the task is `build`, and the target is `app:build`.

```shell
$ moon run app:build

# In v1.14+, "run" can be omitted
$ moon app:build
```

When this command is ran, it will do the following:

- Generate a directed acyclic graph, known as the action (dependency) graph.
- Insert [`deps`](./config/project#deps) as targets into the graph.
- Insert the primary target into the graph.
- Run all tasks in the graph in parallel and in topological order (the dependency chain).
- For each task, calculate [hashes](./concepts/cache) and either:
  - On cache hit, exit early and return the last run.
  - On cache miss, run the task and generate a new cache.

## Running dependents

moon will _always_ run upstream dependencies ([`deps`](./config/project#deps)) before running the
primary target, as their outputs may be required for the primary target to function correctly.

However, if you're working on a project that is shared and consumed by other projects, you may want
to verify that downstream dependents have not been indirectly broken by any changes. This can be
achieved by passing the `--dependents` option, which will run dependent targets _after_ the primary
target.

```shell
$ moon run app:build --dependents
```

## Running based on affected files only

By default [`moon run`](./commands/run) will _always_ run the target, regardless if files have
actually changed. However, this is typically fine because of our
[smart hashing & cache layer](./concepts/cache). With that being said, if you'd like to _only_ run a
target if files have changed, pass the `--affected` flag.

```shell
$ moon run app:build --affected
```

Under the hood, we extract locally touched (created, modified, staged, etc) files from your
configured [VCS](./config/workspace#vcs), and exit early if no files intersect with the task's
[inputs](./config/project#inputs).

### Using remote changes

If you'd like to determine affected files based on remote changes instead of local changes, pass the
`--remote` flag. This will extract touched files by comparing the current `HEAD` against the
[`vcs.defaultBranch`](./config/workspace#defaultbranch).

```shell
$ moon run app:build --affected --remote
```

### Filtering based on change status

We can take this a step further by filtering down affected files based on a change status, using the
`--status` option. This option accepts the following values: `added`, `deleted`, `modified`,
`staged`, `unstaged`, `untracked`. If not provided, the option defaults to all.

```shell
$ moon run app:build --affected --status deleted
```

Multiple status can be provided by passing the `--status` option multiple times.

```shell
$ moon run app:build --affected --status deleted --status modified
```

## Passing arguments to the underlying command

If you'd like to pass arbitrary arguments to the underlying task command, in addition to the already
defined [`args`](./config/project#args), you can pass them after `--`. These arguments are _appended
as-is_.

```shell
$ moon run app:build -- --force
```

> The `--` delimiter and any arguments _must_ be defined last on the command line.

## Advanced run targeting

By this point you should have a basic understanding of how to run tasks, but with moon, we want to
provide support for advanced workflows and development scenarios. For example, running a target in
all projects:

```shell
$ moon run :build
```

Or perhaps running a target based on a query:

```shell
$ moon run :build --query "language=[javascript, typescript]"
```

Jump to the official [`moon run` documentation](./commands/run) for more examples!

## Next steps

          Learn about moon run
        
      ),
      url: './commands/run',
    },
  ]}
/>

---

## Setup toolchain

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';
import LangPartials from '@site/src/components/LangPartials';

One of moon's most powerful features is the [toolchain](./concepts/toolchain), which automatically
manages, downloads, and installs Node.js and other languages behind the scenes using
[proto](/proto). It also enables [advanced functionality](./how-it-works/languages#tier-2--platform)
for task running based on the platform (language and environment combination) it runs in.

The toolchain is configured with [`.moon/toolchain.yml`](./config/toolchain).

:::tip

Change the language dropdown at the top right to switch the examples!

:::

## How it works

For more information on the toolchain, our tier based support, and how languages integrate into
moon, refer to the official ["how it works" language guide](./how-it-works/languages) and the
[toolchain concept](./concepts/toolchain) documentation!

:::info

The toolchain is optional but helps to solve an array of issues that developers face in their
day-to-day.

:::

## Enabling a platform

By default all tasks run through the
[system platform](./how-it-works/languages#system-language-and-toolchain) and inherit _no_ special
functionality. If you want to take advantage of this functionality, like dependency hashing, package
shorthand execution, and lockfile management, you'll need to enable the platform in
[`.moon/toolchain.yml`](./config/toolchain). Otherwise, you can skip to the
[create a task](./create-task) guide.

Begin by declaring the necessary configuration block, even if an empty object! This configuration
can also be injected using the [`moon init `](./commands/init) command (doesn't support all
languages).

import Tier2Bun from './__partials__/setup-toolchain/bun/tier2.mdx';
import Tier2Deno from './__partials__/setup-toolchain/deno/tier2.mdx';
import Tier2Go from './__partials__/setup-toolchain/go/tier2.mdx';
import Tier2Node from './__partials__/setup-toolchain/node/tier2.mdx';
import Tier2PHP from './__partials__/setup-toolchain/php/tier2.mdx';
import Tier2Python from './__partials__/setup-toolchain/python/tier2.mdx';
import Tier2Ruby from './__partials__/setup-toolchain/ruby/tier2.mdx';
import Tier2Rust from './__partials__/setup-toolchain/rust/tier2.mdx';

  
  
  
  
  
  
  
  

Although we've enabled the platform, language binaries must exist on `PATH` for task execution to
function correctly. Continue reading to learn how to automate this flow using tier 3 support.

## Automatically installing a tool

One of the best features of moon is its integrated toolchain and automatic download and installation
of programming languages (when supported), for all developers and machines that moon runs on. This
feature solves the following pain points:

- Developers running tasks using different versions of languages.
- Version drift of languages between machines.
- Languages being installed through different version managers or install scripts.
- Language binaries not existing on `PATH`.
- How shell profiles should be configured.

If you have dealt with any of these pain points before and would like to eliminate them for you and
all your developers, you can try enabling moon's tier 3 support for supported tools. This is easily
done by defining the `version` field for each platform.

import Tier3Bun from './__partials__/setup-toolchain/bun/tier3.mdx';
import Tier3Deno from './__partials__/setup-toolchain/deno/tier3.mdx';
import Tier3Go from './__partials__/setup-toolchain/go/tier3.mdx';
import Tier3Node from './__partials__/setup-toolchain/node/tier3.mdx';
import Tier3PHP from './__partials__/setup-toolchain/php/tier3.mdx';
import Tier3Python from './__partials__/setup-toolchain/python/tier3.mdx';
import Tier3Ruby from './__partials__/setup-toolchain/ruby/tier3.mdx';
import Tier3Rust from './__partials__/setup-toolchain/rust/tier3.mdx';

  
  
  
  
  
  
  
  

When the `version` field is configured, moon will download and install the tool when a related task
is executed for the first time! It will also set the correct `PATH` lookups and environment
variables automatically. Amazing right?

## Next steps

          Configure .moon/toolchain.yml further
        
      ),
      url: './config/toolchain',
    },
    { icon: 'toolchain', label: 'Learn about the toolchain', url: './concepts/toolchain' },
  ]}
/>

---

## Setup workspace

import HeaderLabel from '@site/src/components/Docs/HeaderLabel';
import NextSteps from '@site/src/components/NextSteps';

Once moon has been [installed](./install), we must setup the [workspace](./concepts/workspace),
which is denoted by the `.moon` folder — this is known as the workspace root. The workspace is in
charge of:

- Integrating with a version control system.
- Defining configuration that applies to its entire tree.
- Housing [projects](./concepts/project) to build a [project graph](./how-it-works/project-graph).
- Running tasks with the [action graph](./how-it-works/action-graph).

## Initializing the repository

Let's scaffold and initialize moon in a repository with the [`moon init`](./commands/init) command.
This should typically be ran at the root, but can be nested within a directory.

```shell
$ moon init
```

When executed, the following operations will be applied.

- Creates a `.moon` folder with a [`.moon/workspace.yml`](./config/workspace) configuration file.
- Appends necessary ignore patterns to the relative `.gitignore`.
- Infers the version control system from the environment.

:::info

If you're investigating moon, or merely want to prototype, you can use `moon init --minimal` to
quickly initialize and create minimal configuration files.

:::

## Migrate from an existing build system

Looking to migrate from Nx or Turborepo to moon? Use our
[`moon ext migrate-nx`](./guides/extensions#migrate-nx) or
[`moon ext migrate-turborepo`](./guides/extensions#migrate-turborepo) commands for a (somewhat)
seamless migration!

These extensions will convert your existing configuration files to moon's format as best as
possible, but is not a requirement.

## Configuring a version control system

moon requires a version control system (VCS) to be present for functionality like file diffing,
hashing, and revision comparison. The VCS and its default branch can be configured through the
[`vcs`](./config/workspace#vcs) setting.

```yaml title=".moon/workspace.yml"
vcs:
  manager: 'git'
  defaultBranch: 'master'
```

> moon defaults to `git` and the settings above, so feel free to skip this.

## Next steps

          Configure .moon/workspace.yml further
        
      ),
      url: './config/workspace',
    },
    { icon: 'workspace', label: 'Learn about the workspace', url: './concepts/workspace' },
  ]}
/>

---

## Terminology

| Term                          | Description                                                                                                                                             |
| :---------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Action                        | A node within the dependency graph that gets executed by the action pipeline.                                                                           |
| Action pipeline               | Executes actions from our dependency graph in topological order using a thread pool.                                                                    |
| Affected                      | Touched by an explicit set of inputs or sources.                                                                                                        |
| Cache                         | Files and outputs that are stored on the file system to provide incremental builds and increased performance.                                           |
| CI                            | Continuous integration. An environment where tests, builds, lints, etc, are continuously ran on every pull/merge request.                               |
| Dependency graph              | A directed acyclic graph (DAG) of targets to run and their dependencies.                                                                                |
| Downstream                    | Dependents or consumers of the item in question.                                                                                                        |
| [Generator](./guides/codegen) | Generates code from pre-defined templates.                                                                                                              |
| Hash                          | A unique SHA256 identifier that represents the result of a ran task.                                                                                    |
| Hashing                       | The mechanism of generating a hash based on multiple sources: inputs, dependencies, configs, etc.                                                       |
| LTS                           | Long-term support.                                                                                                                                      |
| Dependency manager            | Installs and manages dependencies for a specific tool (`npm`), using a manifest file (`package.json`).                                                  |
| Platform                      | An internal concept representing the integration of a programming language (tool) within moon, and also the environment + language that a task runs in. |
| Primary target                | The target that was explicitly ran, and is the dependee of transitive targets.                                                                          |
| [Project][project]            | An collection of source and test files, configurations, a manifest and dependencies, and much more. Exists within a [workspace][workspace]              |
| Revision                      | In the context of a VCS: a branch, revision, commit, hash, or point in history.                                                                         |
| Runtime                       | An internal concept representing the platform + version of a tool.                                                                                      |
| [Target][target]              | A label and reference to a task within the project, in the format of `project:task`.                                                                    |
| [Task][task]                  | A command to run within the context of and configured in a [project][project].                                                                          |
| Template                      | A collection of files that get scaffolded by a generator.                                                                                               |
| Template file                 | An individual file within a template.                                                                                                                   |
| Template variable             | A value that is interpolated within a template file and its file system path.                                                                           |
| [Token][token]                | A value within task configuration that is substituted at runtime.                                                                                       |
| Tool                          | A programming language or dependency manager within the [toolchain][toolchain].                                                                         |
| [Toolchain][toolchain]        | Installs and manages tools within the [workspace][workspace].                                                                                           |
| Transitive target             | A target that is the dependency of the primary target, and must be ran before the primary.                                                              |
| Touched                       | A file that has been created, modified, deleted, or changed in any way.                                                                                 |
| Upstream                      | Dependencies or producers of the item in question.                                                                                                      |
| VCS                           | Version control system (like Git or SVN).                                                                                                               |
| [Workspace][workspace]        | Root of the moon installation, and houses one or many [projects][project]. _Also refers to package manager workspaces (like Yarn)._                     |

[project]: ./concepts/project
[target]: ./concepts/target
[task]: ./concepts/task
[token]: ./concepts/token
[toolchain]: ./concepts/toolchain
[workspace]: ./concepts/workspace

---

## moon v0.13 - Hashing and toolchain improvements

With this release, we've landed some improvements to our smart hashing, and paved the road for
additional languages and tooling.

## Node.js is now optional

Title may seem confusing at first, but don't worry, everything is fine! For some context, moon has
been designed to be language agnostic as we plan to support more than JavaScript in the future.
However, some aspects of the codebase were hard-coded for JavaScript and made the assumption that
JavaScript will always be used, with one such aspect being the [`node`](../docs/config/workspace)
setting in [`.moon/workspace.yml`](../docs/config/workspace).

We've reworked this setting to be optional, which allows a repository to opt out of JavaScript.
Right now, this basically does nothing as we do not support other languages yet, but we felt it
necessary to report it anyways! A side-effect of this change is that actions in the runner have been
renamed, for example, `SetupToolchain` -> `SetupNodeToolchain`.

## Improved hashing accuracy

Our [smart hashing layer](../docs/concepts/cache#hashing) is pretty powerful, but was not entirely
accurate. Up until now, when hashing a Node.js project, we'd include the `dependencies`,
`devDependencies`, and `peerDependencies` versions located within the project's `package.json` as
hash inputs. This was great, because if a dependency was explicitly upgraded in the `package.json`,
it would invalidate the previous hashes as the version number changed.

However, what if the dependency was implicitly upgraded by another project, but the `package.json`
was not modified? These kind of transitive changes were currently ignored by moon, but no longer, as
moon will now resolve all `package.json` dependencies to the resolved version found in the root
lockfile (`package-lock.json`, `yarn.lock`, etc)!

At moon, we believe in providing consumers with the ability to configure to their needs, and as
such, have added a new [`hasher`](../docs/config/workspace#hasher) setting to
[`.moon/workspace.yml`](../docs/config/workspace). This setting will allow you to choose between the
2 hashing patterns above!

## New `moon check` command

If you're like us, you're constantly testing, linting, typechecking, so on and so forth, a project
while developing. This was rather cumbersome, as you either had to use separate run commands
(`moon run project:test`, `moon run project:lint`, etc), or use the multi-run approach
(`moon run project:test project:lint`). Both approaches were not ideal for rapid development.

To simplify this process, we've added a new [`moon check`](../docs/commands/check) command, that
will automatically run _all_ build and test tasks for a project (or many projects)! Local and non-CI
tasks will _not_ be ran.

```shell
# Check project at current working directory
$ moon check

# Check project by name
$ moon check app

# Check multiple projects by name
$ moon check client server
```

## New `@moonrepo/types` package

We have many ideas for moon specific npm packages that we plan to release, but before we do that, we
need to ensure all of them are built with the correct interfaces. To solve this, we are shipping a
new package, [@moonrepo/types](https://www.npmjs.com/package/@moonrepo/types), that simply publishes
TypeScript declarations. It contains everything from project and task shapes, configuration
structures, runner information, and more.

```ts
import type { ProjectConfig } from '@moonrepo/types';
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.13.0) for a
full list of changes.

- The runner will now fail with an error if a task has defined `outputs` but an output was not
  created after the task is executed. This change was made so that artifacts are deterministic.
- The `actionRunner` setting in [`.moon/workspace.yml`](../docs/config/workspace) was renamed to
  `runner`.

## What's next?

Expect the following in the v0.14 release!

- A `moon generate` command to generate new projects, files, scaffolding, and more from pre-defined
  templates.
- Implicit dependency discovery. moon will now scan manifest files and determine project
  relationships.

---

## moon v0.14 - Code generation and implicit dependencies

import Image from '@site/src/components/Image';

With this release, we've landed some new features that have been requested multiple times since
launch. A code generation and template scaffolding layer, as well as implicit dependency scanning
for the project graph!

## New `moon generate` command

Code generation is the staple of any large company or repository. Want to spin up a new application?
What about an npm package? Or maybe third-party integrations? Avoid copy-and-pasting existing code,
and instead generate it with the new `moon generate` command, which is powered by our new generator
system.

The generator will locate a template by name on the file system ("npm-package" in the example
below), prompt and interpolate variables, render the files with [Tera](https://tera.netlify.app/) (a
Rust based template engine), and write the files to the target destination.

```shell
# Generate code from a template to a target directory
$ moon generate npm-package ./packages/example
```

Learn more about [code generation in the official guide](../docs/guides/codegen)!

## Implicit dependency scanning

This has been a request since moon's official release, and it's finally here! Up until now, if you
wanted project-to-project dependency relationships, you had to explicitly declare them with
[`dependsOn`](../docs/config/project#dependson). But thanks to a
[ton of](https://github.com/moonrepo/moon/pull/288)
[infrastructure](https://github.com/moonrepo/moon/pull/249) and
[platform](https://github.com/moonrepo/moon/pull/277) changes, we can now infer implicit
dependencies automatically!

We still suggest using explicit dependencies, as it provides more
[automation like project syncing](../docs/concepts/project#dependencies), but implicit is great for
adoption and migration purposes.

## Report CI runs on pull requests

We're fans of continuous and easily accessible feedback, and as such, have released a new GitHub
action, [`moonrepo/run-report-action`](https://github.com/marketplace/actions/moon-ci-run-reports),
which reports the results of [`moon ci`](../docs/commands/ci) as a pull request comment. The report
looks something like the following:

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.14.0) for a
full list of changes.

- When running in a Docker container, caching is disabled in an effort to greatly reduce the size of
  the image.
- Updated `moon setup` to also install Node.js dependencies.

## What's next?

Expect the following in the v0.15 release!

- Major Docker workflow improvements!
- Frontmatter configuration within template files.

---

## moon v0.15 - Enhanced Docker support and 1,000 stars!

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

With this release, we've focused heavily on Docker integration and enhancing the `Dockerfile`
workflow, as well as some minor quality of life improvements for template files and run reports.

## 1,000 ⭐️🌟⭐️!

Before we dive into the release, we want to thank everyone for the initial support, as we passed
[1,000 stars on GitHub](https://github.com/moonrepo/moon) earlier this week! moon was announced back
in June, and to reach this milestone in roughly 3 months is very exciting. We greatly appreciate the
support, and to everyone that is using moon and providing feedback, we thank you from the bottom of
our hearts!

We have a very long roadmap ahead of us, but are very excited to bring all of these features to you,
and to improve the overall developer experience for your monorepos! Here's to 10,000 stars!

## First-class Docker support

[Docker](https://www.docker.com/) is a very popular tool that is typically a part of a developers
workflow, but is also a very tedious one, as `Dockerfile`s have to be manually curated for every
project. We aim to mitigate this problem by supporting Docker as a first-class feature, and by
introducing 2 new commands, [`moon docker scaffold`](../docs/commands/docker/scaffold) and
[`moon docker prune`](../docs/commands/docker/prune).

These commands will automate a `Dockerfile` as much as possible to effectively take advantage of
Docker's layer caching, multi-staged builds, to reduce the amount of manual `COPY` commands, to
reduce the overall size of the container or image, and much more. To demonstrate this, compare the
before and after `Dockerfile`s below!

```docker
FROM node:latest

WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

# Copy moon files
COPY ./.moon ./.moon

# Copy all package.json's and lockfiles
COPY ./packages/cli/package.json ./packages/cli/package.json
COPY ./packages/core-linux-arm64-gnu/package.json ./packages/core-linux-arm64-gnu/package.json
COPY ./packages/core-linux-arm64-musl/package.json ./packages/core-linux-arm64-musl/package.json
COPY ./packages/core-linux-x64-gnu/package.json ./packages/core-linux-x64-gnu/package.json
COPY ./packages/core-linux-x64-musl/package.json ./packages/core-linux-x64-musl/package.json
COPY ./packages/core-macos-arm64/package.json ./packages/core-macos-arm64/package.json
COPY ./packages/core-macos-x64/package.json ./packages/core-macos-x64/package.json
COPY ./packages/core-windows-x64-msvc/package.json ./packages/core-windows-x64-msvc/package.json
COPY ./packages/runtime/package.json ./packages/runtime/package.json
COPY ./packages/types/package.json ./packages/types/package.json
COPY ./package.json ./package.json
COPY ./yarn.lock ./yarn.lock
COPY ./.yarn ./.yarn
COPY ./.yarnrc.yml ./yarnrc.yml

# Install toolchain and dependencies
RUN moon setup

# Copy project and required files
COPY ./packages/types ./packages/types
COPY ./packages/runtime ./packages/runtime
# COPY . .

# Build the target
RUN moon run runtime:build
```

```docker
#### BASE
FROM node:latest AS base
WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

#### WORKSPACE
FROM base AS workspace
WORKDIR /app

# Copy entire repository and scaffold
COPY . .
RUN moon docker scaffold runtime

#### BUILD
FROM base AS build
WORKDIR /app

# Copy workspace skeleton
COPY --from=workspace /app/.moon/docker/workspace .

# Install toolchain and dependencies
RUN moon setup

# Copy source files
COPY --from=workspace /app/.moon/docker/sources .

# Build the target
RUN moon run runtime:build

# Prune workspace
RUN moon docker prune
```

> View the official [Docker usage guide](../docs/guides/docker) for an in-depth walkthrough of all
> these new features!

## Frontmatter for template files

We released [templates and the generator in v0.14](./v0.14) for quick and easy code generation.
Since it was the initial release, it provided the bare minimum of features for common workflows.
We'll continually improve this system over each release, and have done just that for this release,
as all template files now support [frontmatter](../docs/guides/codegen#frontmatter)! Frontmatter is
a mechanism for declaring _per-file configuration_, and is denoted by `---` delimiters at the top of
the file.

This allows you to do some really cool stuff, like overriding the destination path of the file using
the `to` field, as well as taking full advantage of Tera's filters and conditional rendering!

```twig title="templates/react/components/base.tsx"
{% set component_name = name | pascal_case %}

---
to: components/{{ component_name }}.tsx
---

export function {{ component_name }}() {
	return ;
}
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.15.0) for a
full list of changes.

- Run reports (via `--report`) now include additional information, like the total duration, and
  estimated time savings.
  - The [moonrepo/run-report-action](https://github.com/marketplace/actions/moon-ci-run-reports) has
    been updated with this information.
- Improved pnpm integration for Go/Rust binaries shipped in node modules.

## What's next?

Expect the following in the v0.16 release!

- Quality of life improvements for TypeScript.
- Per-project overrides for language/tool versions.

---

## moon v0.16 - Per-project tool versions and TypeScript improvements

With this release, we've landed a long standing request of supporting project-level overrides for
tools configured in the workspace, as well as some quality of life improvements for TypeScript.

## Per-project tool version overrides

Since moons inception, our [toolchain](../docs/concepts/toolchain) has only supported a single
version of a tool (Node.js), as we wanted to embrace the single version policy and encourage all
consumers to keep their tooling version consistent across all projects for reliability. While this
works flawlessly, it's not entirely realistic, as many companies have legacy projects that are stuck
on older versions for whatever reason, and integrating them into moon was rather difficult.

Well no more! We've refactored our toolchain to support tool overrides on a project-by-project
basis. Since we only support Node.js at the moment, this can be achieved with the new
[`workspace.node.version`](../docs/config/project#node) setting in
[`moon.yml`](../docs/config/project).

For example, if your workspace Node.js version is configured as v18.

```yaml title=".moon/workspace.yml"
node:
  version: '18.0.0'
```

You can now override this version at the project-level. Let's go with v14.

```yaml title="/moon.yml"
workspace:
  node:
    version: '14.0.0'
```

When running a task from a project with overrides, the toolchain will download, install, and
configure the new version behind the scenes. This new version will then be used to install
dependencies and execute the tasks commands.

> Although we now support overriding the tool version, the workspace configured package manager
> (`node.packageManager`) and associated version cannot be overridden. This is unlikely to change.

## Per-project dependency installs

Because of the toolchain refactor above, we now support per-project dependency installs as a welcome
side-effect. This is a necessary step in supporting new languages, especially for those that don't
install dependencies in the workspace for all projects, and must install them per project.

This also means that moon now supports non-`package.json` workspaces! If your repository _is not_
using npm/pnpm/yarn workspaces, or a project _is not_ listed within the workspaces glob list,
dependencies will be installed within the project.

## TypeScript improvements

### Routing `outDir` to the cache

A requirement for using project references is that each project must compile declarations (`.d.ts`)
so that consumers/dependents can resolve type information. While this makes sense, it becomes rather
unfortunate as each project folder is now littered with the declaration outputs, which are typically
gitignored.

To improve this experience, we're introducing a new setting
[`typescript.routeOutDirToCache`](../docs/config/toolchain#routeoutdirtocache), that will update the
`outDir` compiler option of _all_ projects to route to moon's cache directory (which should already
be gitignored). This will standardize the use of project references for the entire repository.

For example, a project at "packages/components" will route to the following output directory:

```json title="/tsconfig.json"
{
  // ...
  "compilerOptions": {
    // ...
    "outDir": "../../.moon/cache/types/packages/components"
  }
}
```

> If you require declarations to live within the project, for example an npm package that ships
> types, you should introduce an additional configuration to handle this, like
> `tsconfig.build.json`.

### Mapping project references as `paths`

moon automatically keeps TypeScript project references in sync with the
[`typescript.syncProjectReferences`](../docs/config/toolchain#syncprojectreferences) setting, which
is great, but we can take it further. With the new
[`typescript.syncProjectReferencesToPaths`](../docs/config/toolchain#syncprojectreferencestopaths)
setting, project references (either synced or explicitly defined) will _also_ be mapped to the
`paths` compiler option, automating the list of import aliases.

For example, if a reference has the package name `@brand/components`, the `paths` will be mapped
with:

```json title="/tsconfig.json"
{
  // ...
  "compilerOptions": {
    // ...
    "paths": {
      "@brand/components": ["../shared/components/src/index.ts"],
      "@brand/components/*": ["../shared/components/src/*"]
    }
  },
  "references": [
    {
      "path": "../shared/components"
    }
  ]
}
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.16.0) for a
full list of changes.

- Template files can now be suffixed with `.tera` or `.twig` for
  [syntax highlighting](../docs/guides/codegen#file-extensions).
- We now display more commands and information when running tasks.
- Declare implicit task dependencies with a new [`runner.implicitDeps`](../docs/config/workspace)
  setting.

## What's next?

Expect the following in the v0.17 release!

- Webhooks for important pipeline events (for real this time)!
- YAML anchors and references in config files.
- And [many more](https://github.com/moonrepo/moon/issues/356)...

---

## New VS Code extension!

import Image from '@site/src/components/Image';

We're very excited to announce the initial release of our Visual Studio Code extension!

If you're a huge VS Code fan like us, you most likely use extensions in your everyday workflow. We
want to enhance this experience by providing a fully integrated and interactive moon console! Here's
a preview of what it looks like:

Excited?? Want to learn more? Check out the official
[moonrepo.moon-console](https://marketplace.visualstudio.com/items?itemName=moonrepo.moon-console)
marketplace page, or read the [official documentation](../docs/editors/vscode). This is only the
first iteration of the extension. Expect more advanced features in the future, like...

- Schema validation for configuration files
- Autocompletion for configuration files
- Automatic running/building of projects in the background
- File type association
- Integrated language server
- And much more!

---

## moon v0.17 - Webhooks, extended YAML, and improved runtime performance

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

With this release, we're landing the first iteration of our notifier service, starting with
webhooks! We've also spent some time working on quality of life improvements.

## Breaking changes

To start, we have a few breaking changes this release to be aware of!

### Minor changes to ID formatting

An ID refers to many things — project names, task names, target segments, so on and so forth. When
parsing these values, we format them to remove unwanted characters, as these IDs are used in many
contexts, many of which need to be strict.

Previously, we would remove unwanted characters entirely. Instead, we now replace them with dashes
(`-`) for better readability. Take the following for example:

| ID         | Old       | New        |
| :--------- | :-------- | :--------- |
| domain.com | domaincom | domain-com |
| build:esm  | buildesm  | build-esm  |

### Task `type` has been renamed to `platform`

This setting was renamed for a few reasons. To start, tasks actually have a
[type internally](../docs/concepts/task#types) that is not configured, but is inferred based on
what's configured. This was a bit confusing.

And secondly, our toolchain refers to language integrations as platforms, and since this setting
determines which tool to run with, we wanted to align on the platform terminology.

```yaml
tasks:
  clean:
    command: 'rm -rf ./dist'
    type: 'system'
```

```yaml
tasks:
  clean:
    command: 'rm -rf ./dist'
    platform: 'system'
```

> Because of this change, the `$taskType` token was also renamed to `$taskPlatform`!

## Webhook events (experimental)

Looking to gather metrics for your pipelines? Gain insight into run durations and failures? Maybe
you want to send Slack or Discord notifications? With our new notifier system, this is now possible
through webhooks!

Simply enable the [`notifier.webhookUrl`](../docs/config/workspace#webhookurl) setting to start
receiving events from your CI environments.

```yaml title=".moon/workspace.yml"
notifier:
  webhookUrl: 'https://api.company.com/some/endpoint'
```

> View the [official guide on webhooks](../docs/guides/webhooks) for a full list of events and an
> example payload structure!

## YAML anchors and aliases

We've updated our YAML configuration files to support extended syntax,
[anchors (`&`) and aliases (`*`)](https://support.atlassian.com/bitbucket-cloud/docs/yaml-anchors/).
With this new syntax, you're now able to reduce the amount of duplication required in your config
files, especially when declaring tasks, as demonstrated below!

```yaml
tasks:
  astro:
    command: 'astro'
    local: true

  dev:
    command: 'astro dev'
    inputs:
      - '@group(astro)'
    local: true

  build:
    command: 'astro build'
    inputs:
      - '@group(astro)'
    outputs:
      - 'dist'

  check:
    command: 'astro check'
    inputs:
      - '@group(astro)'
    deps:
      - '~:typecheck'

  preview:
    command: 'astro preview'
    inputs:
      - '@group(astro)'
    deps:
      - '~:build'
    local: true
```

```yaml
_astro: &astro
  command: 'astro'
  inputs:
    - '@group(astro)'

tasks:
  dev:
    

## VS Code extension

If you missed the [announcement earlier this week](./vscode-extension), we released the initial
version of our new VS Code extension! Give it a try and
[refer to the documentation](../docs/editors/vscode) for more information.

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.17.0) for a
full list of changes.

- Increased runtime performance and reduced memory consumption.
- Template enum variables can now define objects for their
  [`values`](../docs/config/template#values).
- Task `deps` can now omit the `~:` prefix for tasks within the current project.
- The `moon check` command can now use the `--report` option.

## What's next?

Expect the following in the v0.18 release!

- Workflow improvements for `moon init`.
- Benchmarks and performance tuning.
- Individual stdout/stderr log files when running tasks.

---

## moon v0.18 - Improved configuration and initialization flow

import Image from '@site/src/components/Image';

Happy Halloween 🎃 👻! With this spooky release, we've focused heavily on our internals and
benchmarking performance metrics, so it's rather light on new features, but we still have some to
show!

## Improved projects configuration

When moon initially launched, it required defining all
[`projects`](../docs/config/workspace#projects) using a map. In v0.3, we added support for globs to
ease the burden of defining many projects. At this point, you had to choose between the 2 patterns,
which wasn't always ideal.

To improve upon this, you can now define a map _and_ globs using a 3rd pattern, like so.

```yaml title=".moon/workspace.yml"
projects:
  globs:
    - 'apps/*'
    - 'packages/*'
  sources:
    www: 'www'
```

## Improved `moon init` flow

The `moon init` command hasn't changed much since our v0.1 release, and with many new features and
configurations over these last 18 releases, the initialization flow has fallen quite behind. We felt
it was the perfect time to modernize this command a bit.

On top of automatically detecting settings from the environment, the command will also now prompt
you with additional questions while configuring Node.js or TypeScript. Here's an example of this
flow:

Furthermore, the command also supports enabling a new tool (appending configuration to
`.moon/workspace.yml`) into an _existing_ moon repository, by running `moon init --tool `.

## Customize `node` execution arguments

moon manages the Node.js binary in our toolchain, and runs all Node.js based tasks using this
binary, instead of relying on the binary found in the developer's environment. Because of this, how
`node` is executed is abstracted away from end users.

What if you wanted to use an [experimental loader](https://nodejs.org/api/esm.html#loaders) and
execute TypeScript code at _runtime_? Or to preserve symlinks? Well, you couldn't... but no longer,
as we've added a new setting, [`node.binExecArgs`](../docs/config/toolchain#binexecargs), that
allows additional `node` [CLI arguments](https://nodejs.org/api/cli.html#options) to be defined,
that will be passed to _all_ executions.

```yaml title=".moon/workspace.yml" {2-4}
node:
  binExecArgs:
    - '--loader'
    - '@boost/module/loader'
```

> Learn more about the
> [Boost module loader](https://boostlib.dev/docs/module#ecmascript-module-loaders)!

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.18.0) for a
full list of changes.

- Default Node.js version has been updated to v18.12 (the new LTS) from v16.17.
- Updated the `moon check` command to support an `--all` flag.
- Improvements to how we store stdout/stderr logs for ran targets.
- Work tree dirty checks when running migration commands.

## What's next?

Expect the following in the v0.19 release!

- Laying the groundwork for _remote caching_!
- An in-repo secrets management layer.
- Performance and affected improvements.

---

## moon v0.19 - Remote caching beta, affected files, and graph optimization

import Image from '@site/src/components/Image';

With this release, we've focused heavily on our remote caching architecture. Since this is a massive
task that requires much work behind the scenes, this overall release is rather light.

## Remote caching beta

A major request for moon is to support remote caching. This is a critical feature that allows
artifacts to be shared across machines and environments, by storing them in a cloud storage
provider, like AWS S3.

We've been working on this feature for months, primarily behind the scenes building the necessary
services and tools, and we've finally reached a point where we could integrate it with moon
directly! However, since this feature is very complex, it's not yet available to the public, but
while you wait, you can sign up for beta access! Jump over to the
[official remote caching documentation for more information](../docs/guides/remote-cache)!

We'll be working on remote caching through every release, continually polishing the implementation,
supporting new features, enabling new regions, calculating pricing, so on and so forth. So stay
tuned!

## Affected files filtering

We've spent a good portion of this release working on affected detection for projects and tasks,
primarily through `--affected`, and have uncovered and fixed a handful of edge cases. With that
being said, we asked ourselves, "How could we improve the developer experience even more"? What
about passing the affected files list to the running task?

And that's exactly what we've done through the new task option
[`affectedFiles`](../docs/config/project#affectedfiles)! This option works in unison with the
`--affected` option, enabling some awesome functionality. Given the following config:

```yaml title="moon.yml" {6}
tasks:
  lint:
    command: 'eslint'
    options:
      affectedFiles: true
```

When we run this task _without_ `--affected`, it will append an argument for the current directory
(`.`). This will lint the entire project.

```shell
# moon run project:lint
eslint .
```

However, when we run this task _with_ `--affected`, and have have touched files in the working tree,
it will now append an argument for each file that matches the task's `inputs`. This will now only
lint the provided files, _instead_ of the entire project.

```shell
# moon run project:lint --affected
eslint ./file.ts ./another/file.ts
```

This functionality is _perfect_ pre-commit hooks, and as such, we've added a
[guide for utilizing this pattern with Git hooks](../docs/guides/vcs-hooks)!

## Dependency graph optimizations

Our dependency graph determines which targets to run, what tools to install, projects to sync, and
in which order. It's a very complex directed acyclic graph, and has only gotten more complicated
over the year, especially with the introduction of project-level tool overrides.

We decided to rewrite the dependency graph from the ground up to mitigate many of these issues,
optimize nodes and edges, reduce the number of data cloning, and to increase the overall
performance. Everything will still work exactly the same (all of our existing tests passed with no
issue)!

On top of this, we've also migrated the internals of moon to a new hashing algorithm that should see
a 5-10% increase in performance!

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.19.0) for a
full list of changes.

- Package managers in the toolchain are now installed in isolation, instead of through Node.js.
- JSON files will now respect the closest `.editorconfig` file.
- Webhook payloads now include information about the running CI/CD environment.
- Generator can now merge JSON/YAML template files.

## What's next?

Expect the following in the v0.20 release!

- Continuation of remote caching work!
- Performance improvements for output hydration.
- Toolchain improvements.

---

## Integrating TypeScript in a monorepo

A common question in the JavaScript ecosystem is how to integrate TypeScript in a monorepo. This is
a fair question, as there's no in-depth source of truth, or one perfect way of doing it. However, we
took it upon ourselves to answer this question!

Based on our experience scaling and managing frontend repositories in open source and large
companies like Airbnb and Coinbase, we're happy to
[announce an in-depth guide on using TypeScript project references in a monorepo](../docs/guides/javascript/typescript-project-refs)!

We hope you find this guide useful, and if you have any questions, feel free to discuss them in our
[Discord community](https://discord.gg/qCh9MEynv2)!

---

## moon v0.20 - Toolchain, caching, and hydration improvements

With this release, we've focused heavily on future proofing our toolchain and how it integrates with
moon. We've also landed a handful of quality of life improvements.

## Breaking changes

To start, we have a few breaking changes this release to be aware of!

### Moved toolchain settings

The [`.moon/workspace.yml`](../docs/config/workspace) config file was getting rather bloated and
complicated, as it contained the projects list, settings for each toolchain language, and settings
for each supported service (runner, generator, etc). Furthermore, this file will keep getting larger
with each new language and service we support.

To future proof moon, and to land as many breaking changes before an official v1, we've decided to
move toolchain specific settings into a new file, [`.moon/toolchain.yml`](../docs/config/toolchain).
This new file will house all language and dependency manager specific settings.

To migrate, move the `node` and `typescript` settings from `.moon/workspace.yml` to
`.moon/toolchain.yml`.

```yaml title=".moon/toolchain.yml"
node:
  # ...

typescript:
  # ...
```

### Moved project-level overrides

Continuing with the changes above, we've also moved the `workspace.node` and `workspace.typescript`
from [`moon.yml`](../docs/config/project) into a new parent field, `toolchain`. We think this makes
more sense.

```yaml title="moon.yml"
# Before
workspace:
  node:
    version: '...'

# After
toolchain:
  node:
    version: '...'
```

## Future of the toolchain

We're really proud of our toolchain, as it avoids an array problems that developers deal with on a
day to day basis, primarily around running tasks using the wrong version of Node.js or their chosen
package manager. While we're in the process of supporting additional languages, starting with
[Deno](https://deno.land/), we had an idea... Since this is basically a better "version manager for
tools", why not extract this out into something else?

And that's what we plan to do! Before we do so, we've had to make some architectural changes, many
of which have landed in this release. During this process, we were able to implement an even better
toolchain, polish many of the edge cases, and improve performance! Stay tuned for more information
on this new tool!

## Increased output hydration by 8-10x

In moon, hydration is the concept of unpacking an existing hashed artifact into a
[task's outputs](../docs/config/project#outputs) during a cache hit. In our previous implementation,
we would delete all existing outputs before unpacking the archive to ensure a clean slate and to
avoid stale files. While this worked, it wasn't the most performant, taking about 280ms for 1,000
files (which is still reasonably fast!).

In our new implementation, we now utilize a smart file tree diffing algorithm that will only unpack
files _with different content_, and will automatically remove stale files in the process. This has
resulted in a 10x performance increase, taking about 30ms! Multiply this by many projects, the
results should be very apparent.

We hope you enjoy this improvement, as it's the first of many to come!

## Cache any and all targets

By default, all [targets](../docs/concepts/target) that produce outputs are cached and archived. For
targets that _do not_ produce outputs, like testing, linting, and typechecking, these are not
cached. This will result in slower CI times as they are continuously ran, even if nothing has
changed. However with our new [remote caching](../docs/guides/remote-cache) layer, we can skip these
from running entirely!

To achieve this, we've added a new setting to [`.moon/workspace.yml`](../docs/config/workspace)
called [`runner.archivableTargets`](../docs/config/workspace#archivabletargets). This setting
accepts a list of targets that should be archived, regardless of whether or not they produce
outputs.

For example, if we want to cache and archive testing, linting, and typechecking, we can define the
following:

```yaml title=".moon/workspace.yml"
runner:
  archivableTargets:
    - ':lint'
    - ':test'
    - ':typecheck'
```

## Path handling in generator templates

Our code generation is powered by [Tera](https://tera.netlify.app/docs/#built-ins), a templating
engine with a ton of built-in utilities. However, it does not provide utilities for file paths, and
as such, we now provide `path_join` and `path_relative` filters.

```twig
{{ some_path | path_relative(from = workspace_root) }}
```

We also now inject variables for the working directory, destination, and workspace root. This will
help with custom paths, especially within frontmatter!
[View the codegen docs for more information](../docs/guides/codegen#variables).

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.20.0) for a
full list of changes.

- Added `vcs.remoteCandidates` to `.moon/workspace.yml` to customize the remotes for Git to query
  against.
- Added support for `moduleSuffixes` and `moduleDetection` in TypeScript `tsconfig.json` compiler
  options.
- YAML files will now respect the closest `.editorconfig` file.
- Refactored terminal output for bette readability.

## What's next?

Expect the following in the v0.21 release!

- An interactive dependency and project graph visualizer.
- A more performant project graph.
- More quality of life improvements for affected files.

---

## moon v0.21 - Tiered language support with initial Go, PHP, Python, Ruby, and Rust

import Label from '@site/src/ui/typography/Label';
import Image from '@site/src/components/Image';

Happy Holidays 🎄☃️! With our last release of the year, we're very excited to announce our tiered
language support structure, which lays the foundation for turning moon into a multi-language build
system! On top of this, we've worked heavily on bug fixing, optimizations, and overall quality of
life improvements.

## New tiered language support

The most common question we receive is whether we plan to support additional languages besides
Node.js, with Rust, Deno, and Bun being top of that list. Adding new languages is non-trivial, as we
need to build abstractions that support and integrate with the language's ecosystem, primarily
dependency managers and resolution algorithms.

This is a very large upfront cost, with a huge time and resource commitment. To reduce this burden,
we're introducing a tiered support structure, so that languages can be incrementally integrated into
moon and adopted by consumers.

The tiers break down as follows:

- &nbsp; &nbsp; **No direct integration** - Tool is not
  directly supported in moon, but can still be ran using the
  ["system" task platform](../docs/faq#can-we-run-other-languages), which expects the tool to exist
  in the current environment.
- &nbsp; &nbsp; **Project categorization** - Projects can
  configure their primary [language in `moon.yml`](../docs/config/project#language), and have a
  dedicated Rust crate for metadata.
- &nbsp; &nbsp; **Ecosystem platformization** - moon deeply
  integrates with the language's ecosystem by parsing manifests, lockfiles, and other semantic files
  to infer dependencies, tasks, and other necessary information.
- &nbsp; &nbsp; **Toolchain integration** - Language is
  directly supported in the toolchain, configured in
  [`.moon/toolchain.yml`](../docs/config/toolchain), and will automatically be downloaded and
  installed.

To learn more about our currently supported languages and their tiers,
[jump to the official documentation](/docs#supported-languages).

> One important facet we'd like to express, is that _all_ languages and tools fall into tier 0. Feel
> free to use anything you'd like as a task command!

## Basic support for Go, PHP, Python, Ruby, and, Rust

As announced above, we now incrementally support new languages, and have integrated the following 5
languages with tier 1 support: Go, PHP, Python, Ruby, and, Rust! Start using these languages today
by setting the [`language`](../docs/config/project#language) field in `moon.yml`, or by letting moon
infer the language based on files in the project root (for example, `Cargo.toml` is Rust).

```yaml title="/moon.yml"
language: 'rust'

tasks:
  build:
    command: 'cargo build'
    inputs:
      - 'src/**/*'
      - 'Cargo.toml'
  test:
    command: 'cargo test'
    inputs:
      - 'src/**/*'
      - 'tests/**/*'
      - 'Cargo.toml'
```

> Because these languages are tier 1, moon _does not_ install the language automatically, and will
> require the command to already exist in the environment. Furthermore, the project language will
> automatically set all task's `platform` to "system", at least until it's supported directly in the
> toolchain.

## Interactive project and dependency graphs

Thanks to the amazing contribution from [Diptesh Choudhuri](https://github.com/IgnisDa), we now have
interactive project and dependency graphs when running the
[`moon project-graph`](../docs/commands/project-graph) and
[`moon dep-graph`](../docs/commands/action-graph) commands respectively.

This is only the first iteration of these graphs. Expect more advanced features in the future, like
filtering, node/edge inspection, exporting, and more!

## New `--updateCache` command line option

Our caching layer is pretty powerful, as it helps to avoid tasks from running unnecessarily.
However, there are situations where you need to refresh or force update the cache outside of the
[`inputs`](../docs/config/project#inputs) list. This is currently achieved with the
[`--cache`](../docs/commands/overview#caching) option, like `moon --cache off run ...`, but this is
non-ideal for a few reasons:

1. It disables _all caching_, which means dependency installs/dedupes will continually be ran. This
   adds a lot of unwanted overhead.
2. It requires you to backspace in the terminal to add the option _before_ `run` or `check`, as it's
   a global option. A little tedious but important for experience.

So to work around these limitations, we've added a new `--updateCache` (or `-u`) to both
[`moon run`](../docs/commands/run) and [`moon check`](../docs/commands/run), which will bypass
reading any existing cache items, but will force update the cache base on the latest run.

```shell
$ moon run app:build --updateCache
```

## New multi-status affected filtering

We support running tasks based on affected files using the
[`moon run --affected`](../docs/commands/run) command, which is great for reducing the amount of
tasks being ran, and for applying code quality tooling like Git hooks. However, you were only able
to apply a single status filter, like "deleted" or "modified", which was non-ideal... but no more!

You can now apply multiple statuses by passing the `--status` option multiple times.

```shell
$ moon run :lint --affected --status modified --status added
```

This pairs nicely with the recent
[`affectedFiles` task option](../docs/config/project#affectedfiles) changes!

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.21.0) for a
full list of changes.

- Refactored project and dependency graphs for improved performance.
- Added args and env var variants to the `affectedFiles` task option.
- Added `--minimal` to `moon init` for quick scaffolding and prototyping.

## What's next?

Expect the following in the v0.22 release!

- Generalized hashing for use in any context (improved deps installation).
- More work on language integrations.

---

## What's in store for 2023

Happy new year! Let's start 2023 by reflecting on last year and diving into our tentative year long
roadmap.

## Year 2022 in review

The original concept and
[first commit of moon](https://github.com/moonrepo/moon/commit/62267e3ccda7a45c2e9355fcbddba577ae54403d)
(codenamed monolith) landed October 23rd, 2021. Eight months later, we
[launched an alpha of moon](https://twitter.com/tothemoonrepo/status/1527467865200136192) to the
public on May 19th, 2022. Since then, we've landed 21 amazing releases based on feedback from the
community and our long-term vision, with some such features as:

- Linux musl, macOS silicon, and ARM support
- Full Node.js/JavaScript ecosystem support
- End-to-end caching and hashing of build artifacts
- Streamlined configuration
- Improved developer experience
- Massive performance improvements
- Automatic cache cleaning
- Code generation / scaffolding
- Dockerfile integration
- Remote caching
- New language agnostic toolchain
- Onboarding of 5 new languages: Rust, Go, PHP, Python, Ruby
- Rewritten project and dependency graphs
- Project-level toolchain overrides
- Project specific caching
- VSCode extension
- 2 GitHub actions
- ...and so much more!

We're very proud with the quality and amount of features we've released in a 7 month timeframe. On
top of this, our [GitHub stars](https://github.com/moonrepo/moon/stargazers) have steadily passed
the 1k mark, [npm](https://www.npmjs.com/package/@moonrepo/cli) downloads are 500 a week and
growing, and our [Twitter](https://twitter.com/tothemoonrepo) isn't doing too bad. This is only the
start, and we're not planning to go anywhere!

## Path to an official v1 release

A common question we receive is "When is v1 going to be released?", as some consumers are weary of
using a "beta" tool. We definitely understand, and as such, have posted a
[high-level overview](https://github.com/moonrepo/moon/issues/491) of what we're hoping to land
before we tag an official v1 release. It basically boils down to landing breaking changes (mainly
around configuration) before v1, so that we avoid bumping to a v2 or v3 unnecessarily. We also want
to land our [toolchain changes](#launching-proto) and [remote caching](#launching-moonbase)
improvements before then.

Our current timeframe is by end of Q1, if not, early Q2.

## Launching moonbase

We haven't mentioned this name publicly yet, but now seems like the perfect time! For the past 6
months we've been working a new web application and service called moonbase, which pairs nicely with
moon, as it provides additional functionality that can only be achieved by persisting information
across runs.

To start, this service provides [remote caching](/docs/guides/remote-cache), which we're already
using in production. At this point in time, objects are stored in our moonrepo S3 buckets, but one
of our major goals is to support storing objects in your private buckets, supporting additional
cloud providers like Google Cloud and Azure, and in the long-term, a self-hosted / on-premises
solution.

But that's not all! moonbase will integrate deeply with [continuous integration](/docs/guides/ci)
pipelines to generate insights, capture metrics, and provide near real-time dashboards. Our goal is
to provide a holistic overview of your entire repository.

moonbase with publicly available remote caching is slated for end of Q1. CI integration is
tentatively slated for Q2. We have even more features that we'll reveal in the future, so stay
tuned!

## Launching proto

Another tool we haven't mentioned yet is proto (name still in flux). proto is a standardized version
manager for programming languages and dependency managers. We've basically extracted our
[toolchain](/docs/concepts/toolchain) into a standalone library, as it's super beneficial for
projects and developers not using moon. It provides all the functionality you'd expect from a
version manager:

- Downloading and installing specific versions
- Automatic version detection
- Updating PATH with the applicable version
- Generating shims
- Pinning shell, local, and global versions

So how's this different from existing version managers like nvm or volta? To start, it's written in
Rust so it's _fast_ and doesn't suffer from being Bash only. Because of this, it's also
multi-platform and will work on Windows. But the biggest different is that proto is language
agnostic and will support multiple languages. To start, it supports Node.js and Deno, but will be
expanded to support our other toolchain languages like Bun, PHP, Ruby, and Python. Another cool
feature is that it also manages versions of dependency managers like npm, yarn, and pnpm!

We're planning to launch proto at the start of Q2.

## Expanding language support

Our initial goal for moon was to provide a first-class build system for the frontend ecosystem that
focused heavily on automation and the developer experience. We believe we've accomplished this goal,
but of course, nothing is ever actually complete, and so JavaScript, TypeScript, and Node.js support
will continually be improved.

However, that's not the entirety of the frontend ecosystem, as [Deno](https://deno.land/) and
[Bun](https://bun.sh/) have been gaining traction this past year, and of course, moon will support
both of them as first-class platforms by end of year.

Furthermore, we recently landed tier 1 support for 5 new languages: Rust, Ruby, PHP, Python, and Go.
Our end of year goal for these languages is to provide full tier 2 support. Tier 3 support is still
an unknown, as we need to investigate the best possible way to integrate these languages into the
toolchain (this work is ongoing). We'll also add new languages based on demand.

With all that being said, this is our tentative timeline around
[language support](/docs#supported-languages) (which may shift at any time):

- **Q1**
  - Tier 1 support for Bun.
  - Tier 2 support for Deno.
- **Q2**
  - Tier 2 support for Bun, PHP.
  - Tier 3 support for Deno.
- **Q3**
  - Tier 2 support for Ruby, Python.
  - Tier 3 support for Bun.
- **Q4**
  - Tier 2 support for Rust, Go.

## Supporting release workflows

moon currently excels at organizing projects, running tasks, and building artifacts, but it has no
support for release workflows. This is everything from capturing changes, bumping versions,
generating changelogs, and publishing to upstream registries. If you use
[Lerna](https://github.com/lerna/lerna) or [changesets](https://github.com/changesets/changesets),
you should be very familiar with this workflow.

Since moon supports monorepos and has in-depth knowledge of the project graph, we can support
release workflows with ease. Our goal is to support this workflow (for all languages) from start to
finish by end of year, ideally much sooner than that!

## More repository management tooling

The other aspect of moon is that it's a repository management tool as well as a build system. We
want to embrace this even further by providing explicit functionality or automation when applicable.
Some examples of this are in-repository secrets management, git hooks management, code ownership and
quality tooling, code review helpers, repository/configuration linting, a moon DSL, and much much
more.

---

## moon v0.22 - New pipeline, hashing, and caching, with Turborepo migration

import Label from '@site/src/ui/typography/Label';
import Image from '@site/src/components/Image';

It's the first release of the year, and with this release, we're landing some quality of life
infrastructure and workflow improvements!

## New action pipeline

When running targets, we generate a graph of actions to execute in order within the action runner.
An action is one of "setup toolchain", "install dependencies", "run target", so on and so forth. Our
action runner would then spawn threads for every action using the [Tokio](https://tokio.rs/)
runtime. While this worked great, concurrency was entirely abstracted away from us.

To mitigate this problem, we've implemented a new system for executing actions known as the action
pipeline (or simply pipeline), which implements a dynamically scaling thread pool on top of Tokio.
This provides us with more control over concurrency, starting with the new `--concurrency` option,
which restricts the number of threads (or CPU cores).

```shell
$ moon run :build --concurrency 2
```

## Expanded hashing functionality

When we run targets in the pipeline, we hash a collection of inputs to calculate whether to continue
running or to exit early. This functionality has been extremely beneficial for optimizing the
pipeline, and so, we've expanded the hasher for other use cases. To start, the following 2 workflows
now utilize the hasher:

- When determining to auto-install dependencies (`npm install`, etc), we now hash all production,
  development, and peer dependencies from applicable manifests (`package.json`). This has resulted
  in more accurate installs, as we're no longer inadvertently installing when a non-dependency field
  is modified in a manifest. On top of this, will still take into account lockfile modified
  timestamps.
- When generating the project graph, we now hash all sources, aliases, and configuration files, to
  determine whether to load the project graph from the local cache.

## Project graph is now cached

Because of the hashing improvements above, we're now able to cache the entirety of the project graph
into local cache. Depending on how many projects are in your workspace, you may see performance
improvements on subsequent runs as we're no longer re-building the project graph over and over
everytime the `moon` binary is ran.

## Migrate from Turborepo

Turborepo is a popular task runner for Node.js based monorepos, but doesn't support all the
functionality that moon does. If you're looking to prototype moon, or migrate from Turborepo to moon
holistically, we now support a new command
[`moon migrate from-turborepo`](/docs/commands/migrate/from-turborepo).

This command will migrate the `turbo.json` file to moon applicable configuration files!

```shell
$ moon migrate from-turborepo
```

## Breaking changes

### Renamed events

Because of the runner -> pipeline changes above, the `runner.*` [webhook](/docs/guides/webhooks)
events were renamed to `pipeline.*`.

### Updated CLI options

Renamed the `--upstream` option to `--remote`, to better align with Git terminology, and removed the
`--report` option from `moon check` and `moon run` commands. Reports are now always created.

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.22.0) for a
full list of changes.

- Added Bun as a tier 1 language (doesn't do much at the moment).
- Added a [`versionConstraint` setting](/docs/config/workspace#versionconstraint) in
  `.moon/workspace.yml` that enforces a requirement on the running moon binary.
- Updated the [`project` fields](/docs/config/project#project) in `moon.yml` to be optional,
  excluding `description`.
- Internal improvements to remote caching and artifact uploading.

## What's next?

Expect the following in the v0.23 release!

- Improved task inheritance workflow.
- Glob support in task `outputs`.
- Project-level environment variables.

---

## moon v0.23 - Scoped task inheritance, and project config updates

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Button from '@site/src/ui/Button';

With this release, we're launching the next iteration of our task inheritance model, as well as
quality of life improvements for project configuration.

## Developer survey

Before we dive into this new release, we have a quick survey for everyone. We know how everyone
feels about surveys, but this one is real quick, only a few minutes, and is mostly multiple choice
questions.

We're looking for feedback on moon itself, what features you're looking for, what you currently do
not like, how you're currently using monorepos, your development workflows, so on and so forth. We'd
very much appreciate it if you could engage with this survey!

  

## Improved task inheritance model

One of the guiding principles behind moon is to simplify repository maintenance, with task
management being top of list. We weren't happy with the current state of things, as every build
system and task runner that exists always opted for per-project task management, which is a massive
amount of overhead and tech debt in the long run. To combat this, moon was designed from the
ground-up using a task inheritance model, where "global" tasks were defined in
[`.moon/project.yml`](/docs/config/tasks), with per-project tasks still being an option with
[`moon.yml`](/docs/config/project).

While inheritance worked great, it did have some shortcomings, such as:

- With the addition of [new programming languages](/blog/v0.21), there's no way to easily define
  tasks for specific languages, that should only be inherited by specific projects.
- There's no way to differentiate tasks between applications or libraries, as they typically have
  different build/compilation systems.
- All of the problems above can be "solved" with
  [`workspace.inheritedTasks`](/docs/config/project#inheritedtasks) in all projects, but it's a
  maintenance headache.

We've been documenting a solution to these problems for many months now, and we're very excited to
finally release our new and improved task inheritance model that solves all of the problems above,
and opens the doors for future enhancements! Keep reading for more information.

### New `.moon/tasks.yml` (breaking)

To start, we renamed `.moon/project.yml` to `.moon/tasks.yml` as we want to emphasize that this
configuration file is for task inheritance functionality only. However, the semantics of this file
has _not_ changed, and is still "tasks to be inherited by _all_ projects".

```yaml title=".moon/tasks.yml"
$schema: 'https://moonrepo.dev/schemas/tasks.json'

tasks:
  # ...
```

> We'll automatically rename this file for you when running a `moon` command!

### New scoped tasks with `.moon/tasks/*.yml`

The biggest change to task inheritance is that tasks can now be scoped by a project's
[`language`](/docs/config/project#language) or [`type`](/docs/config/project#type) using the new
`.moon/tasks/.yml` or `.moon/tasks/-.yml` configuration files! Jump to the
[official documentation on task inheritance](/docs/concepts/task-inheritance) for more information
on how scoping works, the lookup order of files, and much more.

As a demonstration, you can scope tasks to Node.js projects with `.moon/tasks/node.yml`, Rust
applications with `.moon/tasks/rust-application.yml`, Go libraries with
`.moon/tasks/go-library.yml`, Ruby scripts with `.moon/tasks/ruby-tool.yml`, so on and so forth!

We're very excited for this feature, as it's something we personally needed, and we're sure you all
do as well. It also future proofs moon for new programming languages, additional implicit scenarios
to handle, and yet to be discovered functionality.

```yaml title=".moon/tasks/node.yml"
tasks:
  format:
    command: 'prettier --write .'
```

```yaml title=".moon/tasks/go.yml"
tasks:
  format:
    command: 'go fmt'
```

```yaml title=".moon/tasks/php.yml"
tasks:
  format:
    command: 'phpcbf .'
```

```yaml title=".moon/tasks/python.yml"
tasks:
  format:
    command: 'pylint .'
```

```yaml title=".moon/tasks/ruby.yml"
tasks:
  format:
    command: 'rubocop -l'
```

```yaml title=".moon/tasks/rust.yml"
tasks:
  format:
    command: 'cargo fmt --all --check'
```

### Moved `implicitDeps` and `implicitInputs` (breaking)

To standardize inheritance and expansion related functionality, we've moved the
`runner.implicitDeps` and `runner.implicitInputs` settings from `.moon/workspace.yml` to
[`.moon/tasks.yml`](/docs/config/tasks#implicitdeps) and
[`.moon/tasks/*.yml`](/docs/config/tasks#implicitinputs) and removed the `runner` prefix.

This allows for implicits to also be scoped accordingly and granularly. For example, projects can
now inherit dependency manager related files as implicit inputs on a per-language basis:

```yaml title=".moon/tasks/node.yml"
implicitInputs:
  - 'package.json'
```

```yaml title=".moon/tasks/go.yml"
implicitInputs:
  - 'go.mod'
```

```yaml title=".moon/tasks/php.yml"
implicitInputs:
  - 'composer.json'
```

```yaml title=".moon/tasks/python.yml"
implicitInputs:
  - 'pyproject.toml'
```

```yaml title=".moon/tasks/ruby.yml"
implicitInputs:
  - 'Gemfile'
```

```yaml title=".moon/tasks/rust.yml"
implicitInputs:
  - 'Cargo.toml'
```

## Project-level environment variables

Since moon's inception, tasks can be configured with pre-defined environment variables using the
[`env`](/docs/config/project#env-1) setting. These variables would then be passed to the command
during execution. This works perfectly for encapsulation, but becomes tedious when the same
variables are repeated for multiple tasks.

To remedy this, environment variables can now be defined at the top of
[`moon.yml`](/docs/config/project) using the top-level [`env`](/docs/config/project#env) setting.
Variables defined at the top-level will be inherited by all tasks in the current project, but will
not override task-level variables of the same name.

To demonstrate this, the following config:

```yaml title="/moon.yml"
tasks:
  dev:
    # ...
    env:
      TARGET_ENV: 'development'

  build:
    # ...
    env:
      TARGET_ENV: 'development'

  serve:
    # ...
    env:
      TARGET_ENV: 'development'
```

Can be rewritten as:

```yaml title="/moon.yml"
env:
  TARGET_ENV: 'development'

tasks:
  dev:
    # ...

  build:
    # ...

  serve:
    # ...
```

## Globs in task outputs

Another feature that's been around since moon's inception is task
[`outputs`](/docs/config/project#outputs), which only supported relative files and folders. For
historical reasons, it was the easiest solution at the time, but in practice, supporting more
granular control is better.

As such, task `outputs` now support glob patterns as well! This is perfect for restricting and
filtering down which files are cached in the artifact. However, be aware that during hydration (a
cache hit), all files _not matching the glob_ will be deleted, so ensure that critical files _do_
match.

To demonstrate this, if building a JavaScript project, you may want to include `.js` and `.css`
files, but exclude everything else (`.map`, etc).

```yaml title="moon.yml" {4,5}
tasks:
  build:
    command: 'webpack'
    outputs:
      - 'build/**/*.{js,css}'
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.23.0) for a
full list of changes.

- Updated `moon migrate from-turborepo` to preserve globs in outputs.
- Updated project graph to no longer cache when there's no VCS root.
- Updated pnpm to use the new `pnpm dedupe` command when the version is >= 7.26.0.

## What's next?

Expect the following in the v0.24 release!

- New `moon query tasks` command.
- New per-project `platform` setting.
- Token support in task `outputs`.
- TypeScript v5 support.

---

## Remote caching is now publicly available through moonbase

import Button from '@site/src/ui/Button';
import Image from '@site/src/components/Image';
import Logo from '../static/brand/moonbase/logo.svg';

We are proud to announce the launch of [moonbase](/moonbase) remote caching – a new solution that
helps moon developers streamline their build processes and save time.

  

Remote caching allows developers to cache artifacts across builds, improving the efficiency of their
Continuous Integration (CI) pipelines. This is accomplished by automatically caching build artifacts
when moon is run with moonbase [remote caching enabled](/docs/guides/remote-cache). In the event
that a CI run is executed with identical code, the cached artifacts are automatically pulled down,
reducing the time required to complete the build. In our tests, we have seen significant
improvements in CI times, upwards of 90%.

## What is moonbase?

You may be asking yourself, what is moonbase? [moonbase](/moonbase) is a new cloud service that
we've been working on to solve an array of problems in regards to repository and continuous
integration health.

The first problem on this list is [remote caching](/docs/guides/remote-cache), which has been in a
beta program for the past few months. We want to thank all the beta participants for testing our
systems!

We'll also be launching CI insights in the next few weeks. This is a system where we track all your
CI runs (via `moon ci`), and all moon tasks (actions) that ran within each job. We use this
information to track the health of your pipelines, catch regressions, alert on flakiness, and more!
But don't worry, this feature is opt-in.

We're very excited for moonbase! We have a massive roadmap ahead of us, but we're sure y'all will
enjoy everything that it has to offer.

  

## New homepage and product pages

As part of this release, we've updated our homepage, and added new product pages for both
[moon](/moon) and [moonbase](/moonbase). This includes new logos and typography, which we're very
excited for! This is only the beginning, as we're also working on additional behind the scenes
products. Stay tuned!

---

## moon v0.24 - Remote caching, interactive tasks, query improvements, and more

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Button from '@site/src/ui/Button';

With this release, we've polished our CLI experience and improved task interoperability.

## Remote caching now available

If you missed our announcement earlier this week,
[remote caching is now publicly available through our new service moonbase](/blog/moonbase)! If
you're looking to speed up your CI pipelines and share build artifacts between runs, moonbase can
help.

  

## Project-level task platform

In our previous release, [v0.23](./v0.23#project-level-environment-variables), we added support for
project-level environment variables. This is great as it helps to reduce duplication for projects
with many tasks. On that note, we wondered which configuration field we could apply similar
treatment, and as such, we've added a project-level [`platform`](/docs/config/project#platform)
setting.

When this setting is defined, all task's within the current project that have _not explicitly_
configured their `platform`, will inherit the project-level platform. If neither settings are
defined, we'll attempt to detect the correct platform based on the state of the project.

```yaml title="/moon.yml"
# Will set non-explicit task's platform to node
platform: 'node'

tasks:
  # Will be node
  dev: # ...

  # Will be node
  build: # ...

  # Will be system
  serve:
    # ...
    platform: 'system'
```

> This setting is _extremely useful_ for projects that contain multiple languages. Even more so once
> we land Bun and Deno support, as we'll need a way to differentiate JavaScript/TypeScript projects!

## Interactive tasks

When moon executes a task, it streams both stdout and stderr to the terminal _and_ captures the
output for later use. We do this for 2 reasons:

- We store stdout.log and stderr.log files in a tarball archive.
- We replay this captured output when executing a task that has been cached.

While this works, our approach is non-standard. Streams are either piped or inherited, not both!
Because of our custom abstraction around streams and output capturing, it disrupts stdin, breaking
all interactive commands. If you tried to run a task that prompted you with a question and were
unable to answer it, this is why!

To remedy this shortcoming, we're approaching this from 2 angles. The first is that all tasks marked
as [`local`](/docs/config/project#local) (or have caching disabled) will no longer capture streamed
output, and will instead stream natively, allowing interactivity out of the box, but only when
they're the only task being ran. This will cover the majority of use cases.

For the remaining use cases, we're introducing a new `--interactive` flag for
[`moon run`](/docs/commands/run). When this flag is provided, it will force the target into an
interactive mode.

```shell
$ moon run app:new --interactive
```

## Improved `moon query` commands (breaking)

The [`moon query projects`](/docs/commands/query/projects) and
[`moon query touched-files`](/docs/commands/query/touched-files) commands are useful for building
custom solutions and integrations on top of moon, but they weren't developer friendly as they output
large JSON blobs. To remedy this, we've updated both commands to output a simple human readable
format by default, and moved the JSON output behind a `--json` flag.

For example, `moon query touched-files` now outputs a list of absolute file paths separated by new
lines.

```
$ moon query touched-files
/moon/website/docs/commands/query/projects.mdx
/moon/crates/cli/tests/query_test.rs
/moon/crates/cli/src/commands/query.rs
/moon/website/blog/2023-02-13_v0.24.mdx
```

While `moon query projects` now outputs a list of project separated by new lines, where each line
contains the project name, source, type, and language.

```
$ moon query projects
report | packages/report | library | typescript
runtime | packages/runtime | library | typescript
types | packages/types | library | typescript
visualizer | packages/visualizer | library | typescript
website | website | application | typescript
```

We had 2 goals in mind for this change, the first was to make it easily readable, and the second was
for the default output to be easily parseable. We believe we've accomplished these goals!

## New `moon query tasks` command

To expand on the query improvements above, we wanted to provide a way to also query for tasks,
answering the question of "What tasks exists and for what projects?". And with this, we're
introducing a new [`moon query tasks`](/docs/commands/query/tasks) command!

```
$ moon query tasks
types
  :build | packemon
  :format | prettier
  :lint | eslint
  :test | jest
  :typecheck | tsc
report
  :build | packemon
  :format | prettier
  :lint | eslint
  :test | jest
  :typecheck | tsc
...
```

## Shell completions

Auto-completion in your terminal increases productivity, which we're a massive fan of. To help
support this, we're introducing the [`moon completions`](/docs/commands/completions) command, which
generates the appropriate command completions for your current shell.

This command writes to stdout, which can then be redirected to a file of your choice. Be sure to
configure your shell profile to load the completions!

```shell
$ moon completions > ~/.bash_completion.d/moon.sh
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.24.0) for a
full list of changes.

- Added [TypeScript v5](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/)
  support.
- Added a `hasher.walkStrategy` setting to `.moon/workspace.yml`.
- Updated task `outputs` to support token functions (`@group`, `@globs`, etc).
- Reworked our comparison/baseline estimations calculations.

## What's next?

Expect the following in the v0.25 release!

- Deno tier 2 support.
- CI insights and metrics within moonbase.
- Project-level TypeScript settings.

---

## moon v0.25 - Deno tier 2 support, CI insights, custom project languages, and more

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Button from '@site/src/ui/Button';
import Image from '@site/src/components/Image';

With this release, we're landing Deno, our first supported language besides Node.js, and improving
interoperability of languages as a whole.

## Deno tier 2 support (experimental)

Three months ago we announced our [new tiered support structure](./v0.21) for languages, and as of
today, we're happy to announce that our second language to reach tier 2 is
[Deno](https://deno.land)! With tier 2 support, we now analyze Deno specific configuration files
(like `deno.json`) to infer dependencies and relationships, as well as utilize this information for
inputs and hashing purposes. With that being said, we're marking this release as experimental until
we fine tune the implementation, and iron out all the bugs.

To get started with using Deno, enable the new [`deno`](/docs/config/toolchain#deno) setting in
[`.moon/toolchain.yml`](/docs/config/toolchain). At this time, we don't have many settings to
configure, so simply defining an empty object is enough to enable the Deno platform! Learn more
about this in our [Deno handbook](/docs/guides/javascript/deno-handbook).

```yaml title=".moon/toolchain.yml"
deno: {}
```

Once enabled, you can start using `deno` commands in your moon tasks. moon will automatically set
the [`platform`](/docs/config/project#platform-1) to "deno" when using a deno command.

```yaml title="moon.yml"
tasks:
  format:
    command: 'deno fmt'
```

:::info

Because this is only tier 2 support, moon _does not_ download and install Deno into its toolchain.
moon expects the `deno` binary to exist in the current environment.

:::

Furthermore, if you're working a project that is composed of multiple JavaScript runtimes, like
Deno, Bun, or Node.js, you can set the default `platform` for all tasks at the project-level.

```yaml title="moon.yml"
platform: 'deno'
language: 'typescript'
type: 'application'
```

We're very excited for this release as it paves the way for future language integrations, and
enables additional JavaScript runtimes!

## CI insights in moonbase

We've spent the last few weeks implementing a new [moonbase](https://moonrepo.app) feature called CI
insights, where we track all CI runs (via [`moon ci`](/docs/commands/ci)), and all actions (tasks)
that have ran based on affected files. In the future these insights will help catch regressions,
alert on flakiness, provide granular metrics, and help monitor the health of your CI pipeline and
repositories.

With this initial release, we track touched files, which targets are affected based on those files,
an estimation on how much time was saved or lost, the actions that ran and their final status,
outlined as a timeline.

Insights are enabled by default if you're using moonbase in your CI pipeline, and start using moon
v0.25! You can disable insights gathering from your
[organization settings page](https://moonrepo.app).

## Offline mode

moon assumes that an internet connection is always available, as we download and install tools into
the toolchain, resolve versions against upstream manifests, and automatically install dependencies.
While this is useful, having a constant internet connection isn't always viable.

In this release, we now check for an active internet connection and bypass certain workflows when
applicable.
[Jump to the official guide on offline mode for more information](/docs/guides/offline-mode)!

## Custom project `language`

Project's have always been able to define a [`language`](/docs/config/project#language) in
[`moon.yml`](/docs/config/project) that denotes the primary programming language for the project.
Historically this has been a strict enum of supported values, and could _not_ be customized for
other languages. With the introduction of
[language driven task inheritance](./v0.23#new-scoped-tasks-with-moontasksyml), we felt like
revisiting this setting, and as such, you're now able to define _any_ language in this setting,
which also feeds into the task inheritance system.

```yaml title="moon.yml"
language: 'kotlin'
```

With this change, `.moon/tasks/kotlin-application.yml`, `.moon/tasks/dotnet.yml`, and other
variations are now possible! However, besides task inheritance, other functionality like platform
detection, and Dockerfile support are not enabled.

## Project-level TypeScript settings (breaking)

Our TypeScript integration supports many automated workflows, like syncing project references, and
routing `outDir` to our shared cache. This is wonderful for the majority, but for the handful of
projects where these settings were not viable, there was no simple way to disable or opt out of the
functionality.

Well no more, projects can now override the workspace-level TypeScript settings
`routeOutDirToCache`, `syncProjectReferences`, and `syncProjectReferencesToPaths` through the
[`toolchain.typescript`](/docs/config/project#typescript) setting in
[`moon.yml`](/docs/config/project).

```yaml title="moon.yml"
toolchain:
  typescript:
    routeOutDirToCache: false
```

Because this setting was changed from a boolean to an object, the old pattern of disabling
Typescript must now use the `disabled` setting.

```yaml title="moon.yml"
# Old
toolchain:
  typescript: false

# new
toolchain:
  typescript:
    disabled: true
```

## New `moonrepo/setup-moon-action` GitHub action

If you're using GitHub Actions as your CI pipeline, we've introducing a new action called
[moonrepo/setup-moon-action](https://github.com/moonrepo/setup-moon-action), that will install the
`moon` binary globally, and will cache (and restore) the moon toolchain.

With this new action, let moon handle all the heavy lifting, and avoid all the unnecessary steps
around setting up Node.js, and install dependencies.

```yaml
jobs:
  ci:
    name: 'CI'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: moonrepo/setup-moon-action@v1
      - run: moon ci
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.25.0) for a
full list of changes.

- Updated project, task, and target identifiers to support periods (`.`).
- Refactored glob matching to use workspace relative paths instead of absolute. Please report an
  issue if hashing or affected detection is now inaccurate.
- We now build against older operating systems in an attempt to solve GLIBC version errors.

## What's next?

Expect the following in the v0.26 release!

- Officially release proto!
- Improved Deno interoperability.

---

## Introducing proto, a next-generation toolchain manager!

import Button from '@site/src/ui/Button';
import Logo from '../static/brand/proto/logo.svg';

We are proud to announce the launch of [proto](/proto), a next-generation toolchain manager for all
of your favorite programming languages.

  

[proto](/proto) is a Rust based multi-language toolchain manager that will download and install
tools by version, and immediately make them available on `PATH`. proto is launching with initial
support for [Bun](https://bun.sh), [Deno](https://deno.land), [Node.js](https://nodejs.org) (and
npm, pnpm, yarn), and [Go](https://go.dev), with more languages on the way!

```shell
proto install node 18
proto install go 1.20
proto install deno 1.30
```

Unlike other version managers that pin their global binary to a default version, proto will
[contextually detect an applicable version](/docs/proto/detection) from the environment or the
language's ecosystem (like `package.json`), ensuring the correct tool is always being ran.

```shell
# Will detect a version before running
bun run ./script.ts
```

Furthermore, with proto's [`.prototools`](/docs/proto/config) file, you can pin versions of all
required tools on a per-project or per-repository basis, allowing for near instant setup of
developer environments. Perfect for onboarding new developers!

```toml title=".prototools"
node = "18.12.0"
yarn = "3.3.0"
```

```shell
# Install all the things!
proto use
```

And lastly, [moon](/moon)'s toolchain is built on proto, so if you're using moon, you might as well
use proto. This will enable a single toolchain for both tools (in v0.26)!

  

## How to get started?

In a terminal that supports Bash, run:

```
curl -fsSL https://moonrepo.dev/install/proto.sh | bash
```

In Powershell or Windows Terminal, run:

```
irm https://moonrepo.dev/install/proto.ps1 | iex
```

Jump to the [documentation](/docs/proto) for more information on getting started and available
commands!

## Why another version manager?

To start, proto powers [moon's](/moon) toolchain and integrated developer environment. We believed
that moon's toolchain would be extremely beneficial for developers as a whole, and so we extracted
proto out into a standalone Rust CLI and Rust crates that moon inherits.

Furthermore, we believe that requiring multiple ad-hoc version managers for all your languages, each
with different workflows, CLI commands, and configuration files, is a poor developer experience.

Our goal is to unify all of these into a single performant interface. A toolchain manager is the
next step in the version manager evolution.

---

## moon v0.26 - Deeper proto integration, Docker setup, and query commands

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Button from '@site/src/ui/Button';
import Logo from '../static/brand/proto/logo.svg';

With this release, we're providing deeper integration with our new [proto](/proto) toolchain
manager, better Docker support, and new query commands for debugging.

## Full proto toolchain integration

  

Earlier this week we announced [proto](/proto), our own toolchain manager, and an attempt at a next
generation version manager for multiple languages. proto was originally moon's toolchain layer, but
we felt it best to extract it out into a stand-alone tool for everyone to use, especially those not
using moon!

Now that proto has been released, we've updated moon's Rust internals to utilize proto's latest Rust
crates. For the most part, everything will continue to work the same. However, the biggest change is
that the toolchain has moved from `~/.moon` to `~/.proto`, and will result in tools being
re-downloaded and installed. Feel free to delete the old `~/.moon` directory manually.

Furthermore, we've added first-class support for the new [`.prototools`](/docs/proto/config)
configuration file. If this file is found in the workspace root, we'll automatically enable the
tools in our toolchain, and inject the versions (when not defined in `.moon/toolchain.yml`).

```toml title=".prototools"
node = "18.0.0"
pnpm = "7.29.0"
```

## New `moon docker setup` command

moon has provided [built-in `Dockerfile` support](/docs/guides/docker) since v0.15 (11 versions
ago!) and we've always encouraged the use of the [`moon setup`](/docs/commands/setup) command to
setup the toolchain and install project dependencies. Here's an example of a moon powered
`Dockerfile`:

```docker
FROM node:latest
WORKDIR /app

# Install moon binary
RUN npm install -g @moonrepo/cli

# Copy workspace skeleton
COPY ./.moon/docker/workspace .

# Install toolchain and dependencies
RUN moon setup

# Copy source files
COPY ./.moon/docker/sources .

# Build something
RUN moon run app:build

# Prune workspace
RUN moon docker prune

CMD ["moon", "run", "app:start"]
```

However, over the course of these 11 releases since v0.15, we refactored the `moon setup` command to
only setup the toolchain, and _no longer_ install project dependencies. We inadvertently broke our
Docker integration. This was an oversight on our part.

To rectify this situation, we're introducing a new
[`moon docker setup`](/docs/commands/docker/setup) command that will efficiently install
dependencies for projects focused/affected within the `Dockerfile`. This is a much better solution
than before, and you should see improved Docker layer caching!

```diff
-RUN moon setup
+RUN moon docker setup
```

## New `moon query hash` command

When moon runs a task, we generate a unique hash representing the state of that run. When something
goes wrong however, and the hash is different than what you expect, debugging why is rather
non-trivial and requires a lot of internal knowledge. We're looking to reduce this burden, by
introducing the new [`moon query hash`](/docs/commands/query/hash) command.

```shell
$ moon query hash 0b55b234
```

This command will print the contents of the hash manifest, which is all inputs and sources used to
generate the unique hash. From here you can use this output to investigate what's actually
happening.

```json
{
  "command": "build",
  "args": ["./build"]
  // ...
}
```

## New `moon query hash-diff` command

Expanding on the new command above, we're also introducing the
[`moon query hash-diff`](/docs/commands/query/hash-diff) command, which can be used to compute the
difference between 2 hashes. Perfect in understanding what has changed between ran tasks.

```shell
$ moon query hash-diff 0b55b234 2388552f
```

When ran, the command will print out the differences as highlighted lines. If you use `git diff`,
this will feel familiar to you.

```diff
{
	"command": "build",
	"args": [
+		"./dist"
-		"./build"
	],
	...
}
```

## Other changes

View the
[official release](https://github.com/moonrepo/moon/releases/tag/%40moonrepo%2Fcli%400.26.0) for a
full list of changes.

- A handful of critical bug fixes.
- Targets that generate an empty hash are now considered a failure, as they may be an edge case not
  accounted for.

## What's next?

Expect the following in the v1 release!

- Officially release a v1!
- Project tagging and constraints.

---

## proto v0.3 - Improved npm, go, and version requirement support

With this release, we're improving some workflows and version detection logic based on initial
feedback.

## Bundled npm support

After Node.js is installed, the version of npm that came bundled with that Node.js version will also
be installed into proto. This functionality can be skipped by passing `--no-bundled-npm` during
installation.

```shell
$ proto install node -- --no-bundled-npm
```

To further expand upon this, `bundled` is now considered a built-in alias, and will be used during
version detection. When encountered, we'll first detect the version of Node.js running, and infer
the npm version from there.

```shell
$ proto global npm bundled
```

> Only supported by proto, not moon.

## Automatic `GOBIN` setup

After Go is installed, we'll now inject a `GOBIN` environment variable into your shell, pointing to
`~/go/bin`, if it doesn't already exist. This variable will be used to locate Go binaries across all
installed versions, and help to avoid binary not found errors.

This functionality can be skipped by passing `--no-gobin` during installation.

```shell
$ proto install go -- --no-gobin
```

> Only supported by proto, not moon.

## Better version requirement detection

Previously when proto encountered a version requirement (`^`, `~`, `>=`, etc) during version
detection, we would attempt to resolve a version that satisfied the requirement based on versions
available in the remote manifest (what's been officially released). While this worked, it would
result in far too many local installs as that satisfied version constantly changed.

Instead, we now satisfy the version requirement based on versions that have been installed locally
to `~/.proto/tools`. If no version matches, detection will simply move on to the next case, and
eventually fallback to the global default version.

---

## moon v1.0 - Official release! Project constraints, tagging, and more!

🎉 It's finally here! After almost a year of development, a handful of breaking changes, we've
officially reached a stable v1 of moon! This release is feature packed with quality of life
improvements.

## The road to v1

It's been 10 months since moon launched publicly, and since that time we have landed 501 pull
requests, fixed 100's of bugs, made 16 breaking changes, released 26 versions, and have been used by
companies like Ikea, SumUp, Depot, and Gallery. It's been a wild ride, and we're excited to finally
reach a stable v1 release.

## Project boundaries with constraints

One feature that moon has not supported, but is critical for large monorepos, is project boundaries.
A project boundary is a concept that enforces a strict relationship between projects, and is a
common pattern in monorepos. For example, a project may only be allowed to depend on projects with a
[specific tag](#enforce-relationships-with-tags), or a project of a specific type.

moon now supports this functionality through the new
[`constraints`](/docs/config/workspace#constraints) setting in
[`.moon/workspace.yml`](/docs/config/workspace). The primary constraint we're introducing is
[`enforceProjectTypeRelationships`](/docs/config/workspace#enforceprojecttyperelationships), which
enforces relationships between projects based on their [`type`](/docs/config/project#type) field.

For example, an application can only depend on library or tool based projects, but _not_ other
applications (this is a code smell). This setting is enabled by default!

```yaml title=".moon/workspace.yml"
constraints:
  enforceProjectTypeRelationships: true
```

And that's not all, continue reading for more information on tag based constraints!

## Project tagging

Everyone is familiar with the concept of tagging, and moon's implementation is no different. Tags
are a simple mechanism for categorizing projects, and can be defined through the
[`tags`](/docs/config/project#tags) setting in [`moon.yml`](/docs/config/project).

```yaml title="moon.yml"
tags:
  - 'react'
  - 'prisma'
```

Tags can be used to group projects together for easier querying, enforcing of project boundaries,
applying constraints, and more in the future. Tags will become a staple for maintaining repositories
at scale. Continue reading for more information!

### Querying projects by tag

The first integration with tags is project querying. You can now query for projects by tag using the
new `--tags` option in the [`moon query projects`](/docs/commands/query/projects) command. For
example, say you want to find all projects that are tagged with `vue` or `trpc`:

```shell
$ moon query projects --tags 'vue|trpc'
```

### Enforce relationships with tags

Another feature of tags is enforcing relationships between projects using our new
[`constraints`](#project-boundaries-with-constraints) setting. When a tagged constraint is defined,
it requires all [dependencies](/docs/concepts/project#dependencies) of a tagged project to require 1
of the configured tags, otherwise an error is thrown during project graph creation.

To demonstrate this, take the following configuration:

```yaml title=".moon/workspace.yml" {2,3}
constraints:
  tagRelationships:
    next: ['react', 'trpc']
```

This dictates that all dependencies of a project with the `next` tag, must declare either `react`,
`trpc`, or `next` in their own tags. This is great for crafting a monorepo with strict project
boundaries!

## Shells for system tasks

Up until now, all executed tasks would not be wrapped in a shell for 1 reason, to ensure tasks are
deterministic. A major goal for moon is that tasks are deterministic and easily reproducible across
all machines. Shells break this guarantee, as they can introduce subtle bugs that are difficult to
diagnose, and may differ wildly between developers and machines.

However in practice, not supporting shells has been a major pain point for many users, and for the
most part, most system tasks typically run common commands or execute pre-defined scripts. The
chance of a non-deterministic build is very small. As such, we've decided to make a compromise, and
allow shells for [system tasks](/docs/config/project#platform-1), but not for language based tasks.

For example, the following tasks:

```yaml title="moon.yml"
tasks:
  example:
    command: 'echo $PWD'
    platform: 'system'
  global:
    command: 'bin-on-path'
    platform: 'system'
```

Would now be executed as `/bin/sh -c 'echo $PWD'` and `/bin/sh -c 'bin-on-path'` on Unix platforms
respectively. On Windows, we execute tasks with `pwsh.exe -c` and pass arguments via stdin.

We're also taking this a step further, by introducing a new task option called
[`shell`](/docs/config/project#shell), that can be used to toggle the shell wrapping on or off. When
turned off, this allows you to customize and execute the shell as you please.

```yaml title="moon.yml"
tasks:
  example:
    command: 'bash -c "echo $PWD"'
    platform: 'system'
    options:
      shell: false
```

## Environment variable substitution

moon supports granular environment variables through the project-level
[`env`](/docs/config/project#env) setting, task-level [`env`](/docs/config/project#env-1) setting,
and the task [`envFile`](/docs/config/project#envfile) option. We're expanding their functionality
with variable substitution, allowing the value of another environment variable to be interpolated
using the syntax `${VAR_NAME}`. This is especially useful for composing complex environment
variables.

```yaml title="moon.yml"
tasks:
  dev:
    command: 'app start'
    env:
      APP_TARGET: '${REGION}-${ENVIRONMENT}'
```

The same substitution syntax can also be used within `.env` files.

```toml title=".env"
APP_TARGET="${REGION}-${ENVIRONMENT}"
```

## Date/time token variables

[Tokens](/docs/concepts/token) are a mechanism used in task configuration for dynamically injecting
values from the current project or task, especially when task inheritance is involved. Tokens have
existed since moon's inception, without much change... until now.

We're excited to introduce a new set of tokens for referencing the
[current date or time](/docs/concepts/token#datetime): `$date`, `$time`, `$datetime`, and
`$timestamp`. With these new tokens, you're now able to implement clever or unusual solutions, like
grouping builds or deploys based on the current timestamp.

```yaml title="moon.yml"
tasks:
  deploy:
    command: 'app deploy --output ./build/$timestamp'
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.0.0) for a full list of
changes.

- Added a `hasher.warnOnMissingInputs` setting to `.moon/workspace.yml`.
- Added a `$projectAlias` task token.
- Added a `telemetry` setting to `.moon/workspace.yml`.
- Updated the new version check to only run on the `check`, `ci`, `run`, and `sync` commands.

## What's next?

Expect the following in the v1.1 release!

- Polish and stability initiatives.
- Task inheritance based on tags.
- Deno tier 3 support.

---

## proto v0.4 - Rust support, user configs, and more

With this release, we've added Rust language support, user configs, and a few other improvements.

## Rust language support

We're very excited to announce support for the [Rust language](https://www.rust-lang.org/) in proto.
This is our first language addition since the initial release, and we're very happy with how it
turned out.

```shell
$ proto install rust stable
```

For those of you unfamiliar with Rust, Rust provides its own toolchain manager through
[`rustup`](https://rustup.rs/) — a very powerful one at that. We don't want to reinvent the wheel
here, so instead of downloading and installing Rust into proto's toolchain, we chose to call
`rustup` commands under the hood. Because of this, Rust support in proto requires Rust/Cargo to be
pre-installed on your system. Jump to the [docs for more information](/docs/proto/tools).

All in all, the cool thing about supporting Rust in proto is that you can standardize all your tools
in a single config for [`proto use`](/docs/proto/commands/use).

```toml title=".prototools"
node = "18.2.0"
rust = "1.68.0"
```

## New user configuration

We have a long list of ideas and features that would be cool to support in proto, but not as the
default functionality. Because of this, we required a way for users to opt-in to this functionality,
and have landed on a new user configuration located at `~/.proto/config.toml`.

```toml title="~/.proto/config.toml"
auto-install = true
```

This new configuration only supports a single setting (for now), `auto-install`, that when enabled,
will automatically install a missing tool for the detected version when running
[`proto run`](/docs/proto/commands/run) (or a shim).

## New `proto upgrade` command

We now provide a [`proto upgrade`](/docs/proto/commands/upgrade) command for upgrading proto itself.
This will download the latest version and replace the binary at `~/.proto/bin/proto`.

```shell
$ proto upgrade
```

---

## moon v1.1 - Task debugging and improvements

With this release, we're introducing some quality of life task improvements.

## Token variable support in task commands

moon supports a concept known as [tokens](/docs/concepts/token) where values are injected into tasks
during project graph creation. This allows for dynamic values in your tasks, such as the current
project language, or the current task name, and is crucial for task inheritance to work.

However, tokens were only supported by task args, inputs, and outputs, but not commands... until
now. Commands can now use token variables (but not token functions). For example, this is useful for
referencing shared scripts from the workspace root.

```yaml title="moon.yml"
tasks:
  precheck:
    command: '$workspaceRoot/scripts/precheck.sh'
```

## Run targets in closest project

The [`moon run`](/docs/commands/run) command can run targets in an array of different formats, but
was unable to run targets based on the current working directory. Well no more! You can now run
tasks from the closest project based on file path by omitting `:` from the target name.

```shell
$ cd packages/components

# Runs `components:build` internally
$ moon run build
```

## View resolved task information

Debugging task issues can be a quite a pain, as there can be many points of failure. Are inputs too
greedy? Are outputs not being created? Does it exist at all? To help with this, you can now view
task information by running [`moon task `](/docs/commands/task).

```shell
$ moon task app:build
```

This command will display _resolved_ information, including inherited settings, and path resolved
inputs and outputs. Here's an example:

```
RUNTIME:BUILD

ID: build
Project: runtime
Platform: node
Type: build

PROCESS

Command: packemon build --addFiles --addExports --declaration
Environment variables:
 - NODE_ENV = production
Working directory: /Projects/moon/packages/runtime
Runs dependencies: Concurrently
Runs in CI: Yes

DEPENDS ON

 - types:build

INPUTS

 - .moon/*.yml
 - packages/runtime/src/**/*
 - packages/runtime/tsconfig.*.json
 - packages/runtime/types/**/*
 - packages/runtime/package.json
 - packages/runtime/tsconfig.json
 - tsconfig.options.json

OUTPUTS

 - packages/runtime/cjs
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.1.0) for a full list of
changes.

- Support pnpm v8's new lockfile format.
- Better handling for task's that execute the `moon` binary.
- Updated `noop` tasks to be cacheable, so that they can be used for cache hit early returns.

---

## proto v0.5 - Version aliasing and global binaries

With this release, we're providing solutions for installing globals and using aliases.

## Install global binaries

Installing global binaries (packages, modules, etc) is a common task for developers, and proto now
provides a solution for this workflow with the `proto install-global` command. Continue reading for
more information.

:::info

Global install directories will need to be added manually to your `PATH` from your shell.

:::

### Bun, Deno, Go, Rust

All of these languages provide a built-in solution for installing global binaries to a shared
location, regardless of the language's current version. Because of this, proto will simply call
their install commands under the hood.

```shell
$ proto install-global rust cargo-release

# Same as
$ cargo install cargo-release --force
```

Globals will be installed to the following locations:

- **Bun**: `~/.bun/bin`
- **Deno**: `~/.deno/bin`
- **Go**: `~/go/bin`
- **Rust**: `~/.cargo/bin`

### Node.js, npm, pnpm, yarn

Unfortunately, the Node.js ecosystem is pretty fractured when it comes to installing global
binaries. Each package manager provides their own solution for installing globals, and each has
their own quirks. The problem is further exacerbated by the fact that globals are tied to Node.js
version, so if you switch versions, you lose all your previous globals!

To work around this, proto standardizes the global installation process for Node.js, but requires
all globals to be installed through proto. You can no longer use `npm install -g`, `pnpm add -g`, so
on and so forth, and must use:

```shell
$ proto install-global node webpack-cli
```

Globals will be installed to a shared location, `~/.proto/tools/node/globals/bin`, and will persist
across versions!

## Custom version aliases

We are excited to announce 2 new commands that enable you to define custom version aliases,
[`proto alias`](/docs/proto/commands/alias) and [`proto unalias`](/docs/proto/commands/unalias).
Aliasing of versions is a feature that allows you to assign a custom name or label to a specific
version of a tool.

For example, instead of using the version number, you can assign a label such as "work" or
"personal" to a version. This makes it easier to remember and manage different versions.

```shell
$ proto alias node work 16.16
$ proto alias node personal 18
```

Aliases can be used anywhere a version is accepted, for example:

```shell
$ proto bin node work
$ proto install node personal
```

---

## proto v0.6 - Unused cleaning and improved global binaries

import Button from '@site/src/ui/Button';
import Image from '@site/src/components/Image';

With this release, we're expanding on our global binary support and providing quality of life
improvements.

## RFC: Plugins system

Since proto's inception, plugins have been top of mind, but runtime based plugins in Rust are
_difficult_. The only viable solution to this problem is WASM, but most developers have never used
WASM before, nor are they familiar with WASM tooling (myself included).

However, we're at a point in proto's life-cycle where the core is rather stable, and it's time to
start investigating plugin support. To this end, we've introduced a small RFC outlining how plugins
will be used, enabled, and implemented. It's not very in-depth as we want to avoid implementation
details, but from a consumers perspective, we want to ensure that it makes sense.

We'd very much appreciate it if you could take a look at the RFC and provide feedback. If you have
any experience in Rust runtime plugins, we'd love to hear your thoughts as well.

  

## Cleaning stale and unused tools

Is your `~/.proto` installation growing out of control? Are there old versions of tools that you
don't use anymore? Or versions you never used? Unsure if you're using a tool at all or still need
it?

To help avoid these questions and problems, we're introducing a new command that will uninstall
stale and unused tools, [`proto clean`](/docs/proto/commands/clean). When ran, the command will
launch an interactive session and scan the file system for old tools, prompting you to remove them.

```shell
$ proto clean
```

By default the command will uninstall tools that haven't been used in over 30 days, but this can be
customized with the `--days` option.

:::info

Tools installed before v0.6 will most likely be considered stale, as we weren't tracking install and
last used timestamps. However, everything will work as intended after running a tool or simply
moving forward from this point.

:::

## Global binary improvements

In our [previous release](./proto-v0.5), we announced the `proto install-global` command for
installing global dependencies that are unique per tool. Thanks to the community, this command has
been updated to support installing multiple globals at once!

```shell
$ proto install-global node typescript webpack-cli
```

On top of this, we're also introducing another command that was requested by the community,
`proto list-global`, that can be used to list all currently installed globals.

```shell
$ proto list-global node
tsc - ~/.proto/tools/node/globals/lib/node_modules/typescript/bin/tsc
tsserver - ~/.proto/tools/node/globals/lib/node_modules/typescript/bin/tsserver
```

## Better error messages

We've spent most of the past week working on a new internal architecture called
[Starbase](https://github.com/moonrepo/starbase), which will be the new foundation for proto and
moon moving forward. One of the major benefits of this new architecture is a rewritten error system
that provides more context and better error messages.

Here's an example of this, albeit with a contrived situation:

---

## moon v1.2 - Tag based task inheritance

In this small release, we're improving our task inheritance and performance.

## Task inheritance based on project tags

In v0.23 we introduced [scoped task inheritance](/blog/v0.23#improved-task-inheritance-model) by
project type/language, and in v1.0 we introduced [project tagging](/blog/moon-v1.0#project-tagging),
but what if we combined both of these features? In this release, you can now define workspace-level
tasks _by tag_ that'll be inherited by all projects with that tag.

To demonstrate this, say you have a monorepo composed of multiple [Astro](https://astro.build)
applications, each duplicating the same Astro tasks. Instead of duplicating, define an `astro` tag
in each project's [`moon.yml`](/docs/config/project#tags).

```yaml title="/moon.yml"
language: 'typescript'
type: 'application'
tags: ['astro']
```

And then create a new tasks configuration at `.moon/tasks/tag-astro.yml` with the following
contents:

```yaml title=".moon/tasks/tag-astro.yml"
fileGroups:
  astro:
    - 'public/**/*'
    - 'src/**/*'
    - 'astro.config.*'
    - 'tsconfig.json'

tasks:
  astro:
    command: 'astro'
    local: true

  # Development server
  dev:
    command: 'astro dev'
    local: true

  # Production build
  build:
    command: 'astro build'
    inputs: ['@group(astro)']
    outputs: ['dist']

  # Check .astro files
  check:
    command: 'astro check'
    inputs: ['@group(astro)']
    deps: ['typecheck']

  # Preview production build locally
  preview:
    command: 'astro preview'
    deps: ['build']
    local: true
```

Each of these Astro applications will now inherit all 5 tasks and the file group automatically! This
helps to greatly reduce maintenance overhead and help enforce consistency across projects. Jump to
the official [task inheritance docs](/docs/concepts/task-inheritance) for more information on tag
based inheritance.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.2.0) for a full list of
changes.

- Upgraded to proto v0.6.
- Improvements to file system operations.
- Minor improvements to performance.

---

## proto v0.7 - First step towards plugins

With this release, we're very excited to announce our initial support for plugins in proto!

## Initial plugins architecture

Last week we posted an [RFC for a new plugins architecture](./proto-v0.6#rfc-plugins-system) for
proto. We believe plugins will unlock an array of capabilities for proto, will enable the community
to add their own custom integrations, and the ability for tools to be managed within proto's
toolchain.

We were very excited for this RFC, and couldn't wait, so we spent the last week prototyping
implementations. We got the basics of downloading, installing, and enabling a plugin at _runtime_
working incredibly fast. However, implementing the entire RFC in 1 release would have taken too
long, and we wanted to avoid dropping such a large feature in a single release. Because of this,
we've only implemented [TOML plugins](/docs/proto/non-wasm-plugin) in this release, and will
implement WASM plugins in a future release.

### TOML plugins

You may be asking yourself, aren't plugins typically code? For the most part, yes, but after
building a "version manager" for multiple languages, we've come to the realization that many tools
can simply be supported through a basic configuration file.

At minimum, tools require the following pieces to be managed:

- Where and how to download the tool
- How to install/unpack the tool
- How to resolve available versions to install
- How to execute the tool's binary

All 4 of these pieces can be solved with a configuration file, and as such, we opted to support a
[TOML schema based plugin](/docs/proto/non-wasm-plugin) as an alternative to a code based plugin.
The other benefits of a schema is that it's _easy to write, read, and maintain_, doesn't require any
code, and doesn't force you into a specific programming language.

To demonstrate how this plugin works, here's an example of a [moon](/moon) TOML schema.

```toml title="moon-schema.toml"
name = "moon"
type = "cli"

[platform.linux]
download-file = "moon-{arch}-unknown-linux-{libc}"

[platform.macos]
download-file = "moon-{arch}-apple-darwin"

[platform.windows]
download-file = "moon-{arch}-pc-windows-msvc.exe"

[install]
download-url = "https://github.com/moonrepo/moon/releases/download/v{version}/{download_file}"

[resolve]
git-url = "https://github.com/moonrepo/moon"
```

Very simple right? With this, you can now configure moon as a plugin within proto.

```toml title=".prototools"
moon = "1.2.0"

[plugins]
moon = "source:./path/to/moon-schema.toml"
```

And ultimately manage every version of moon through proto! Because moon is now a plugin, every
command in proto that accepts a `` argument, will now accept `moon` as a valid tool.

```shell
$ proto install moon 1.2.0
$ proto list-remote moon
$ proto use
```

Learn more about [TOML plugins in the official docs](/docs/proto/plugins)!

## Cleaning improvements

Last week we introduced the [`proto clean`](/docs/proto/commands/clean) command that will
automatically delete stale and unused tools from the toolchain. This week we've implemented a few
improvements to the cleaning process:

- Added a `--yes` option to [`proto clean`](/docs/proto/commands/clean), allowing prompts to be
  bypassed.
- Added a `auto-clean` setting to `~/.proto/config.toml`, enabling automatic cleaning when
  [`proto use`](/docs/proto/commands/use) is ran.

---

## moon v1.3 - Advanced run targeting and an official proto plugin

After many months of design and development, we're finally introducing MQL, our own unique query
language!

## Run targets based on a query

Our [`moon run`](/docs/commands/run) command is pretty powerful. It allows you to run targets in
one, many, or all projects. It also supports running multiple targets in parallel. However, it
wasn't powerful enough, as it couldn't run the following types of scenarios:

- Run a target in projects of a specific language.
- Run a target in libraries or applications.
- Run a target based on project file system path.
- Run a target in projects with a matching tag.
- Run a target in projects that match a keyword.
- Run a target in projects based on AND or OR conditions.
- Or a combination of these.
- And many more!

Supporting all of these scenarios through CLI arguments just feels like bad design, and would result
in a poor developer experience. There had to be a better way to support this! So we set out to solve
this problem, and after much thought, we're stoked to introduce
[MQL, a query language unique to moon](/docs/concepts/query-lang).

With MQL, you can now run scenarios like "I want to build all Node.js libraries", or "I want to lint
and test all Rust projects". Simply pass an unscoped target and a query to the `run` command:

```shell
$ moon run :build --query "taskPlatform=node && projectType=library"

$ moon run :lint :test --query "language=rust"
```

This is only the first iteration of MQL and it's already quite powerful. Expect additional fields,
features, and functionality in the future!

## Plugin support for proto

Earlier this week we announced [plugin support for proto](./proto-v0.7), starting with a TOML based
plugin. This is great as it allows _any_ kind of versioned tool to be managed in proto's toolchain,
so why not moon? Starting with this release, you can now install and manage moon _from_ proto, using
our officially maintained TOML plugin.

In your `.prototools` or `~/.proto/config.toml` file, add the following snippet:

```toml title=".prototools"
[plugins]
moon = "source:https://raw.githubusercontent.com/moonrepo/moon/master/proto-plugin.toml"
```

And as easy as that, you can now use `moon` as a tool within any `proto` command. For example:

```shell
$ proto install moon 1.3.0
$ proto list-remote moon
$ proto bin moon
```

Furthermore, with proto, we can now pin the version of moon on a per-project basis. Perfect for
enforcing the same version for all developers on your team!

```toml title=".prototools"
moon = "1.3.0"
```

> When using this approach, be sure `~/proto/.bin` is in your `PATH`, and takes precedence over
> `~/.moon/bin`.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.3.0) for a full list of
changes.

- Upgraded to proto v0.7.
- Improved accuracy of our globbing utilities, especially around dotfiles/dotfolders.
- Updated config loading to be strict and error on unknown fields for non-root fields.

---

## proto v0.8 - Version detection and installation improvements

In this release, we're dropping some quality of life workflow improvements.

## Built-in detection for `proto use`

The [`proto use`](/docs/proto/commands/use) command is extremely useful for bootstrapping your
development environment with all necessary tooling, but it had a hard requirement on the
[`.prototools`](/docs/proto/config) configuration file. But what if you're already using non-proto
version files, like `.nvmrc` or `.dvmrc`? Or maybe manifest settings, like `packageManager` or
`engines` in `package.json`?

Great questions, and we agree! As such, we've updated `proto use` to _also_ detect a version from
the environment for the current working directory. We suggest using `.prototools`, but feel free to
configure your environments as you so choose!

```shell
# Install all the things!
$ proto use
```

## Smarter version detection

One of proto's best features is its [contextual version detection](/docs/proto/detection), but it
did have 1 shortcoming. When we detected a partial version, like `1.2`, we'd resolve to a fully
qualified version with the latest patch version (e.g. `1.2.3`). While this worked in most cases,
everytime a new patch was released upstream (e.g. `1.2.4`), proto would error and require a manual
install of this new version. This was pretty annoying as `1.2.3` and `1.2.4` are likely to be
compatible, and both satisfy the `1.2` version constraint.

To mitigate this scenario, we've updated the version detection to scan the locally installed
versions _first_ when encountering a partial version. This solves the problem above by allowing
`1.2.3` to satisfy the requirement, instead of forcing an install of `1.2.4`.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.8.0) for a full list
of changes.

---

## moon v1.4 - New tag target scope, MQL support for query commands, and more!

With this release, we're bringing further improvements to tags and MQL.

## Run targets by tag with `#tag:task`

We love our community, as you all continuously suggest new and awesome features that haven't crossed
our minds. One such feature was the ability to run tasks for all projects with a tag,
[suggested by @theoephraim](https://github.com/moonrepo/moon/issues/803), which is now possible with
the new [tag scope](/docs/concepts/target#by-tag), `#tag:task`.

As an example, we can easily lint all projects that have the `frontend` tag.

```shell
$ moon run '#frontend:lint'
```

> Because `#` is special syntax and denotes a comment, the target will need to be quoted to work
> correctly!

## Updated `moon query` commands to support MQL

Last week we announced [MQL](./moon-v1.3#run-targets-based-on-a-query), a custom query language for
applying filters to moon's project graph, primarily through the [`moon run`](/docs/commands/run)
command. We plan to slowly integrate MQL throughout moon as it provides an easy to use API, and an
overall better developer experience.

As such, we've updated both [`moon query projects`](/docs/commands/query/projects) and
[`moon query tasks`](/docs/commands/query/tasks) to support MQL statements as an optional first
argument. Totally makes sense that query commands would support MQL!

```shell
# Find all projects with a `lint` or `build` task
$ moon query projects "task=[lint,build]"

# Find all tasks with an id that starts with "dev"
$ moon query tasks "task~dev-*"
```

## Deprecated `node.aliasPackageNames` setting

moon project's support the [concept of aliasing](/docs/concepts/project#aliases), where
language/ecosystem specific names are used alongside moon's. For example, the `name` field from
`package.json`. However, aliasing was off by default for Node.js projects and had to be explicitly
enabled with the `node.aliasPackageNames` setting.

In an effort to streamline moon adoption for Node.js codebases, we're deprecating that setting, and
instead will now always inherit the `package.json` name as an alias. For example, if you're package
name was `@company/utils`, you can now run a target like so:

```shell
$ moon run @company/utils:build
```

> This setting is now a no-op and can be removed from your configuration.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.4.0) for a full list of
changes.

- Upgraded to proto v0.8.

---

## moon v1.5 - Rust tier 2 and 3 support

import Button from '@site/src/ui/Button';

With this release, we're announcing not just tier 2, but also tier 3 support for the Rust language.

As big fans of Rust (moon is written in it), we're stoked to finally add full language support, and
to integrate our first non-JavaScript language! This release is rather massive, and required a ton
of internal work, most of which we'll skip over.

Instead we'll only talk about the key features that you, the consumers, will actually care about. To
start, we've started working on a Rust handbook, that outlines how to enable Rust, what kind of
integrations we support, and a handful of common questions.

  

## New `rust` configurations

Languages in
[moon are enabled through configuration](/docs/how-it-works/languages#enabling-a-language) blocks in
[`.moon/toolchain.yml`](/docs/config/toolchain), and Rust is no different. We now support a
[`rust`](/docs/config/toolchain#rust) toolchain setting
([view all available settings](/docs/config/toolchain#rust)).

```yaml title=".moon/toolchain.yml"
rust:
  version: '1.69.0'
```

When the `rust` setting is defined, it will enable the language and
[deep platform integration](/docs/how-it-works/languages#tier-2--platform), and when the `version`
field is defined, it will further enable
[toolchain support](/docs/how-it-works/languages#tier-3--toolchain). Both of these features provide
heavy automation, improving the overall developer experience.

This is fantastic, but what if another Rust project in the monorepo requires a different toolchain
channel/version? If so, they can use the new [`toolchain.rust`](/docs/config/project#rust) setting
in [`moon.yml`](/docs/config/project) to define project-level overrides.

```yaml title="/moon.yml"
toolchain:
  rust:
    version: '1.58.0'
```

## New `rust` task platform

The main benefit of Rust language support is that tasks can be ran within the context of our
[Rust platform integration](/docs/how-it-works/languages#tier-2--platform). This can easily be done
by setting the project's [`language`](/docs/config/project#language) to "rust" in
[`moon.yml`](/docs/config/project).

This will set the [`platform`](/docs/config/project#platform-1) of all tasks within the project to
"rust", unless they have been explicitly configured to something else.

```yaml title="/moon.yml"
language: 'rust'
type: 'application'
```

If you're mixing languages within a single project, and can't use the `language` setting above, you
can define `platform` on the task directly.

```yaml title="/moon.yml"
tasks:
  build:
    command: 'cargo build'
    platform: 'rust'
```

> We also attempt to detect this automatically by comparing command names and checking for the
> existence of files like `Cargo.toml`.

## Updated `moon init` command

As part of this release, we've also updated the [`moon init`](/docs/commands/init) command to
support initializing Rust. By default, the command will prompt you on whether to install Rust or
not, otherwise, when `--yes` is passed, the language will be installed if a `Cargo.toml` file is
detected in the destination directory.

If you already have a moon workspace, you can pass `--tool rust` to install Rust into the workspace.

```shell
$ moon init --tool rust
```

## Updated `moon docker` commands

And lastly, we also want to provide a great [`Dockerfile` experience](/docs/guides/docker) when
using Rust. The [`moon docker scaffold`](/docs/commands/docker/scaffold) command has been updated to
copy `Cargo.toml`, `Cargo.lock`, `rust-toolchain.toml`, and other Rust/Cargo related files. When
using Cargo workspaces, nested `Cargo.toml` files are also scaffolded.

```docker
RUN moon docker scaffold rust-app
```

Furthermore, we've also updated the [`moon docker prune`](/docs/commands/docker/scaffold) command to
remove the entire `target` directory, greatly reducing the size of the image. Pruning makes the
assumption that it's being ran _after_ a release profile has been built.

```docker
RUN moon run rust-app:build-release
RUN moon docker prune
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.5.0) for a full list of
changes.

---

## moon v1.6 - Persistent tasks and task extending RFC

import Button from '@site/src/ui/Button';

In this release, we're introducing a new feature called persistent tasks, and an RFC for extending
tasks.

## RFC: Task extending/variants

Before we dive into this release, we want to briefly talk about a new RFC that we're looking for
feedback on, [task extending/variants](https://github.com/moonrepo/moon/issues/849). This is a
feature that has been top-of-mind since moon's inception, but we haven't had the foundation in place
to support it, nor what the API should look like.

The gist of the RFC is that we want to support tasks that extend other tasks with additional
arguments. This is a common workflow with npm scripts:

```json
{
  "scripts": {
    "lint": "eslint .",
    "lint:fix": "npm run lint --fix"
  }
}
```

As consumers of moon, we'd appreciate any feedback on the RFC before we move forward!

  

## Persistent tasks

Tasks that never complete, like servers and watchers, are known as persistent tasks. Historically we
had support for these kinds of tasks through the [`local`](/docs/config/project#local) setting in
[`moon.yml`](/docs/config/project). This setting would modify the task for continuous execution by
disabling caching, streaming output, and not running in CI.

While this worked for the most part, there was one scenario that was still problematic, and that was
running multiple persistent tasks in parallel. Depending on the task dependency chain, sometimes
these tasks would _not_ run in parallel, some may never start (blocked on another tasks), or the
order of nodes in the graph is non-ideal. A great example of this can be found in this
[discussion thread](https://github.com/moonrepo/moon/discussions/830).

To mitigate this problem, we're introducing a new task option,
[`persistent`](/docs/config/project#persistent) (which is also enabled by the `local` setting). When
a task is marked as persistent, it will always _run last and in parallel_ within the dependency
graph, after all dependencies (from all other persistent tasks) have completed.

```yaml title="moon.yml"
tasks:
  dev:
    command: 'next dev'
    local: true
    # OR
    options:
      persistent: true
```

This is a perfect solution to running multiple development servers and tools in watch mode:

```yaml title="moon.yml"
tasks:
  dev:
    command: 'noop'
    deps:
      - 'frontend:dev'
      - 'backend:dev'
      - 'database:start'
      - 'tailwind:watch'
```

## Logging migration

This is more of a heads up than anything, but we've started an internal Rust migration from the old
[log](https://crates.io/crates/log) crate to the new [tracing](https://crates.io/crates/tracing)
crate. Tracing provides is with far more information, metrics, and instrumentation, which we hope to
take advantage of in the future.

This will be an ongoing migration that will last for many releases, and during this time while we
support both `log` and `tracing` in unison, the logs will be a bit noisy. We'll be working to clean
up the logs as we gradually convert the codebase.

And lastly, the move to `tracing` has also caused the log output to change. For example, in the log
excerpt below, all messages with "log" after the date are the old `log` crate, while the others with
distinct module names are the new `tracing` crate.

```log
[DEBUG 14:44:19] moon_process::command_inspector  Running command git status --porcelain --untracked-files -z  env_vars={} working_dir="~/Projects/moon"
[DEBUG 14:44:19] log  Filtering based on touched status "all"  log.target="moon:query:touched-files" log.module_path="moon_cli::queries::touched_files" log.file="crates/cli/src/queries/touched_files.rs" log.line=85
[DEBUG 14:44:19] log  Creating dependency graph  log.target="moon:dep-graph" log.module_path="moon_dep_graph::dep_builder" log.file="crates/core/dep-graph/src/dep_builder.rs" log.line=35
[DEBUG 14:44:19] log  Running 32 actions across 5 batches  log.target="moon:action-pipeline" log.module_path="moon_action_pipeline::pipeline" log.file="crates/core/action-pipeline/src/pipeline.rs" log.line=93
[DEBUG 14:44:19] log  Setting up Node.js 20.0.0 toolchain  log.target="moon:action:setup-tool" log.module_path="moon_action_pipeline::actions::setup_tool" log.file="crates/core/action-pipeline/src/actions/setup_tool.rs" log.line=26
[DEBUG 14:44:19] proto_node::resolve  Resolving a semantic version for "20.0.0"
[DEBUG 14:44:19] proto_core::resolver:load_versions_manifest  Loading versions manifest from local cache  cache_file=~/.proto/temp/3d16d1693e83828f98bae178f181d5a01103b7f222db27cdeaec9b4950e951d7.json
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.6.0) for a full list of
changes.

- Updated long running processes to log a checkpoint indicating it's still running.
- Reworked file groups to use workspace relative paths, instead of project relative.
- Reworked processes to better handle command line arguments, shells, and piped stdin input.

---

## proto v0.9 - New GitHub action, plugin unpacking, and more

This is a small release that provides many internal improvements.

## New `moonrepo/setup-proto` GitHub action

If you're using proto in GitHub Actions and would love to automate the workflow as much as possible,
well look no further, as we're introducing the
[moonrepo/setup-proto](https://github.com/moonrepo/setup-proto) action. Thanks to
[Tom Davidson](https://github.com/tomdavidson) for the initial spike of work!

This action will automatically install the `proto` binary globally, and cache the toolchain at
`~/.proto` (be sure to run `proto use` to download and install tools).

```yaml
# ...
jobs:
  ci:
    name: 'CI'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: 'actions/checkout@v4'
      - uses: 'moonrepo/setup-proto@v0'
      - run: 'proto use'
```

> If you're using moon, be sure to use
> [moonrepo/setup-moon](https://github.com/moonrepo/setup-moon-action) instead.

## Added `install.unpack` to TOML plugin

Our [TOML plugins](./proto-v0.7#toml-plugins) have been quite popular, and the community has been
using them to much success. However, the plugin assumed that all downloaded files are archives (tar,
zip) and will attempt to unpack them based on file extension. This is not always the case, as some
downloads are just raw executables.

Because of this, unpacking would sometimes fail, or we'd be unable to extract the correct file
extension. To work around this limitation, we're introducing a new setting, `install.unpack`, that
controls whether the downloaded file should be unpacked or not. By default this setting is `true`.

Here's an example using [moon](/moon).

```toml
# ...

[platform.linux]
download-file = "moon-{arch}-unknown-linux-{libc}"

[platform.macos]
download-file = "moon-{arch}-apple-darwin"

[platform.windows]
download-file = "moon-{arch}-pc-windows-msvc.exe"

[install]
download-url = "https://github.com/moonrepo/moon/releases/download/v{version}/{download_file}"
unpack = false
```

## Initial support for `node-gyp`

The [`node-gyp` binary](https://github.com/nodejs/node-gyp) is required for building Node.js native
addons, and was previously not supported in proto. We will now create a `node-gyp` binary in
`~/.proto/bin` when the `npm` tool is installed. Why npm? Because `node-gyp` comes packaged with npm
instead of Node.js... for some reason.

With that being said, this is currently experimental, as we haven't tested it thoroughly, and are
unaware of all the possible edge cases. So keep that in mind!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.9.0) for a full list
of changes.

---

## moon v1.7 - Next-generation configuration and errors

import Image from '@site/src/components/Image';

With this release, we've rewritten configuration from the ground up, improved error messages, and
started work on diagnostics!

## Configuration rewrite

If you've ever written Rust before, you may be familiar with the state of configuration crates in
the ecosystem. There's only 2 viable choices to choose from, and we've been using 1 of them.
However, it's been a constant source of friction for our use cases, and didn't support features that
we've needed (built-in validation, file extending, and more).

After researching our options, and attempting to contribute upstream, we decided to build our own
configuration solution, unique to moonrepo's projects. As such, we're excited to announce
[schematic](https://github.com/moonrepo/schematic), the most powerful configuration crate in the
Rust ecosystem, with built-in features like:

- Strict parsing with serde (serilization, deserialization).
- Code frames in errors (when applicable).
- Source file/URL extending.
- Partial file parsing and merging.
- Field-level merge strategies.
- Recursive validation.
- Dynamic default and env var values.
- And much more!

We've spent the last few weeks building this crate from the ground up, and migrating the moon
codebase to it. It's been quite a feat, but we're very excited for what it has to offer already, and
what's to come!

### Strict parsing

When we fail to parse a configuration file, we now include a descriptive message of the failure, and
the file that failed to parse. Typically this will be for unknown fields and invalid value types.

> We hope this bubbles up typos and incorrectly nested settings!

### Recursive validation

Previously when validation would fail, we'd return on the first error and ignore subsequent errors.
This is a non-ideal experience as you'd have to constantly run `moon` commands until all validation
issues have been resolved.

Now we aggregate all validation errors, even from deeply nested fields, and present them together.

### What's next?

Since [schematic](https://github.com/moonrepo/schematic) is very young, and it hasn't been tested
heavily in the ecosystem, we expect bugs and weird edge cases to popup. If you encounter any issues,
please report them immediately so that we can fix them as soon as possible!

With that being said, we'll continue to improve parsing, error messages, and unique functionality,
like code frames within errors. Here's an example for a basic JSON file.

## Better errors

You may have noticed the errors in the screenshots above look quite different than what we've
rendered until now, and you are correct. Going forward, all errors will be rendered by the wonderful
Rust crate, [miette](https://crates.io/crates/miette).

We've introduced this crate to handle _all_ errors and diagnostics within moon, not just
configuration. So expect a much better developer experience moving forward!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.7.0) for a full list of
changes.

- Added support for npm lockfile v3 format.

---

## moon v1.8 - Code owners and shared configuration

With this release, we've focused on a critical facet of managing a large codebase, source code
ownership, and sharing task configuration.

## Support for code ownership

An important workflow for companies of any size is reviewing code, and ensuring the right people are
reviewing and approving that code. This is especially true for large companies with hundreds of
developers, or many distinct teams working in a single codebase.

Popular VCS providers like [GitHub](https://github.com/), [GitLab](https://about.gitlab.com/), and
[Bitbucket](https://bitbucket.org/product/) provide built-in features to handle such workflows,
aptly named code owners. They all achieve this through a similar mechanism, a single `CODEOWNERS`
file that maps file system paths to owners (users, teams, groups, etc). These owners are then
required to approve a pull/merge request because it can be merged into the base branch.

:::info

For more information, view our official in-depth [code owners guide](/docs/guides/codeowners)!

:::

### Generate a `CODEOWNERS`

Managing the `CODEOWNERS` file manually can be a tedious task, especially when you have hundreds of
projects. To help with this, moon can generate the `CODEOWNERS` file for you,
[based on project owners](#new-project-owners-setting), formatted to your VCS provider of choice.
This helps to avoid an out-of-date ownership file!

We're introducing a few new workspace settings to handle this, the first is
[`codeowners`](/docs/config/workspace#codeowners), which enables and configure code ownership as a
whole, and the second is [`vcs.provider`](/docs/config/workspace#provider), which determines the VCS
provider to generate the file for (and unlocks future features).

```yaml title=".moon/workspace.yml"
codeowners:
  syncOnRun: true
  globalPaths:
    '*': ['@admins']

vcs:
  manager: 'git'
  provider: 'github'
```

The settings above will generate the following file:

```shell title=".github/CODEOWNERS"
# (workspace)
* @admins
```

While this looks very simple, it really shines once projects start adding their own granular code
ownership. Continue reading for more information!

### New project `owners` setting

To make use of code owners, you'll need to define an [`owners`](/docs/config/project#owners) setting
in a project's [`moon.yml`](/docs/config/project) file. This setting requires a list/map of owners
(contributors required to review) associated to file paths/patterns, relative from the current
project's root.

```yaml title="packages/components/moon.yml"
owners:
  paths:
    'src/': ['@frontend', '@design-system']
    '*.config.js': ['@frontend-infra']
    '*.json': ['@frontend-infra']
```

These paths will then be prefixed with the project source when
[generating the `CODEOWNERS`](#generate-a-codeowners) file.

```shell title=".github/CODEOWNERS"
# components
/packages/components/src/ @frontend @design-system
/packages/components/*.config.js @frontend-infra
/packages/components/*.json @frontend-infra
```

### New `moon sync codeowners` command

Although moon can [automatically generate](/docs/config/workspace#synconrun) the `CODEOWNERS` file
when running a target, there may be situations where this is disabled, or teams/developers would
like to generate the file manually. To handle this, we're providing the
[`moon sync codeowners`](/docs/commands/sync/codeowners) command, which will trigger the generation
process.

```shell
$ moon sync codeowners
```

## Community-driven task configuration

A powerful but often overlooked feature of moon is the ability to
[share and extend task configuration](/docs/guides/sharing-config) from remote sources. This is
extremely useful in...

- Providing a single source of truth for configuration.
- Reducing task duplication across projects.
- Ensuring tasks are battle-tested and ready for use.

The other upside of this approach is that configuration can be _community-driven_! To support this
as a first-class feature, we're launching the
[`moon-configs` repository](https://github.com/moonrepo/moon-configs), a collection of task
configurations for popular programming languages, frameworks, libraries, and more! As of now, the
repository is kind of empty, but we're hoping to grow it over time, so feel free to contribute!

If you're curious how this works in practice, we'll use our Rust configuration as an example. The
entire system is based around [tag inheritance](/docs/concepts/task-inheritance), where a project
can inherit tasks from a remote source, and then extend or override them as needed. For example,
create the tag-based config:

```yaml title=".moon/tasks/tag-rust.yml"
extends: 'https://raw.githubusercontent.com/moonrepo/moon-configs/master/rust/tasks-workspace.yml'
```

And then in Rust projects that you'd like to inherit these tasks, add the following tags:

```yaml title="/moon.yml"
tags: ['rust']
```

It's as simple as that!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.8.0) for a full list of
changes.

- Added a new action to the graph, `SyncWorkspace`, that'll be used for workspace-level checks.
- Added `MOON_OUTPUT_STYLE` and `MOON_RETRY_COUNT` environment variables.

---

## proto v0.11 - New shims and better logging

This is a small release that improves shims and logs.

## New and improved shims

The core facet of proto is our shims found at `~/.proto/bin`. They exist purely to re-route tool
executions internally to proto, so that we can detect the correct version of these tools to run.
However, maintaining and creating these shims has historically been very complicated. So we chose to
rewrite them from the ground-up!

All tools should continue to function exactly as they did before, if not better. Furthermore,
because of this new shim layer, we're now able to create what we call "secondary shims", like
[`bunx` for Bun](https://bun.sh/docs/cli/bunx), `pnpx` for pnpm, and `yarnpkg` for Yarn.

## Better logging

proto has supported logging since its initial release behind the `PROTO_LOG` environment variable.
However, this variable wasn't heavily documented, nor easily discoverable. So as an alternative, we
now support a global `--log` option, which can be passed to any `proto` command.

```shell
$ proto install node --log trace
```

On top of this, we also ran an audit of all our log calls, to improve messaging, include additional
information, rework applicable levels, and more. They should be far more readable!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.11.0) for a full list
of changes.

---

## moon v1.9 - VCS hooks management and improved task inheritance

In this release, we're introducing a long requested feature, VCS hooks! As well as a complete
rewrite of our task inheritance layer.

## Support for VCS hooks

In our last release, we added support for [code ownership](./moon-v1.8), to better help teams manage
their code review and approval workflows. To continue this trend of "features all companies require
but don't have a good solution for", we're adding support for VCS hooks,
[starting with Git](https://git-scm.com/docs/githooks).

If you're unfamiliar with Git hooks, they're a mechanism for running scripts before or after certain
Git events. For example, before a commit is added, before pushing, or after merging. Hooks can be
used for such situations as:

- Ensuring commit messages abide by a certain format.
- Ensuring affected project's source code pass linting and formatting checks.
- Validating configuration files.
- And much more!

:::info

For more information, view our official in-depth [VCS hooks guide](/docs/guides/vcs-hooks)!

:::

### New `vcs` settings

To support hooks, we're introducing the `vcs.hooks` and `vcs.syncHooks` settings to
[`.moon/workspace.yml`](/docs/config/workspace). The former is where you configure the list of
commands to run, grouped by hook type.

```yaml title=".moon/workspace.yml"
vcs:
  hooks:
    pre-commit:
      - 'pre-commit run'
      - 'moon run :lint --affected'
```

The latter will automatically create and sync hooks with the local VCS checkout, enabling them going
forward. [Learn more about enabling hooks](/docs/guides/vcs-hooks#enabling-hooks), and choosing the
approach that works best for you or your team!

### New `moon sync hooks` command

Although moon can [automatically create](/docs/config/workspace#synchooks) hooks when running a
target, this may be undesirable or abrasive for some developers. Instead, we also support an opt-in
solution through the [`moon sync hooks`](/docs/commands/sync/hooks) command, which will manually
create the hooks.

```shell
$ moon sync hooks
```

## Rewritten task inheritance

One of the most complicated systems in moon is the task inheritance layer. On the surface, it sounds
rather simple, but internally it was very complicated. For common use cases, it worked very well,
but for advanced use cases, how a task was "inherited and merged" was sometimes undefined behavior.

Over the past year, we've introduced many new features, such as
[implicit dependencies and inputs](./v0.23), [tag-based task inheritance](./moon-v1.2),
[project-level environment variables](./v0.23#project-level-environment-variables),
[custom languages](./v0.25#custom-project-language) and
[platforms](./v0.24#project-level-task-platform), and so much more. Each of these new features would
throw yet another facet to be aware of during the task inheritance model, and over the past year, it
has become rather unwieldy.

To rectify this situation before it becomes worse, we rewrote our
[project, task](https://github.com/moonrepo/moon/pull/921), and
[task inheritance](https://github.com/moonrepo/moon/pull/939) layers from the ground-up using a new
builder pattern, including writing all new unit tests, to properly and efficiently account for all
edge cases.

Going forward, tasks should be far more accurate and deterministic. If you encounter any weirdness,
it's either a bug/edge case that was rectified (and is no longer allowed), or a bug/edge case not
accounted for in our current unit test suite. Please report them either way!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.9.0) for a full list of
changes.

- Added `--clean` and `--force` flags to `moon sync codeowners` command.
- Updated `moon init` to detect VCS providers and resolve fully-qualified tool versions.
- Improved VCS file handling, caching, and performance.

---

## proto v0.12 - Experimental WASM plugins

import Button from '@site/src/ui/Button';

After months of hard work, we're excited to release our first iteration of WASM plugins for proto.

## WASM plugins

Three months ago, we [published an RFC](https://github.com/moonrepo/proto/issues/73) for supporting
plugins in proto. Plugins are a must, as they allow consumers to easily extend proto with additional
tools, instead of them being built into proto core (which is very time consuming).

Two months ago, we released support for [TOML plugins](/docs/proto/non-wasm-plugin). These are very
simple plugins powered by static configuration files. They're great for simple tools like CLIs and
pre-built languages, as everything is powered by static HTTP URLs and file names. However, sometimes
you need dynamic control...

And after 2 months of development, and help from the [Extism team](https://extism.org/), we're
excited to announce initial support for WASM plugins. WASM is a portable binary format, with
sandboxed access to the file system (via WASI), and the ability to execute processes and fetch URLs.
This means that plugins can be written in any language that compiles to WASM, like Rust, C, C++, Go,
TypeScript, and more. This removes the requirement of writing Rust and contributing to proto
directly!

  

### Using WASM plugins

Once the `.wasm` file is publicly available for download, we can configure it as a plugin in
[`.prototools`](/docs/proto/config).

```toml
[plugins]
my-plugin = "source:https://domain.com/path/to/wasm/plugin.wasm"
```

And execute all `proto` commands using the configured plugin identifier.

```shell
proto install my-plugin
```

### Example implementation

The official guide above walks you through creating a plugin, but to demonstrate the power of WASM
plugins, here's an example function that defines parameters for downloading and installing Node.js.
This is written in Rust and using Extism's official PDK.

```rust
#[plugin_fn]
pub fn download_prebuilt(
    Json(input): Json,
) -> FnResult> {
    let version = input.env.version;
    let arch = input.env.arch;

    let prefix = match input.env.os {
        HostOS::Linux => format!("node-v{version}-linux-{arch}"),
        HostOS::MacOS => format!("node-v{version}-darwin-{arch}"),
        HostOS::Windows => format!("node-v{version}-win-{arch}"),
        other => {
            return Err(PluginError::UnsupportedPlatform {
                tool: NAME.into(),
                platform: format!("{:?}", other),
            })?;
        }
    };

    let filename = if input.env.os == HostOS::Windows {
        format!("{prefix}.zip")
    } else {
        format!("{prefix}.tar.xz")
    };

    Ok(Json(DownloadPrebuiltOutput {
        archive_prefix: Some(prefix),
        download_url: format!("https://nodejs.org/dist/v{version}/{filename}"),
        download_name: Some(filename),
        checksum_url: Some(format!("https://nodejs.org/dist/v{version}/SHASUMS256.txt")),
        ..DownloadPrebuiltOutput::default()
    }))
}
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.12.0) for a full list
of changes.

---

## moon v1.10 - Mid-year quality of life improvements

import Button from '@site/src/ui/Button';

Instead of launching a large feature this release, we're focusing on quality of life and developer
experience improvements.

## Quality improvements

In the past 6 months, we've released over 16 versions of moon, with our official v1.0 release among
them. This is extremely impressive and we're very proud of the progress we've made. To continue this
trend, we'll be starting a new initiative that will land quality of life improvements (instead of
major features) every 6 months, starting with this release!

### Potential breaking changes

While APIs haven't changed, we have introduced some fixes for edge case that could be considered
breaking, but for the most part, these changes probably won't affect you. With that being said...

The first fix is that tasks configured with the same `outputs` location (including glob overlap)
will now error. This is extremely problematic for caching and hydration, as multiple tasks all
writing to the same output will inflate the tarball, and cause unwanted side effects. To demonstrate
this, the following is now an error:

```yaml title="moon.yml"
tasks:
  build:
    command: 'foo build'
    outputs:
      - 'dist'

  compile:
    command: 'bar compile'
    outputs:
      - 'dist'
```

The other fix, which primarily applies to [`moon ci`][ci] and [`moon check`](/docs/commands/check),
is that a target will be skipped if one of its dependencies failed or has also been skipped.
Previously the target would attempt to run and most likely fail since it relied on artifacts from
its dependencies (which don't exist). Another benefit of this change is that runs should be much
faster, as we're not wasting time running targets that we know will fail, which is great for CI.

### Ignore hashing input files

We're introducing 2 new settings to [`.moon/workspace.yml`](/docs/config/workspace) that'll provide
more control over the hashing flow, [`hasher.ignorePatterns`](/docs/config/workspace#ignorepatterns)
and [`hasher.ignoreMissingPatterns`](/docs/config/workspace#ignoremissingpatterns).

The `ignorePatterns` setting can be used to entirely ignore a file (using glob patterns) from being
hashed, and in turn, exclude it as an input source. For example, say we want to ignore all image
files.

```yaml title=".moon/workspace.yml"
hasher:
  ignorePatterns:
    - '**/*.{png,svg}'
```

The `ignoreMissingPatterns` setting pairs with
[`hasher.warnOnMissingInputs`](/docs/config/workspace#warnonmissinginputs). When enabled, moon will
log a warning to the terminal that an input is missing. This is useful for uncovering
misconfigurations, but can be quite noisy when inputs are truly optional. This new setting can be
used to filter these warnings.

```yaml title=".moon/workspace.yml"
hasher:
  warnOnMissingInputs: true
  ignoreMissingPatterns:
    - '**/.eslintrc.*'
    - '**/*.config.*'
```

### Customize base and head revision

The [`moon ci`][ci] command has always supported customizing the Git base and head revisions through
the `--base` and `--head` options respectively. This was a requirement for running CI effectively,
by comparing across branches or commits. However, the [`moon run`][run] did not support this, as
this command was designed to primarily be run locally, but it turns out, y'all are using it in CI
too!

To improve the effectiveness of `moon run` in CI, we've made the following improvements, all of
which require the `--remote` option to be passed.

- Added support for `MOON_BASE` and `MOON_HEAD` environment variables, for customizing the base and
  head revisions respectively (also supported in `moon ci`). If not defined, will use the default
  branch and `HEAD`.
- When the current branch is the default branch, the base revision will be the previous commit.
  Useful for commits landing on master/main.

## New debugging a task guide

Running tasks is the most common way to interact with moon, so what do you do when your task isn't
working as expected? Diagnose it of course! However, diagnosing the root cause of a broken task can
be quite daunting:

- Is configuration wrong?
- What about inheritance? Or merging?
- Is the task platform correct?
- Were tokens expanded correctly?
- What about variable substitution?
- So on and so forth...

To help answer these questions, we're excited to publish an
[in-depth guide for debugging a task](/docs/guides/debug-task)! These steps are the same steps we
use internally to diagnose reported issues, or help the Discord community. We hope you find this
guide extremely beneficial!

  

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.10.0) for a full list
of changes.

- Updated [`moon ci`][ci] to include a summary of all failed actions.
- Updated the run report to include stderr/stdout for all attempts.

[ci]: /docs/commands/ci
[run]: /docs/commands/run

---

## proto v0.13 - Bun, Deno, and Go now powered by WASM plugins

With this release, we're embracing WASM even further.

## Core migration to WASM

Now that WASM plugin support is up and running, we've hit a non-ideal situation where we have
multiple competing implementations for "tools" in proto. We currently have 3 different approaches:

- Tools implemented in Rust and built into proto's core.
- TOML based plugins, with a simple Rust based wrapper.
- WASM based plugins.

This is far too many implementations to support, and makes it extremely difficult to add new
features for tools, as it affects all 3. To remedy this situation, we've decided to migrate all core
tools to WASM plugins, and remove the Rust based implementations. The core of proto and its CLI will
still be Rust, but will be slowly migrated into a truly pluggable architecture.

To test drive and experiment with this solution, we've migrated
[Bun](https://github.com/moonrepo/bun-plugin), [Deno](https://github.com/moonrepo/deno-plugin), and
[Go](https://github.com/moonrepo/go-plugin) into WASM plugins, and starting with this release, they
are purely powered by WASM and have been removed entirely from the Rust implementation.

In the next release, we hope to migrate Node.js and Rust as well. And in a future release, the TOML
plugins will be compiled into
[`.wat` files](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format)
and loaded as WASM plugins. From here, we will have a single tool implementation, and can implement
some really exciting features!

## New `github:` plugin configuration

Alongside the `source:` configuration strategy, plugins can now be configured with the `github:`
strategy to locate WASM files from GitHub releases. For example, the `bun_plugin.wasm` file will be
downloaded from our
[`bun-plugin`'s latest release](https://github.com/moonrepo/bun-plugin/releases).

[Learn more about this new locator scope!](/docs/proto/plugins)

```toml title=".prototools"
[plugins]
bun = "github:moonrepo/bun-plugin"
```

> Bun support is built into proto, there is merely an example!

## New `proto plugins` commands

With the advent of plugins, we thought it would be nice to know which plugins are actually
configured and in use, without having to manually search config files across the file system, and as
such, have added a new [`proto plugins`](/docs/proto/commands/plugin/list) command.

This command is simple. It will list all plugins that are currently configured for the current
project, by loading all `.prototools` files up the tree, and loading the user
`~/.proto/config.toml`.

```shell
$ proto plugins
bun - Bun
  GitHub: moonrepo/bun-plugin
  Tag: latest

deno - Deno
  GitHub: moonrepo/deno-plugin
  Tag: latest

go - Go
  GitHub: moonrepo/go-plugin
  Tag: latest
```

[Learn more about this new command!](/docs/proto/commands/plugin/list)

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.13.0) for a full list
of changes.

- Added documentation for writing [unit tests for WASM plugins](/docs/proto/wasm-plugin#unit-tests).
- Updated `proto clean` and `proto use` to load and merge all `.prototools` from the current
  directory and upwards.
- Many WASM API improvements.

---

## moon v1.11 - Next-generation project graph

With this release, we've focused heavily on rewriting our project graph for the next-generation of
moon.

## New project graph

One of the first features that was built for moon was the project graph, as this was required to
determine relationships between tasks and projects. Its initial implementation was rather simple, as
it was a basic directed acyclic graph (DAG). However, as moon grew in complexity, so did the project
graph, and overtime, it has accrued a lot of cruft and technical debt.

One of the biggest pain points has been the project graph cache, and correctly invalidating the
cache for all necessary scenarios. If you've been using moon for a long time, you're probably aware
of all the hot fixes and patches that have been released. Another problem with the cache, is that it
included hard-coded [file system paths](https://github.com/moonrepo/moon/issues/937) and
[environment variables](https://github.com/moonrepo/moon/issues/896), both of which would not
invalidate the cache when changed.

We felt it was time to rebuild the project graph from the ground up. Some of this work has already
landed in [previous releases](./moon-v1.9#rewritten-task-inheritance).

### Old implementation

For those of you who are interested in the technical details, here's a quick overview of how the old
project graph worked. To start, the graph was composed around the following phases:

- **Build** - Projects are loaded into the graph (nodes), relationships are linked (edges),
  configurations are read, tasks are inherited, and platform/language rules are applied.
- **Expand** - In all tasks, token variables and functions are expanded/substituted, dependencies
  are expanded (`^:deps`, etc), `.env` files are read (when applicable), so on and so forth.
- **Validate** - Enforces project and task boundaries and constraints.

This is quite a lot of work, and it was all done in _a single pass_. What this means is that for
each project loaded into the graph, we would recursively build -> expand -> validate, until all
projects have been loaded, synchronously at once in the same thread. Because this is a rather
expensive operation, the project graph cache was introduced to avoid having to do this work on every
run.

Makes sense, right? For the most part yes, but there is a core problem with the solution above, and
if you've noticed it already, amazing! The problem is that out of these 3 phases, only the build
phase is truly cacheable, as the expand and validate phases are far too dynamic and dependent on the
environment. This means that the cache is only partially effective, and in some cases, entirely
broken.

Another unrelated problem with this solution, is that because everything is built in a single pass,
advanced functionality that requires multiple passes is not possible and has been stuck on the
backlog.

### New implementation

For backwards compatibility, the new project graph works in a similar manner, but has none of the
shortcomings of the old implementation (hopefully). To start, the new project graph still has the
same 3 phases, but they are _no longer processed in a single pass_, instead...

The build phase is now asynchronous, enabling deeper interoperability with the rest of the
async-aware codebase. However, the critical change is that the project graph cache is now written
_after_ the build phase (and read _before_), instead of after the entire graph being generated.

> The new cache file is `.moon/cache/states/partialProjectGraph.json`, and is named partial because
> tasks have not been expanded. Use `moon project-graph --json` for a fully expanded graph.

The expand phase has changed quite a bit. Instead of expanding everything at once, projects and
tasks are only expanded when they are needed. For example, if only running a single target, we'll
now only expand that project and task, instead of _everything_ in the graph. With this change, you
should potentially see performance increases, unless you're using `moon ci` or `moon check --all`.

And lastly, validation is still the same, but has been reworked so that we can easily extend it with
more validation rules in the future.

### Unlocked features

With these changes to building and expanding, we've unlocked a few new features that were not
possible before.

- Task dependencies can now reference tag based targets. For example, say we want to build all React
  projects before starting our application.

```yaml title="moon.yml"
tasks:
  dev:
    command: 'next dev'
    deps:
      - '#react:build'
```

- Task commands and arguments will now substitute environment variables, by first checking `env`,
  then those from the system.

```yaml title="moon.yml"
tasks:
  build:
    command: 'docker build --build-arg pkg=$PKG_NAME'
  env:
    PKG_NAME: 'foo-bar'
```

- Project dependencies can now mark relationships as `build`. This is only applicable for languages
  that support build dependencies, like Rust.

```yaml title="moon.yml"
dependsOn:
  - id: 'foo'
    scope: 'build'
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.11.0) for a full list
of changes.

- Identifiers (project names, file groups, etc) can now be prefixed with underscores (`_`).
- Added Poetry detection support for Python projects.
- Added an `experiments` setting to `.moon/workspace.yml`.

---

## proto v0.14 - Node.js and Rust now powered by WASM plugins

With this release, we've finished our migration to a WASM based plugin architecture.

## Full migration to WASM

In [our last release](./proto-v0.13), we migrated the Bun, Deno, and Go plugins to WASM. In this
release, we're excited to announce that we have completed our WASM migration by also converting
Node.js (and npm, etc) and Rust to WASM plugins. We've also updated our TOML plugin layer to use
WASM under the hood.

With this, 100% of our tools are now powered by WASM, and the APIs are stable enough for you, the
consumers, to build your own plugins! We have plans for additional APIs in the next release,
primarily installing and uninstall globals, and a hooks system, so look forward to that! To learn
more about our official plugins, check out the their repositories!

- [Bun](https://github.com/moonrepo/bun-plugin)
- [Deno](https://github.com/moonrepo/deno-plugin)
- [Go](https://github.com/moonrepo/go-plugin)
- [Node](https://github.com/moonrepo/node-plugin)
- [Rust](https://github.com/moonrepo/rust-plugin)
- [Schema](https://github.com/moonrepo/schema-plugin)

This release may seem light, but we
[rewrote the entire core](https://github.com/moonrepo/proto/pull/161) from the ground up to support
a pure plugin based architecture. This was a lot of work, but our implementation is far easier to
work with, and more robust. As part of this process, we improved version and range handling, archive
unpacking, and much more!

> Because of the rewrite, we may have introduced a few bugs. Please report any issues!

## Breaking changes for TOML plugins

In preparation for the next release, and as clean up during the rewrite, we've made a few breaking
changes to the TOML schema, primarily around global handling. To start, this old code:

```toml
[install]
globals-dir = ["$PROTOSTAR_HOME/bin", "$HOME/.protostar/bin"]
global-args = ["install", "--force", "{dependency}"]
```

Can now be rewritten as:

```toml
[globals]
lookup-dirs = ["$PROTOSTAR_HOME/bin", "$HOME/.protostar/bin"]
install-args = ["install", "--force", "{dependency}"]
```

And lastly, the `install.unpack` setting has been removed. We believe our installation layer is
smart enough to unpack or move files automatically.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.14.0) for a full list
of changes.

- Versions defined in `.prototools` must be fully-qualified semantic versions. Partial versions
  (missing patch or minor) are no longer supported. This may change in the future based on feedback.
- Tool and plugin names must now be in kebab-case.
- Node
  - Yarn 2+ is now installed using `@yarnpkg/cli-dist`. We no longer downgrade to the latest v1.
  - Will no longer detect a version from `engines` in `package.json`.
- Rust
  - Will now detect a version/channel from `rust-toolchain.toml` and `rust-toolchain`.

---

## moon v1.12 - Task improvements: extending, interactive, and more

In this release, we focused heavily on improving tasks, its configuration, and related systems.

## Extending sibling or inherited tasks

Three months ago, we posted an
[RFC on how to support task extending / task variants](https://github.com/moonrepo/moon/issues/849).
On paper this doesn't sound like a hard problem to solve, but internally it would of been an uphill
battle to implement. Thanks to previous releases from the past few months, and the rewrite of the
project graph, task builder, and more, this implementation was a breeze. To finalize the RFC, we
went with option 2, by adding a new `extends` field to task configurations.

With this new addition, we can now rewrite this old configuration, which was needlessly
repetitive...

```yaml title="moon.yml"
tasks:
  lint:
    command: 'eslint .'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
      - '*.js'
      - '.eslintrc.js'
      - 'tsconfig.json'
      - '/.eslintignore'
      - '/.eslintrc.js'
      - '/tsconfig.eslint.json'
      - '/tsconfig.options.json'

  lint-fix:
    command: 'eslint . --fix'
    local: true
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
      - '*.js'
      - '.eslintrc.js'
      - 'tsconfig.json'
      - '/.eslintignore'
      - '/.eslintrc.js'
      - '/tsconfig.eslint.json'
      - '/tsconfig.options.json'
```

Into the following configuration.

```yaml title="moon.yml"
tasks:
  lint:
    command: 'eslint .'
    inputs:
      - '@globs(sources)'
      - '@globs(tests)'
      - '*.js'
      - '.eslintrc.js'
      - 'tsconfig.json'
      - '/.eslintignore'
      - '/.eslintrc.js'
      - '/tsconfig.eslint.json'
      - '/tsconfig.options.json'

  lint-fix:
    extends: 'lint'
    args: '--fix'
    local: true
```

We're very happy with this solution, as it's far more readable, maintainable, and doesn't introduce
yet another paradigm to learn. Our goal was to be as familiar as possible, while providing extensive
functionality behind the scenes, which we believe to have achieved.

Some other interesting facts around task extending:

- When extending a task, [merge strategies](/docs/concepts/task-inheritance#merge-strategies) are
  applied in a similar fashion to inheritance.
- Inherited tasks can be extended from by project-level tasks.
- It's possible to create multiple extended chains.

## Configure tasks as interactive

Six months ago, we added support for [interactive tasks in v0.24](./v0.24#interactive-tasks), but
only if certain conditions were met: if only 1 target is running, they are considered interactive,
or if the `--interactive` option was passed to [`moon run`](/docs/commands/run). However, we believe
it nice to support interactive tasks through task configuration directly, but it required some
thought into how this would work within the dependency graph and pipeline, as only 1 task can
interact with stdin at a time.

We solved this problem by reworking our dependency graph so that interactive tasks are isolated from
other actions in the graph, and are not run in parallel with other actions. This will result in
longer dependency chains, but results in a working stdin solution.

To mark a task as interactive, enable the [`options.interactive`](/docs/config/project#interactive)
setting.

```yaml title="moon.yml"
tasks:
  init:
    command: 'init-app'
    options:
      interactive: true
```

## Tokens in environment variables

Up until now, [token functions and variables](/docs/concepts/token) were only supported in task
commands, args, inputs, and outputs, but not environment variables... why? Honestly, there was no
real reason they weren't supported, it simply never crossed our mind! But thanks to requests from
the community, both token functions and variables are now supported in task
[`env`](/docs/config/project#env-1).

This is great for propagating moon values to other systems. For example, say you want to use moon
project names for Sentry, keeping a 1:1 mapping.

```yaml title="moon.yml"
tasks:
  start:
    command: 'run-server'
    env:
      SENTRY_PROJECT: '$project'
```

If you're familiar with tokens, you may be asking yourself, "How do token functions work since they
expand to a list of paths?" That's a great question! When token functions are used in an environment
variable, like `@group(sources)`, the list of paths will be joined with a comma (`,`).

```yaml title="moon.yml"
tasks:
  build:
    # ...
    env:
      SRCS: '@group(sources)'
```

Since the environment variable is simply a string, you could parse it with your language of choice
to extract the list of paths.

```js
const paths = process.env.SRCS.split(',');
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.12.0) for a full list
of changes.

- Added git worktree support.
- Updated task `outputs` to support negated globs.
- Will now log a warning to the console if a configuration file uses the `.yaml` extension.

---

## proto v0.15 - Install and uninstall globals

This is a small release that adds support for uninstalling globals, and improves our WASM APIs.

## Uninstall global dependencies

proto has supported [installing globals since v0.5](./proto-v0.5), but there's been no way to
uninstall an existing global, until now! In this release, we're introducing the
`proto uninstall-global` command, which will do just that! The API is exactly the same as its
installation counter-part.

```shell
proto install-global node prettier

# On second thought, nevermind...
proto uninstall-global node prettier
```

### WASM functions

Implementing this command was rather straight forward, but most of the work went into supporting
[`install_global` and `uninstall_global`](/docs/proto/wasm-plugin) functions for WASM plugins, and
then updating all existing plugins! For those of you writing your own plugins, here's an example of
what the Rust code looks like:

```rust
#[plugin_fn]
pub fn install_global(
    Json(input): Json,
) -> FnResult> {
    let result = exec_command!(inherit, "npm", ["install", "--global", &input.dependency]);

    Ok(Json(InstallGlobalOutput::from_exec_command(result)))
}
```

### TOML setting

We've also updated our TOML plugins to support uninstalling globals through the new
[`globals.uninstall-args`](/docs/proto/non-wasm-plugin) setting. Hopefully the name is self
explanatory, but it's a list of arguments passed to the tool's binary, that'll uninstall the global.

```toml
# ...

[globals]
install-args = ["install", "--global", "{dependency}"]
uninstall-args = ["uninstall", "--global", "{dependency}"]
```

## Improved WASM documentation

With each release we're slowly stabilizing the WASM and TOML APIs for an official v1 release (which
is soon), and with this, it requires more documentation. As part of this release, we've done a giant
polish pass on our WASM documentation, and have included the following sections:

- [Virtual paths](/docs/guides/wasm-plugins#virtual-paths)
- [Host environment](/docs/guides/wasm-plugins#host-environment)
- [Host functions](/docs/guides/wasm-plugins#host-functions--macros)
- [Tool ID and context](/docs/guides/wasm-plugins#plugin-identifier)

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.15.0) for a full list
of changes.

- Major WASM API improvements, including backwards incompatible changes.

---

## proto v0.16 - Add, remove, and purge plugins

This release adds functionality for managing plugins and purging the proto store.

## Add and remove plugins

Now that proto has fully embraced a plugin based architecture, we thought it'd be nice to support
the management of these plugins through the CLI. This release adds two new commands:
[`proto add-plugin`](/docs/proto/commands/plugin/add) and
[`proto remove-plugin`](/docs/proto/commands/plugin/remove).

Adding a plugin requires a unique ID and what we call a locator, which is a string that dictates
where to locate and download the plugin from. Here's an example for Node.js, but this isn't
necessary as it's built-in:

```shell
$ proto add-plugin node source:https://github.com/moonrepo/node-plugin/releases/latest/download/node_plugin.wasm
```

Additionally, removing a plugin is even easier.

```shell
$ proto remove-plugin node
```

## Purge tools and plugins

proto has supported cleaning for quite some time through the
[`proto clean`](/docs/proto/commands/clean) command (and the
[`auto-clean` setting](/docs/proto/config)), which would automatically delete installed tool
versions and temporary files that are older then a specific timeframe. This helps to free up disk
space for unused or rarely used tools.

In this release, we're expanding the `clean` command's functionality with a concept known as
purging, which will "delete entirely". The first being the new `--purge` option, which will delete a
tool, its manifest, _all_ installed versions, and the entire `~/.proto/tools/` directory.

```shell
# Delete all traces of Node.js
$ proto clean --purge node
```

Additionally, a new `--purge-plugins` option can be used to delete all downloaded plugins (the
`~/.proto/plugins` directory). Useful for house keeping or if you want to start fresh.

```shell
$ proto clean --purge-plugins
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.16.0) for a full list
of changes.

- Added folder locking during tool installation to avoid colliding processes.
- Renamed `PROTO_ROOT` to `PROTO_HOME`, but we'll support `PROTO_ROOT` for the time being.

---

## moon v1.13 - Toolchain now uses WASM plugins

This is a light release that focused primarily on upgrading to the WASM based proto implementation.

## proto upgrade and WASM plugins

Over the last few months, we've made immense strides on [proto](/proto), our multi-language
toolchain. For those of you unaware, moon's toolchain is built on top of proto, and we accomplish
this by utilizing the same Rust code between both tools.

However, moon has been locked to [proto v0.12](/blog/proto-v0.12), which was a purely Rust based
implementation. With the release of [proto v0.13](/blog/proto-v0.13) and onward, proto has moved to
a WASM based plugin architecture (with the core still in Rust), which allows us to support more
languages, and enables developers to write plugins in non-Rust languages.

And since our WASM plugins have stabilized by [proto v0.16](/blog/proto-v0.16), we felt it was time
to finally upgrade moon's implementation to the latest and greatest. So what does this mean exactly?
A few things:

- If you're using moon's [toolchain](/docs/config/toolchain) (like `node`), we will now download the
  [Node.js WASM plugins](https://github.com/moonrepo/node-plugin) in the background (to
  `~/.proto/plugins`).
- These plugins are in charge of downloading and installing the Node.js, npm, pnpm, or yarn version
  specified in your toolchain configuration.
- The entire plugin flow is now logged to the console, so you can see what's happening behind the
  scenes.
- In the future (most likely moon v2), our platform and language integration will also be powered by
  WASM plugins. This enables you to build your own custom plugins!

:::info

This entire process should be transparent to all users, and you should not notice any changes.
However, in case this upgrade causes issues, we wanted to isolate it from other changes, hence the
light release!

:::

## Allow tasks to fail

"Allow tasks to fail?" You ask yourself. "Doesn't that defeat the point of a task runner?" You
question further. "You're not wrong!" We reply. These questions assume a perfect repository state,
where all tasks either pass or fail, and there's no middle ground. In reality, very rarely is that
true, and we want to support those stuck in the middle, such as:

- In a heavy migration and it's known that a task is currently broken.
- The task is flaky but you've been unable to find the root cause.
- Upstream dependencies have published a backwards incompatible change, and you're waiting on a fix.
- And of course, in the middle of adopting moon!

For situations where a task consistently or sometimes fails, but you don't want it to fail the
entire pipeline (especially in CI), you can enable the new
[`allowFailure` task option](/docs/config/project#allowfailure).

```yaml title="moon.yml"
tasks:
  typecheck:
    command: 'tsc --build'
    options:
      allowFailure: true
```

When enabled, failing tasks will no longer bail [`moon run`](/docs/commands/run) early, nor will it
exit [`moon ci`](/docs/commands/ci) with a non-zero exit code. However, we still built guard rails
around this feature, as we don't want to encourage bad practices, and one of these guard rails is
that tasks that enable `allowFailure` _cannot_ be depended on by other tasks, as we cannot guarantee
that it's side-effect free.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.13.0) for a full list
of changes.

- Added colors to command line `--help` menus.
- Updated `runner.archivableTargets` to support tag scoped targets.
- Updated `moon query tasks --affected` to filter based on affected task, instead of affected
  project.

---

## proto v0.17 - Experimental Python support and canary releases

This release implements two long requested features, Python language support and canary releases.

## Experimental Python support

It's been quite a while since we've introduced a new language into proto, and we're excited to
announce the highly requested language, Python! Since Python is now an
[officially supported language](https://github.com/moonrepo/python-plugin), installing Python (and
pip) is as simple as:

```shell
$ proto install python
```

However, we're marking language support as experimental for the time being. We expect our
implementation to work for modern Python versions, but may not work for older versions, especially
Python 2. The reasons for this are as follows:

- proto will install pre-built binaries from
  [indygreg/python-build-standalone](https://github.com/indygreg/python-build-standalone). This is
  an unofficial project, and _does not_ support all Python versions.
- If [`python-build`](https://github.com/pyenv/pyenv/blob/master/plugins/python-build/README.md) is
  available, we'll attempt to use it to build + install Python. This currently requires `pyenv` to
  be installed, and _does not_ work on Windows.
- Furthermore, we only support `cpython` at the moment, and do not support `pypy`, `jython`, or
  other Python implementations. It's unknown whether this functionality should be in the core Python
  plugin, or another plugin entirely.

In a future proto version, we want to support a true "build from source" approach for all tools.
Once that functionality has landed, we can properly support Python on all platforms, but until then,
let us know how this works for you!

## Install canary releases

A canary release is a mechanism for rolling out new features and changes to a small subset of users,
without it being an official release on an official channel. This allows users to opt-in and test
functionality if they so choose. Canary releases are not meant to be used in production, and may
contain bugs or breaking changes. A canary is similar to a nightly (or weekly) release, depending on
the tool.

We now support this workflow in proto. To install a canary release, simply use the
[`--canary` flag when installing a tool](/docs/proto/commands/install):

```shell
$ proto install  --canary
```

This will install the latest canary release to `~/.proto/tools//canary`, and _only_ the latest
release can be used. Re-installing with `--canary` will overwrite the previous canary installation.

However, because we [detect a version to run with at runtime](/docs/proto/detection), how should you
actually run canary? The easiest way is to prefix the shim with an environment variable:

```shell
$ PROTO_BUN_VERSION=canary bun ./index.ts
```

Or to explicitly configure the version in [`.prototools`](/docs/proto/config):

```toml
bun = "canary"
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.17.0) for a full list
of changes.

- Added colors to command line `--help` menus.
- Updated the following locations to support partial versions and aliases:
  - Tool versions in `.prototools`.
  - Pinning a default version with `proto install --pin`.
  - Setting global version with `proto global`.
  - Setting local version with `proto local`.
- Node, npm, pnpm, and yarn will again extract a version from `package.json` engines.

---

## proto v0.18 - List installed tools and configure HTTP client

Today we've got a small release that includes some helpful features.

## New `proto tools` command

Are you curious what tools you have installed? And more specifically, which versions? What about
configured aliases? Until now, you had to manually check the `~/.proto/tools` directory for this
information, but now, you can simply run [`proto tools`](/docs/proto/commands/plugin/list) to get a
list of all installed tools.

This command will list all tools that have been installed, along with their installed versions,
relevant timestamps, available aliases, and store location.

```shell
$ proto tools
go - Go
  Store: ~/.proto/tools/go
  Versions:
    1.20.0 - installed 08/24/23, last used 09/18/23
    1.20.2 - installed 01/01/70, last used 09/18/23, default version

node - Node.js
  Store: ~/.proto/tools/node
  Aliases:
    ~20 = stable
  Versions:
    18.0.0 - installed 09/03/23, last used 09/18/23, default version
    18.14.0 - installed 09/04/23, last used 09/04/23
    18.17.1 - installed 09/04/23, last used 09/04/23
    19.0.0 - installed 09/03/23
    20.0.0 - installed 09/03/23
    20.6.0 - installed 09/04/23, last used 09/18/23
```

> This information can also be represented as JSON by passing the `--json` flag.

## New `[http]` user settings

Furthermore, we've added a new
[`[http]` setting to `~/.proto/config.toml`](/docs/proto/config#settingshttp) that allows you to
configure aspects of the HTTP client, which is primarily used for downloading tools.

This may useful if you're behind a proxy, a VPN, or corporate network, and certain requests and
certificates are blocked.

```toml title="~/.proto/config.toml"
[http]
proxies = ["http://intra.net/proxy"]
root-cert = "/path/to/root/cert.pem"
```

## Index for third-party tools

Now that our TOML and WASM plugins have stabilized, we felt the time was right to start working on a
third-party index, a registry of all available tools. We've updated the official
[Supported tools](/docs/proto/tools) documentation to now include third-party tools.

At this time, the list of tools is powered by a JS/JSON object,
[which can be found here](https://github.com/moonrepo/moon/blob/master/website/src/data/proto-tools.tsx).
In the future, we may move this to a database, add filtering, sorting, and everything else necessary
for showcasing tools maintained by the community!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.18.0) for a full list
of changes.

- For TOML plugins, we updated the schema internally to be represented as JSON instead of TOML,
  which may cause breakages depending on a version mismatch between proto and the plugin.

---

## moon v1.14 - Improvements to running targets and toolchain versions

In this release, we've focused on loosening restrictions to improve the overall developer
experience.

## Shorthand for `moon run`

This has been a long requested feature and we're happy to finally deliver it! You can now omit the
"run" keyword for the [`moon run`](/docs/commands/run) command, just so long as the first non-option
argument is a target (must contain a `:`).

```shell
# v1.13
$ moon run app:build

# v1.14+
$ moon app:build
```

## Choose targets for `moon ci`

When we initially built [`moon ci`](/docs/commands/ci), we wanted a solution that simply ran
everything in CI that _should be ran_, taking care of all the complicated logic to determine
affected tasks, comparing Git branches, gathering targets, partitioning across jobs, etc... And it
does just that, and it does it well!

However, one major caveat to using `moon ci` is that it runs _every task_ in the workspace (assuming
they're affected). This has been quite a blocker for adoption as teams may want fine-grained control
of their CI. For example, running build tasks in one job, lint tasks in another, so on and so forth.

In this release, we've made the necessary changes to allow these workflows, by supporting a list of
targets for `moon ci`, similar to how `moon run` works. If no targets are provide, the existing "run
everything" logic will be used.

```shell
# v1.13
$ moon ci

# v1.14+
$ moon ci :build :lint :etc
```

Splitting targets across jobs is demonstrated with the following GitHub Action workflow:

```yaml title=".github/workflows/ci.yml"
name: 'CI'
on:
  push:
    branches:
      - 'master'
  pull_request:
jobs:
  build:
    name: 'Build'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: 'actions/checkout@v4'
        with:
          fetch-depth: 0
      - uses: 'moonrepo/setup-moon-action@v1'
      - run: 'moon ci :build'
  format-lint:
    name: 'Format + Lint'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: 'actions/checkout@v4'
        with:
          fetch-depth: 0
      - uses: 'moonrepo/setup-moon-action@v1'
      - run: 'moon ci :format :lint'
  test:
    name: 'Test'
    runs-on: 'ubuntu-latest'
    steps:
      - uses: 'actions/checkout@v4'
        with:
          fetch-depth: 0
      - uses: 'moonrepo/setup-moon-action@v1'
      - run: 'moon ci :test'
```

## Configure partial toolchain versions

Since moon's inception, our [integrated toolchain](/docs/concepts/toolchain) required fully
qualified semantic versions (major.minor.patch) for tools. This was by design to ensure that we
could provide a consistent, reliable, and deterministic experience for all users. This solved the
problem of "Is X using the correct version of Y?".

However, this also meant that we were unable to support partial versions (major.minor) of tools,
which is a common use case and request for many users. Over the last few months, we've made immense
progress in [proto](/proto) on how it parses, resolves, and evaluates versions, known as the
[version specification](https://crates.io/crates/version_spec).

We felt the time was right to pull these changes into moon, and as such, all `version` fields in
[`.moon/toolchain.yml`](/docs/config/toolchain) now support partial versions, version
requirements/ranges, and even aliases!

```yaml title=".moon/toolchain.yml"
node:
  version: '20.7' # ~20.7
  npm:
    version: '^9'

rust:
  version: 'stable'
```

:::info

Learn more about how this works under the hood in the
[official version specification documentation](/docs/concepts/toolchain#version-specification).

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.14.0) for a full list
of changes.

- Added `packemon`, `sveltekit`, `vite`, `vitest` to
  [moonrepo/moon-configs](https://github.com/moonrepo/moon-configs).
- Updated `.moon/tasks` to support nested folders, for better organization of task files.
- Improved handling of certificates and proxies.
- Updated to proto v0.18.

---

## proto v0.19 - Version pinning and outdated checks

In this release, we're improving version pinning and introducing a new command to check for outdated
versions.

## New `proto pin` command (breaking)

Before our official v1 release, which is relatively soon, we'll be making some breaking changes with
the proto APIs. The first is the introduction of the new [`proto pin`](/docs/proto/commands/pin)
command, which replaces the previous `proto local` and `proto global` commands. We felt this was a
much cleaner change, and far easier to understand than the previous command names.

```shell
# v0.18
$ proto local go 1.20
$ proto global node 20

# v0.19+
$ proto pin go 1.20
$ proto pin node 20 --global
```

## New `pin-latest` setting

While we're on the subject of pinning versions, we've also introduced a new
[`pin-latest`](/docs/proto/config#pin-latest) setting. Do you want the latest version to always be
pinned? Do you forgot to pass `--pin` when installing? Do you forget to run the `proto global` or
`proto local` commands (now `proto pin`)? If you answered yes to any of these questions, then this
setting is for you.

When enabled, and a tool is installed with the "latest" version, the resolved version will
automatically be pinned to the configuration of your choice. For example, say we have the following
user config:

```toml title="~/.proto/config.toml"
pin-latest = "local"
```

And we run one of the following commands:

```shell
$ proto install go
$ proto install node latest
```

Then the resolved version of the tool will automatically be set to the `.prototools` file in the
current directory. Handy right?

## New `proto outdated` command

By request of the community, we're introducing yet another new command,
[`proto outdated`](/docs/proto/commands/outdated). If you're familiar with package managers, you can
probably guess what this command does! It'll check for newer available versions, for all tools
configured in the closest `.prototools` file. Very handy for keeping your tools up to date.

```
$ proto outdated

go - current version 1.20.2 (via ~1.20), newer version 1.20.8, update available!
node - current version 20.7.0 (via 20.7.0), latest version 20.8.0, update available!
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.19.0) for a full list
of changes.

- Added `PROTO_WASM_LOG` environment variable to toggle the logging of messages from Extism and WASM
  plugins. Useful for debugging.
- Updated `proto install` to auto-clean stale plugins after a successful installation.

---

## moon v1.15 - Next-generation action graph

In this release, we've taken the next step in modernizing our action pipeline, by rewriting the
dependency graph.

## Hello action graph, goodbye dependency graph

For the past few months, we've been working on a rewrite of our action pipeline, which consists of
the project graph, dependency graph, task executor, process pipeline, and more. It's a slow process,
with many different pieces that must land in sequence, but we're almost done. The next step in this
process is the [introduction of the new action graph](/docs/how-it-works/action-graph), which
replaces the previous dependency graph.

For the most part, the graphs work in a similar fashion, but since we rewrote it from the ground up,
we were able to resolve any discrepancies and performance issues. The biggest changes between the
new and old graphs are:

- All actions now depend on the `SyncWorkspace` action, instead of this action running arbitrarily.
- Cleaned up dependency chains between actions, greatly reducing the number of nodes in the graph.
- Renamed `RunTarget` to `RunTask`, including interactive and persistent variants.
- And lastly, we ditched our batched task approach for a ready queue. Continue reading for more
  information!

### A new performant thread pool

In the old dependency graph, when we'd execute a task, we'd order the graph topologically and then
group actions into batches (or buckets) based on their dependency chains. Batches would then be
executed in order within the thread pool. This approach worked well, but had one major flaw: it
wasn't as performant as could be. For example, if our thread pool size was 12, and a batch only had
2 tasks in it, what were the other 10 threads doing? Absolutely nothing. They were sitting idly,
waiting for a task.

And now with the new action graph, we take full advantage of all threads in the pool. Instead of the
batched approach above, we now use a topological task-ready queue, where a thread without work (or
is waiting for work) can poll the graph for a new task to run. A task is considered ready to run if
it either has no dependencies, or all of its dependencies (in the chain) have been ran.

For large graphs, this should result in a significant performance improvement!

### Automatic dependency linking (breaking)

> In v1.17, we changed the scope from "peer" to "build" to reduce friction.

Because of these graph changes, we do have a minor "breaking change". Tasks that depend (via `deps`)
on other tasks from arbitrary projects (the parent project doesn't implicitly or explicitly depend
on the other project), not including the root-level project, will now automatically mark that other
project as a "peer" dependency (if not already configured with `dependsOn`). For example, "b"
becomes a peer dependency for "a".

```yaml title="a/moon.yml"
tasks:
  build:
    deps: ['b:build']
```

Now internally becomes:

```yaml title="a/moon.yml"
dependsOn:
  - id: 'b'
    scope: 'peer'

tasks:
  build:
    deps: ['b:build']
```

If you'd prefer this dependency to _not be_ a peer, you can explicitly configure it with a different
scope. For Node.js projects, the "build" scope can be used as a no-op replacement.

```yaml title="a/moon.yml"
dependsOn:
  - id: 'b'
    scope: 'build' # production, development

tasks:
  build:
    deps: ['b:build']
```

We're marking this as a breaking change as this could subtly introduce cycles in the project graph
that weren't present before, and for Node.js projects, this may inject `peerDependencies`. However,
this change was necessary to ensure accurate dependency chains in the graph.

## New `moonrepo/setup-toolchain` GitHub action

We've begun a process to deprecate the
[moonrepo/setup-moon-action](https://github.com/moonrepo/setup-moon-action) and
[moonrepo/setup-proto](https://github.com/moonrepo/setup-proto) GitHub actions, and instead, combine
and replace them with a new [moonrepo/setup-toolchain](https://github.com/moonrepo/setup-toolchain)
action. Why a new action instead of fixing the others?

The biggest problem was that both previous actions shared about 90% of the same code, but were
slightly different in how they installed the binaries and cached the toolchain. It was was also
confusing for consumers to understand and know which action to use (because they shouldn't be used
together).

To remedy this, we're prototyping the new
[moonrepo/setup-toolchain](https://github.com/moonrepo/setup-toolchain) action, which has been
working quite well. It aims to solve the following:

- Installs `proto` globally so that installed tools can also be executed globally.
- Conditionally installs `moon` globally if the repository is using moon (attempts to detect a
  `.moon` directory).
- Caches the toolchain (`~/.proto`) so subsequent runs are faster.
- Hashes `.prototools` and `.moon/toolchain.yml` files to generate a unique cache key.
- Cleans the toolchain before caching to remove unused or stale tools.
- Can auto-install tools when used.

```diff
# ...
jobs:
  ci:
    name: CI
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
-      - uses: moonrepo/setup-moon-action@v1
+      - uses: moonrepo/setup-toolchain@v0
```

## Now supported in Railway

If you're a big fan of [Railway](https://railway.app/) (like we are), and you're deploying a Node.js
backed application, then you'll be happy to hear that Railway now officially and natively supports
moon! We spent some time over the past month
[integrating moon support into their Nixpacks architecture](https://nixpacks.com/docs/providers/node).

To make use of this, set the `NIXPACKS_MOON_APP_NAME` environment variable to the name of your moon
project that you want to be deployed. This will then automatically run `moon run :build` and
`moon run :start` respectively. To customize the task names, you can set the
`NIXPACKS_MOON_BUILD_TASK` and `NIXPACKS_MOON_START_TASK` environment variables.

:::info

This is currently only supported for Node.js projects, but will be expanded to other languages in
the future!

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.15.0) for a full list
of changes.

- Added a `moon action-graph` command.
- Added a `--dependents` argument to `moon action-graph`.
- Added the ability to skip non-`RunTask` actions using environment variables.
- Deprecated the `moon dep-graph` command.

---

## proto v0.20 - New shims and binaries management

In this release, we're reworking how shims and binaries work.

## Shims _and_ Binaries (breaking)

Since proto's inception, we've used shims as a way to execute installed tools. This allowed us to
wrap the underlying tool binary to provide additional functionality, such as automatic version
detection, runtime hooks, and more. However, this approach has some limitations, such as:

- Shims are forced onto you and there's no way to use proto without shims.
- Shims are slower than executing the native binary, upwards of 10x slower. While this equates in
  milliseconds, it can be noticeable dependending on the tool.
- For Windows, our shim files are `.cmd` _and not_ `.exe`. This causes a lot of weird and unexpected
  problems when an environment expects a real executable, or uses a hard-coded `.exe` extension.

To remedy this, we're introducing both a shim and non-shim approach, which has resulted in a pretty
big breaking change. Shims are now generated in `~/.proto/shims` (instead of `~/.proto/bin`), while
`~/.proto/bin` will now store symlinks to native binaries. To migrate to this new pattern, we're
introducing a new `proto migrate` command (this only needs to be ran once).

```shell
$ proto upgrade
$ proto migrate v0.20 --log debug
```

### How it works

When installing proto for the first time, or running the `proto migrate` command, we prepend `PATH`
with `$PROTO_HOME/shims:$PROTO_HOME/bin`. This allows shims to be executed _first_ and fallthrough
to native binaries if a shim does not exist (for example, `.exe` on Windows).

Furthermore, if you'd prefer to _only use_ shims, or _only use_ binaries, you can update `PATH` and
remove the unwanted directory path.

And lastly, if shims are causing problems, you can now easily reference the native binaries
directly. This was rather complicated before.

### Comparison

|                      | Shims                                              | Binaries                                                                |
| -------------------- | -------------------------------------------------- | ----------------------------------------------------------------------- |
| **Location**         | `~/.proto/shims`                                   | `~/.proto/bin`                                                          |
| **Created as**       | Scripts that run `proto run`                       | Symlinks to the native binary                                           |
| **Version executed** | Detects version at runtime                         | Last version that was installed + pinned                                |
| **Supported for**    | All tools                                          | Only tools that support native execution (may not work for `.js` files) |
| **Additional files** | Creates extra files (like `bunx`, `node-gyp`, etc) | Only links the primary binary                                           |

## Support for minisign checksums

When proto installs a tool, it runs a process known as checksum verification, where we ensure the
download hasn't been modified maliciously in anyway. Historically we only supported SHA256
checksums, but now, we also support the new [minisign](https://jedisct1.github.io/minisign/) tool,
used by popular tools like [Zig](https://ziglang.org/).

If you're building a plugin for a tool that uses minisign, you can use the new
[`checksum_public_key`](/docs/proto/wasm-plugin#downloading-pre-builts) (WASM) or
[`install.checksum-public-key`](/docs/proto/non-wasm-plugin#downloading-and-installing) (TOML) field
to provide the public key for use in verification.

When the checksum URL ends in a `.minisig` extension, proto will automatically use minisign for
checksum verification!

```toml
[install]
checksum-url = "https://domain.com/some/path/to/checksum.minisig"
checksum-public-key = "untrusted comment: ..."
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.20.0) for a full list
of changes.

- Updated `proto use` to install tools in parallel.
- Updated `proto plugins` and `proto tools` to load plugins in parallel.
- Updated `proto run` to error when the tool attempts to self-upgrade outside of proto.
- Rust plugin
  - Will now attempt to install `rustup` if it does not exist on the current machine.
  - Will now respect the `RUSTUP_HOME` environment variable when locating the `.rustup` store.
- Schema plugin
  - Added `install.checksum_public_key` for defining the public key used to verify checksums.
  - Added `metadata.self_upgrade_commands` for defining which sub-commands should be blocked for
    self-upgrades.

---

## proto v0.21 - Linux x64 musl support

This is a very small release that primarily adds support for the Linux x64 musl target.

Thanks to [cargo-dist](https://github.com/axodotdev/cargo-dist), we can now build and distribute
musl binaries with relative ease. When building the binary, libraries are statically linked to
ensure that the binary can run on any Linux distribution.

You can download the binary from the official
[GitHub release](https://github.com/moonrepo/proto/releases/tag/v0.21.0) or by running the
[Bash installation script](/docs/proto/install#linux-macos-wsl). In the future, we plan to support
arm64 builds for both Linux gnu and musl.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.21.0) for a full list
of changes.

- Improved file and directory locking. Will now work correctly across processes and signals,
  especially for those killed/dropped.
- Updated WASM functions to use explicit Rust enum types for versions to properly handle all
  variations (version, alias, requirement, range).

---

## moon v1.16 - Bun support, Rust improvements, and more!

With this release, we've focused on requests from the community, instead of internal migration work
or new features.

## Bun as a package manager

Now that [Bun v1 has officially released](https://bun.sh/blog/bun-v1.0) and our
[bun-plugin](https://github.com/moonrepo/bun-plugin) for proto has stabilized, we can start slowly
integrating Bun support into moon. The first step in this series is adding Bun as a supported
package manager for Node.js. Seems odd as they are conflicting runtimes... right? While true, a lot
of users are interested in using Bun purely as a package manager, as it can install dependencies
incredibly fast. So why not support it?

In this release, you can now install dependencies with Bun by configuring
[`node.packageManager`](/docs/config/toolchain#packagemanager) and
[`node.bun`](/docs/config/toolchain#npm-pnpm-yarn-bun) in your toolchain.

```yaml title=".moon/toolchain.yml"
node:
  packageManager: 'bun'
  bun:
    version: '1.0.0'
```

Additionally, you can now execute Bun commands within tasks! However, ensure the task's platform is
still set to `node` though, as this is using Bun as a package manager within Node.js, not as a
separate runtime.

```yaml title="moon.yml"
tasks:
  test:
    command: 'bun test'
    platform: 'node'
```

When using Bun, the following integrations are applied:

- Will automatically download and install Bun for the configured version.
- Will install dependencies using `bun install` (deduping currently not supported).
- Will parse `bun.lockb` for dependency resolution and task hashing.
- Will use `bunx` instead of `npx` for one-off package executions.
- Can execute `bun` commands within tasks.

> This change _only_ adds support for Bun as a package manager for Node.js. It does not add Bun as a
> supported language/platform in the toolchain, but it does pave the way for this to happen! Also
> note that Bun _is not supported on Windows_!

## Configure Rust components and targets

We've had Rust tier 2 and 3 support for quite a while now, but there was a big missing piece: the
ability to configure and install additional
[components](https://rust-lang.github.io/rustup/concepts/components.html) and
[targets](https://doc.rust-lang.org/nightly/rustc/platform-support.html) for the current toolchain.
In this release, we've added support for both!

Simply configure the [`rust.components`](/docs/config/toolchain#components) or
[`rust.targets`](/docs/config/toolchain#targets) settings in
[`.moon/toolchain.yml`](/docs/config/toolchain), and moon will automatically install them when the
pipeline is ran. This functionality uses the same hashing implementation as
[`rust.bins`](/docs/config/toolchain#bins-1), so will only install the first time, and again if the
configuration changes (or the cache is removed).

```yaml title=".moon/toolchain.yml"
rust:
  version: '1.73.0'
  components:
    - 'clippy'
    - 'rust-analyzer'
  targets:
    - 'wasm32-wasi'
```

## Force toolchain to use global binaries

Our [toolchain](/docs/concepts/toolchain) is great for local development, as it ensures all
developers and machines are running the exact versions of tools required for the workspace. However,
it becomes overkill for other environments like CI and Docker where the environment has been
pre-configured.

To avoid the unnecessary overhead of download and installing tools in the toolchain, we're
introducing the `MOON_TOOLCHAIN_FORCE_GLOBALS` environment variable. When provided, this will:

- Disable downloading and installing tools (will still download the WASM plugins).
- Execute all tool commands using the global binary available on `PATH`.

```shell
MOON_TOOLCHAIN_FORCE_GLOBALS=true moon ci
```

> We're looking into ways to automate this process, but for now, this is the best solution.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.16.0) for a full list
of changes.

- Added an improved task inheritance chain resolver. To fallback to the previous behavior, set
  `experiments.interweavedTaskInheritance: false` in `.moon/workspace.yml`.
- Added a new [project type `automation`](/docs/config/project#type), for projects like E2E and
  integration testing.
- Updated action graph cycle detection to list all nodes in the cycle (when detectable).
- Updated all npx calls to use a package manager equivalent. For example: `yarn dlx`, `pnpm dlx`,
  `bunx`.
- Updated to support Yarn v4.

---

## proto v0.23 - New detection strategy, tool commands, and more

With this release, we've reorganized our commands, improved version detection, and Windows support.

## New `detect-strategy` setting

Up until now, when proto would attempt to detect a version, it would use a version from the closest
`.prototools` file, or tool specific file (`package.json`, `.nvmrc`, etc), which ever matched first.
For the most part, this works great, but what if you wanted `.prototools` to take precedence over
other files, even if found in a higher parent directory? You unfortunately couldn't.

To support this new flow, we're introducing a new [`~/.proto/config.toml`](/docs/proto/config)
setting called [`detect-strategy`](/docs/proto/config#detect-strategy). This setting supports the
following values, with more possibly in the future!

- `first-available` (default) - Will use the first available version that is found. Either from
  `.prototools` or a tool specific file.
- `prefer-prototools` - Prefer a `.prototools` version, even if found in a parent directory. If none
  found, falls back to tool specific file.

```toml title="~/.proto/config.toml"
detect-strategy = "prefer-prototools"
```

## New `proto tool` command group (breaking)

Our CLI surface area has been growing and we felt it was time to start grouping commands, starting
with the new [`proto tool`](/docs/proto/commands/plugin) command. This command will contain "not
used very often" subcommands in relation to tools and their plugins, primarily for managing plugins,
and viewing tool information and inventory. As such, we've deprecated and moved the following
top-level commands:

- Moved `proto add-plugin` to `proto tool add`.
- Moved `proto remove-plugin` to `proto tool remove`.
- Moved `proto plugins` to `proto tool list-plugins`.
- Moved `proto tools` to `proto tool list`.

## New `proto tool info` command

Continuing with the changes above, we're also introducing a new command,
[`proto tool info`](/docs/proto/commands/plugin/info), which displays detailed information about a
tool and its backing plugin. For example:

```
$ proto tool info node

node - Node.js

Inventory
  Store: ~/.proto/tools/node
  Executable: ~/.proto/tools/node/20.0.0/bin/node
  Globals directory: ~/.proto/tools/node/globals/bin
  Binaries:
    - ~/.proto/bin/node (primary)
  Shims:
    - ~/.proto/shims/node (primary)

Plugin
  Version: 0.5.2
  Source: https://github.com/moonrepo/node-plugin/releases/download/v0.5.2/node_plugin.wasm
```

> This command also supports JSON output via `--json`.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.23.0) for a full list
of changes.

- Added support to plugins to ignore certain paths when detecting a version.
- Updated Windows to create 3 shim files for each tool: `.cmd` (cmd.exe), `.ps1` (powershell), and
  no extension (bash).

---

## moon v1.17 - Full Bun support, TypeScript improvements, and more!

In this release, we've focused heavily on the JavaScript and TypeScript ecosystems, by improving our
implementations, and providing full Bun support.

## Bun tier 1, 2, and 3 support

Yes you read that right! Not just 1 tier, not just 2 tiers, but all 3 language tiers have been
implemented for Bun, providing [full language support](/docs/how-it-works/languages), and parity
with Node.js. Thanks to the Bun work in [proto](/proto) and the previous
[v1.16 release](./moon-v1.16), we were able to add full Bun support with relative easy.

So what does Bun support look like? To start, you can now configure a
[`bun`](/docs/config/toolchain#bun) setting in [`.moon/toolchain.yml`](/docs/config/toolchain),
including an optional `version` to download and install, and settings similar to Node.js.

```yaml title=".moon/toolchain.yml"
bun:
  version: '1.0.13'
  syncProjectWorkspaceDependencies: true
```

This will enable the `bun` platform and the following integrations are applied:

- Will automatically download and install Bun for the configured version.
- Will install dependencies using `bun install` (deduping currently not supported).
- Will parse `bun.lockb` for dependency resolution and task hashing.
- Will use `bunx` instead of `npx` for one-off package executions.
- Can execute `bun` commands within tasks.

With the `bun` platform enabled, you can now configure the platform for projects and tasks (is
automatically detected when running the `bun` or `bunx` commands).

```yaml title="/moon.yml"
# Default platform for all tasks (optional)
platform: 'bun'

tasks:
  dev:
    command: 'bun run dev'
  test:
    command: 'bun test'
  lint:
    command: 'eslint .'
    # Only required for npm packages (if not defined above)
    platform: 'bun'
```

## TypeScript improvements

### Configure the root directory

When moon was first designed, it was designed for JavaScript based monorepos. Because of this, there
were a handful of assumptions that still exist today, one of which is that the moon workspace root
was assumed to be the JavaScript and TypeScript root. The root is extremely important in resolving
relative paths for project references and other path based functionality, so using the workspace
root made the most sense.

However, what if your TypeScript root isn't the workspace root? Or the TypeScript root and
JavaScript root are different? Well, you were out of luck... until now! We're introducing a new
setting called [`typescript.root`](/docs/config/toolchain#root), that denotes the root directory for
TypeScript related functionality (relative from moon's workspace root).

```yaml title=".moon/toolchain.yml"
typescript:
  root: './typescript'
```

### Include shared types

Another common TypeScript practice is to have shared `.d.ts` types that are used across multiple
projects, or to augment third-party types. This is so common that we felt obligated to support it in
some capacity within moon. With that said, we're introducing a new setting,
[`typescript.includeSharedTypes`](/docs/config/toolchain#includesharedtypes).

```yaml title=".moon/toolchain.yml"
typescript:
  includeSharedTypes: true
```

When enabled, we'll automatically sync the shared types path to the `include` field of all relevant
project `tsconfig.json`s. However, for this to work correctly, the shared types _must_ exist in a
`types` folder relative from the [TypeScript root](#configure-the-root-directory).

For example, if the TypeScript root is `/`, and shared types is `/types`, then all packages in
`/packages/*` will be updated with the following:

```json title="packages/example/tsconfig.json"
{
  "include": ["../../types/**/*"]
}
```

> This setting can be overridden on a per-project basis.

### Include sources of project references

Continuing with `include` related functionality, we've introducing yet another new setting,
[`typescript.includeProjectReferenceSources`](/docs/config/toolchain#includeprojectreferencesources),
which does exactly as its name implies. It automatically appends the sources (`**/*`) of all project
references to the `include` field of all relevant project `tsconfig.json`s.

This is useful (and sometimes required) for the following reasons:

- It makes files within a referenced project available for import into the consuming project. This
  is required for "press tab to auto-import" nested/deep files, otherwise only index imports will
  work (and barrel files are costly).
- It also improves the editor experience by making the source files available for intellisense,
  autocomplete, and other features.

```yaml title=".moon/toolchain.yml"
typescript:
  includeProjectReferenceSources: true
```

To understand this functionality, say you have a project with the following `tsconfig.json`, and
this project depends on 2 other projects: ui and utils.

```json title="packages/example/tsconfig.json"
{
  "compilerOptions": {},
  "include": ["src/**/*"]
}
```

When our syncing process occurs, we'll automatically sync project references, and include referenced
sources, like so.

```json title="packages/example/tsconfig.json"
{
  "compilerOptions": {},
  "include": ["src/**/*", "../ui/**/*", "../utils/**/*"],
  "references": [{ "path": "../ui" }, { "path": "../utils" }]
}
```

> This setting can also be overridden on a per-project basis.

## JavaScript improvements

### Supporting the "single version policy" pattern

If you're unfamiliar with the single version policy, or the one version rule, it's a pattern that
only allows dependencies to be configured in a single location, typically the root `package.json`.
This pattern forces _all_ projects in a monorepo to use the same dependencies, and avoid the package
`workspaces` functionality.

This pattern was previously not possible in moon, as our automatic dependency installation process
did not account for it, and it would either install in the root if using `workspaces`, or in a
project otherwise. To support this pattern, we're introducing the new setting
[`node.rootPackageOnly`](/docs/config/toolchain#rootpackageonly) for Node.js, and
`bun.rootPackageOnly` for Bun.

```yaml title=".moon/toolchain.yml"
node:
  rootPackageOnly: true
```

When enabled, we'll only install dependencies in the workspace root, regardless of other settings or
how `package.json`s are configured. However, this setting _does not_ verify that other
`package.json`s _do not_ have dependencies. It's up to you to ensure that other `package.json`s do
not have dependencies.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.17.0) for a full list
of changes.

- Updated automatic dependency linking to use the `build` scope instead of `peer` scope. This should
  alleviate some of the pain points with `package.json` syncing.
- Improved project reference syncing and edge case handling.

---

## proto v0.24 - Standardized configuration and 10x WASM boost

In this release, we've standardized our configuration from the ground-up.

## Improved WASM performance up to 20x

Before we dive into the major changes of this release, we want to highlight the performance
improvements that have landed recently. Thanks to [Dylibso](https://dylibso.com/) and the
[Extism](https://extism.org/) team, we've been able to improve the performance of our WASM plugins
by 10-20x! This was achieved by plugging into wasmtime's ahead-of-time (AOT) compiler and caching
layer.

Here's an example of the performance improvements when running `node --version`. On older versions,
the execution time was anywhere from 100ms-200ms, but is now down to 10-20ms! This is almost as fast
as native's 5-10ms!

```shell
# proto v0.23.5 and below
hyperfine --warmup 10 -- 'node --version'
Benchmark 1: node --version
  Time (mean ± σ):      99.2 ms ±   6.3 ms    [User: 662.5 ms, System: 79.4 ms]
  Range (min … max):    91.3 ms … 119.7 ms    29 runs

# proto v0.23.6 and above
hyperfine --warmup 10 -- 'node --version'
Benchmark 1: node --version
  Time (mean ± σ):      18.5 ms ±   1.0 ms    [User: 7.9 ms, System: 12.7 ms]
  Range (min … max):    17.1 ms …  23.8 ms    146 runs
```

:::success

Dylibso is hosting an [Extism hackathon](https://dylibso.com/events/2023/hack-for-good/) through the
month of December, that'll donate to children in need. Check it out and participate!

:::

## Standardized configuration (breaking)

Up until now, proto has supported 2 types of configuration, `.prototools` and
`~/.proto/config.toml`. The former can exist in any folder, and is used for pinning versions and
defining plugins. The latter is a per-user file that is used for customizing how proto works and
also defining plugins.

Over time, functionality in both of these files has grown, and so has the overlap between them. We
felt it was time to standardize these files into a single configuration file, and as such, have
removed `~/.proto/config.toml` and merged its functionality into
[`.prototools`](/docs/proto/config). The biggest changes are:

- proto settings (like `auto-clean` and `http`) must now exist within a
  [`[settings]` table](/docs/proto/config#settings).
- Tool specific settings (like `node-intercept-globals`) have moved to the new
  [`[tools.node]` table](/docs/proto/config#tools) ([more info below](#tool-level-settings)).
- Plugins are still configured within a [`[plugins]` table](/docs/proto/config#plugins).
- Global/default settings can be defined in `~/.proto/.prototools`.

```toml title=".prototools"
node = "20.0.0"

[settings]
auto-clean = true

[settings.http]
allow-invalid-certs = true
```

The other massive benefit of this change, is that settings _can now be defined anywhere_!
Previously, settings like `auto-clean` or `detect-strategy` could only be defined at the user-level,
but what if your company or team wanted to control this setting? It wasn't possible without asking
all team members to update their configuration manually. With this change, settings can now be tied
to projects or repositories!

:::info

After upgrading, run `proto migrate v0.24` to migrate the old user configuration to the new format!

:::

### Tool-level settings

While working on these configuration changes, we also landed the
[Tool-level configuration RFC](https://github.com/moonrepo/proto/issues/261), although with a
different implementation. This enables users to define settings that will be passed to the WASM
plugin of a specific tool, controlling how it works. These settings can be configured with the new
[`[tools.]` table](/docs/proto/config#tools).

For example, the `node` tool has a setting called `intercept-globals`, which will trigger an error
when npm/pnpm/yarn attempt to install a global package.

```toml title=".prototools"
[tools.go]
gobin = false

[tools.node]
intercept-globals = false
```

As of now, only the [Node.js](https://github.com/moonrepo/node-plugin) and
[Go](https://github.com/moonrepo/go-plugin) plugins support settings.

## Moved aliases and default versions (breaking)

To continue with these configuration changes, we've also moved aliases and the default version into
this new configuration. Previously, both of these values were stored in
`~/.proto/tools//manifest.json`, but the problem was, that this file is internally managed by
proto, and should not be modified by users. This made it difficult for users to manage, and to
persist these values across machines (think dotfile syncing).

Now these values are stored in [`.prototools`](/docs/proto/config), with aliases being configured in
[`[tools..aliases]`](/docs/proto/config#toolsaliases), and the default version (global) being
pinned as a version in `~/.proto/.prototools`. Here's an example:

```toml title="~/.proto/.prototools"
node = "20.0.0"

[tools.node.aliases]
work = "18"
```

This change also enables aliases to be defined anywhere! Previously, aliases were only allowed to be
defined globally for a user, but now they can be defined per-project, or even per-directory.

:::info

After upgrading, run `proto migrate v0.24` to migrate your aliases and default versions to the new
configuration format!

:::

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.24.0) for a full list
of changes.

- proto now supports [canary](/docs/proto/install#canary-releases) and
  [nightly](/docs/proto/install#nightly-releases) releases.
- Updated non-latest plugins to be cached for 30 days, instead of forever.
- Fixed an issue where resolving canary versions wouldn't work correctly.

---

## proto v0.25 - Linux arm64 gnu and musl support

This is a very small release that primarily adds support for Linux arm64 targets.

Thanks to [cargo-dist](https://github.com/axodotdev/cargo-dist), we can now build and distribute
arm64 binaries with relative ease. When building the binary, libraries are statically linked to
ensure that the binary can run on any Linux distribution.

You can download the binary from the official
[GitHub release](https://github.com/moonrepo/proto/releases/tag/v0.21.0) or by running the
[Bash installation script](/docs/proto/install#linux-macos-wsl).

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.25.0) for a full list
of changes.

- Added a [`proto debug config`](/docs/proto/commands/debug/config) command, to debug all loaded
  configs and the final merged config.
- Added a `PROTO_BYPASS_VERSION_CHECK` environment variable, to bypass loading and checking of
  versions.

---

## moon v1.18 - New task execution flow and custom project names

With this release, we've focused heavily on 2 important aspects: task execution, and our onboarding
flow.

## New path based task execution

Since moon's inception, before we would execute a task's command, we would locate its executable on
the file system and execute it directly. We went with this approach as we wanted to avoid all of the
baggage and "unknown behavior" that came with executing through a shell, and to ensure a more
deterministic outcome. This approach worked very well for stand-alone binaries, like `node`,
`cargo`, and built-in commands like `rm`, `mkdir`, and `git`.

However, it was very problematic in 2 scenarios: executables from language dependencies (Node.js
modules, etc), and multi-command based tasks (using `&&`). To remedy this situation, we're no longer
locating the executables ourselves, and instead are prepending `PATH` with the locations in which we
know these executables should exist. We're also loosening the restriction on the
[`shell` task option](/docs/config/project#shell), which can now be enabled for _all_ tasks, not
just system tasks.

### Dependency executables

For the 1st scenario, let's talk about Node.js modules. When we encountered an unknown task command,
like `eslint` or `prettier`, we'd attempt to locate its executable by traversing `node_modules/.bin`
directories, parsing Bash/PowerShell scripts, resolving the source `.js` files, and finally
executing with `node`. To demonstrate this, say you had the following task:

```yaml title="moon.yml"
tasks:
  format:
    command: 'prettier --write .'
```

When finally executed, internally it would become something like this command:

```shell
~/.proto/tools/node//bin/node ../../node_modules/prettier/internal/cli.mjs --write .
```

This was required since our runtime is Rust and we don't have access to Node.js's module resolution
algorithm... but this approach was very brittle and error prone. It took us many releases to iron
out all the bugs, and we're pretty sure there are still edge cases unaccounted for. So instead, as
mentioned above, we now prepend `PATH`, resulting in the following command:

```shell
PATH="/path/to/node_modules/.bin:/path/to/proto/tools:$PATH" prettier --write .
```

This is a much cleaner approach and is far easier to understand as a user.

### Multi-command tasks

While not officially supported in moon, it's been possible to run multiple commands in a single task
using `&&` syntax. However, this approach did not work correctly with our integrated toolchain, as
only the 1st command in the list would have its binary be located and executed correctly.

For example, say we wanted to run 2 npm packages, the following would _not_ work:

```yaml title="moon.yml"
tasks:
  build:
    command: 'rm -rf dist && vite build && tsc --build'
```

With this new `PATH` based approach, this will now work correctly. And furthermore, this also
enables executables within Bash and PowerShell scripts to be located and executed correctly as well.

### What's next?

In the future, we'll continue to expand on this functionality, and our ultimate goal is to remove
the concept of `platform` from tasks, which has been a bit confusing for new users.

## Customize the project name in `moon.yml`

This has been a long requested feature, but thanks to the project graph rework and improvements over
the last few releases, this is now possible. In [`moon.yml`](/docs/config/project), you can now
configure the [`id`](/docs/config/project#id) setting to override the project name (identifier)
derived from [`projects`](/docs/config/workspace#projects) in
[`.moon/workspace.yml`](/docs/config/workspace) (most applicable to glob based project locations).

For example, say we have the following `projects` glob.

```yaml title=".moon/workspace.yml"
projects:
  - 'apps/*'
  - 'packages/*'
```

By default, the project folder name becomes the project name. For the most part this is fine, but
what if you have a very large monorepo? Or have conflicting project names? Or are migrating
projects? It becomes difficult to manage and organize. But now, simply configure `id`!

```yaml title="/moon.yml"
id: 'custom-project-name'
```

:::info

Be sure that all targets, project dependencies, task dependencies, and other references are using
the new identifier, otherwise an error will be triggered!

:::

## Improved onboarding flow

While this doesn't affect current users, we still want to announce that we've made some slight
changes to our onboarding process and the [`moon init`](/docs/commands/init) command. The previous
command prompted far too many questions, as we would attempt to detect what languages are currently
in use, and integrate them into the toolchain.

This was confusing for new users, so starting with this release, we've simplified the process to
only create the moon workspace within a repository.

```shell
moon init
```

With that being said, you can still integrate tools into the toolchain, by passing the identifier of
a supported moon tool as an argument.

```shell
moon init node # bun, rust, etc
```

:::success

We've also rewritten a good portion of the "[Getting started](/docs/setup-workspace)" documentation
to reflect these changes!

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.18.0) for a full list
of changes.

- Improved string allocation and performance for queries, task tokens, and process commands.
- Improved remote caching flow and handling.
- Updated proto to v0.25.

---

## proto v0.26 (rc) - Release candidate available for testing!

We've got a very special release candidate that we'd love to stress test before an official release!

proto at its core is a version manager, which means like most version managers, it relies on a
concept known as shims. Shims are lightweight executable scripts that act like a proxy to the
underlying binary, and are useful for proto to intercept executions and inject custom functionality,
like our dynamic version detection.

On Unix machines, we relied on Bash scripts for shims, which worked rather well. However, on
Windows, we relied on PowerShell scripts (`.ps1`), batch/cmd scripts (`.cmd`), and Bash scripts, all
with differing levels of functionality, and each serving a separate purpose. Windows support _did
not_ work well.

## What didn't work?

When using shims, you must ensure that all the following scenarios work well: piping data/commands,
redirection, stdin prompts, interactivity, signal handling, exit code bubbling, so on and so forth.
Bash solves a lot of this for us, but Windows does not have a native Bash shell, and thus we had to
rely on other scripting languages. The `.cmd` files barely supported any of this, and the `.ps1`
files were a bit better, but still not great.

For the most part, executing a shim as-is and doing basic work was fine, but once you needed a
complex scenario (like above), it broke down pretty quickly. It was also further exacerbated when
dealing with nested shim executions, for example, `npm` calls `node` under the hood. The parent shim
may be executed with `.ps1` but the child may be `.cmd`, and these do not play well together.

The other problem on Windows is that scripts are not true executables, and are not easily located on
`PATH` (excluding `.cmd` files).

## What's new?

To combat all of these problems, we needed a truly native solution, and that's exactly what we did.
We wrote our own Rust based executable, that will replace all of the custom shim scripts, and can
properly handle all of the required scenarios. This new executable is named `proto-shim`
(`proto-shim.exe` on Windows) and is published alongside the `proto` binary.

This new executable solves all of the following problems (hopefully):

- Locatable on `PATH` (is an `.exe` for Windows)
- Can pipe/redirect data
- Handles stdin prompts/interactivity
- Supports ctrl+c interruptions
- Passes parent signals to child processes
- Attempts to kill child processes on parent exit
- Bubbles exit codes
- Native performance
- Doesn't require special privileges (no symlinks)

## How to test?

If you're interested in testing this new implementation (we'd appreciate it), you can do so by
downloading the latest release candidate from GitHub: https://github.com/moonrepo/proto/releases

Once downloaded, unpack the archive, and move the `proto` and `proto-shim` binaries to the
`~/.proto/bin` directory (or the location of your `PROTO_INSTALL_DIR` environment variable). From
here, you can execute `proto` or your tool binaries as normal.

:::warning

If you run into issues, try deleting the old `~/.proto/shims` directory and trying again. If
problems still persist, please report an issue or reach out to us on Discord!

:::

:::info

On macOS, you may need to add the binary to the trusted list, in your Priacy & Security settings.
This can also be achieved on the command line with `xattr -c ~/.proto/bin/*`.

:::

## What to test?

Basically everything. We want to ensure that all of the functionality in [What's new?](#whats-new)
works as expected, so simply go about your day to day development and let us know if you run into
any issues!

---

## proto v0.26 - New native shim implementation

After many release candidates, and a ton of testing, proto v0.26 is finally here!

## Rethinking shims

proto at its core is a version manager, which means like most version managers, it relies on a
concept known as shims. Shims are lightweight executable scripts that act like a proxy to the
underlying binary, and are useful for proto to intercept executions and inject custom functionality,
like our dynamic version detection.

On Unix machines, we relied on Bash scripts for shims, which worked rather well. However, on
Windows, we relied on PowerShell scripts (`.ps1`), batch/cmd scripts (`.cmd`), and Bash scripts, all
with differing levels of functionality, and each serving a separate purpose. Windows support _did
not_ work well.

To avoid current and future compatibility issues, we needed a truly native solution, and that's
exactly what we did. In this release, we wrote our own Rust based executable, that will replace all
of the custom shim scripts. This new executable is named `proto-shim` (`proto-shim.exe` on Windows)
and is published alongside the `proto` binary.

This new executable solves all of the following problems (hopefully):

- Locatable on `PATH` (is an `.exe` for Windows)
- Can pipe/redirect data
- Handles stdin prompts/interactivity
- Supports ctrl+c interruptions
- Passes parent signals to child processes (uses `execvp` on Unix)
- Attempts to kill child processes on parent exit
- Bubbles exit codes
- Native performance
- Doesn't require special privileges (no symlinks)

## Upgrade troubleshooting

Because this release adds a new executable (`proto-shim`), you'll most likely run into issues when
upgrading via `proto upgrade`. The root issue is that the upgrade process was only aware of the
single `proto` file, and not the new `proto-shim` file, so it will not copy the shim into the
correct location, and subsequent proto commands will fail.

We could backport this change to v0.25, but it would require all users to upgrade to that patch
version first before upgrading to v0.26. But this still wouldn't solve the issue for users upgrading
from v0.24, or an even earlier version.

The best way to remedy this situation is to simply
[re-install proto as a whole](/docs/proto/install). Once you're on v0.26, this will be a non-issue.

```shell
# Unix
curl -fsSL https://moonrepo.dev/install/proto.sh | bash

# Windows
irm https://moonrepo.dev/install/proto.ps1 | iex
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.26.0) for a full list
of changes.

- Added basic telemetry to track tool install/uninstall metrics.
- Fixed an issue where binaries were being symlinked with broken versions in their file name (most
  commonly for Python).

---

## moon v1.19 - Improvements to task dependencies, codegen, and more

In this release, we're introducing some long-awaited and requested improvements.

## Configure args and env vars for task dependencies

This has been a long standing request from the community, and we're happy to finally deliver it.
Starting with v1.19, you can now configure optional command line arguments and environment variables
for each task [`deps`](/docs/config/project#deps) entry. These values will be passed to the task
when it is executed.

Here's an example of what both patterns look like. The `target` field is required when configuring
an object, and both the `args` and `env` fields can be mixed and matched.

```yaml title="moon.yml"
tasks:
  build:
    command: 'vite build'
    deps:
      # Just a target
      - '^:build'

      # With args (string)
      - target: '^:build'
        args: '--mode production'

      # With env vars
      - target: '^:build'
        env:
          NODE_ENV: 'production'

      # With args (array) and env vars
      - target: '^:build'
        args:
          - '--mode'
          - 'production'
        env:
          NODE_ENV: 'production'
```

When using this functionality, there are a few things to understand about its implementation, and
how it affects the rest of the pipeline:

- When extending or inheriting a task and a merger is required, and this task has a dependency with
  a colliding target, the `args` and `env` fields will _NOT_ be deeply merged. Whichever task is
  inherited last will have its `deps` used.
- When multiple dependencies of the same target are ran in the action pipeline, but with differing
  args or env vars, only 1 will run at a time. We try to avoid running them in parallel to avoid
  collisions and corrupting outputs.
- Arguments and environment variables do _NOT_ support tokens.
- If dependencies all write to the same output, cleaning the output is your responsibility, not
  moon's.

## Codegen improvements

Code generation is one of moon's oldest features, and hasn't been improved in quite a while. We felt
the time was right to give it a little love.

### Extend other templates

This has been a [request for over a year](https://github.com/moonrepo/moon/issues/434), and we
finally found the time to put it on the roadmap. Starting with this release, you can now extend
other templates using the [`extends`](/docs/config/template#extends) setting in
[`template.yml`](/docs/config/template), which supports a list of template names.

Templates will be recursively extended from top to bottom, and all files and variables will be
inherited and merged at the top-level.

```yaml title="template.yml"
title: 'npm package'
extends: ['node-common']
```

### Configure a default destination

When you call [`moon generate`](/docs/commands/generate) you must provide a destination directory
for the generated files, or we'll prompt you to provide one. But what if you wanted to standardize
the destination? For example, a package scaffolding template should go to `packages/`. This is now
possible with the optional [`destination`](/docs/config/template#destination) setting in
[`template.yml`](/docs/config/template).

If no destination is provided to `moon generate`, we'll use this default destination.

```yaml title="template.yml"
title: 'npm package'
destination: 'packages/[name | kebab_case]'
variables:
  name:
    type: 'string'
    default: ''
    required: true
    prompt: 'Package name?'
```

:::info

For better interoperability, this setting can also reference variables using `[var]` syntax, and can
also use Tera filters. Learn more about this in the
[code generation documentation](/docs/guides/codegen#interpolation).

:::

## Resolved long-standing experiments

moon has a concept of [experiments](/docs/config/workspace#experiments), where certain features are
gated behind a flag. This allows us to support new and old functionality in parallel, and also allow
users to gradually upgrade when encountering a breaking change. For many months now, we've had 2
experiments running, and have decided on a path forward.

The first is `experiments.interweavedTaskInheritance`, which would inherit global and local tasks in
order, interweaved within each other. The old implementation would inherit global first, then local
second, distinctly grouping them. Since this experiment was introduced, we have not received a
single bug report or issue. This is a good sign that the new behavior is working as expected, and as
such, have decided _to move forward_ with this experiment and make it the new implementation. The
old implementation has been removed entirely.

The second is `experiments.taskOutputBoundaries`, which was rather controversial when introduced.
This experiment would trigger an error anytime a [task's `outputs`][outputs] overlapped within
another [task's `outputs`][outputs]. The reason for this change, is that multiple tasks writing to
the same output location could "corrupt" the expected state, and trigger unexpected results when
hydrating from the cache. However in practice, this restriction has caused more headache and
introduced a steeper learning curve then expected. It also caused problems with
[tasks that extend](/docs/config/project#extends) from another, resulting in the same outputs being
used. Because of this, we've decided _to **not** move forward_ with this experiment, and allow
whatever task outputs you wish (we trust you're smart enough to not shoot yourself in the foot).

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.19.0) for a full list
of changes.

- Updated proto to v0.26 (from v0.25), which includes a new shims implementation.
- Updated VS Code extension to support multiple VS Code workspace folders.

[outputs]: /docs/config/project#outputs

---

## proto v0.27 - PowerShell profiles, shim regeneration, and more

This is a small release that improves the overall developer experience.

## PowerShell profile support

When proto was first launched, we didn't support PowerShell profiles, but did support Windows by
running `setx` commands to inject the `PROTO_HOME` environment variable, and update `PATH`. While
this worked, it was not ideal, and unexpected for users. This is our fault and our lack of Windows
knowledge.

Starting with v0.27, we now official support PowerShell profiles, and will no longer call `setx`.
Instead we write the environment variable changes to one of these files, depending on what exists:

- Windows
  - `~\Documents\PowerShell\Microsoft.PowerShell_profile.ps1`
  - `~\Documents\PowerShell\Profile.ps1`
- Unix
  - `~/.config/powershell/Microsoft.PowerShell_profile.ps1`
  - `~/.config/powershell/profile.ps1`

## Regenerate shims & bins

proto has gone through some growing pains, we won't deny that. With the handful of breaking changes,
the configuration refactor, and the ground-up rework of how shims/bins are handled, we've hit a few
snags. Most of those snags have been around tool execution.

To remedy some of these problems, we're introducing the [`proto regen`](/docs/proto/commands/regen)
command. This command will clean the shims (`~/.proto/shims`) and optionally bins (`~/.proto/bins`)
directory, regenerate shims, and relink bins based on globally pinned versions.

```shell
$ proto regen

# Include bins
$ proto regen --bin
```

This is extremely useful in resetting to a clean state.

## Better version parsing for TOML plugins

When our [TOML plugin](/docs/proto/non-wasm-plugin) receives a version, we attempt to parse it into
a valid semantic version. However, not all tools follow semver, as they may release without patch or
minor versions, or use a different pre/build pattern.

To remedy this, we've updated our regex to be more flexible, and to utilize named capture groups.
With named groups, we can now piece the version together, fill in missing values, and then parse it.

We've also renamed the field to `version-pattern` from `git-tag-pattern`, as the regex is now also
used for manifest parsing. The old name is still supported for the time being.

```toml
# Before
[resolve]
git-tag-pattern = "^@protostar/cli@((\\d+)\\.(\\d+)\\.(\\d+))"

# After
[resolve]
version-pattern = "^@protostar/cli@((?\\d+)\\.(?\\d+)\\.(?\\d+))"
```

> Jump to the [official documentation](/docs/proto/non-wasm-plugin#version-patterns) for more
> information!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.27.0) for a full list
of changes.

---

## What's in store for 2024

Happy new year! Let's start 2024 by reflecting on last year and diving into our tentative year long
roadmap.

## Year 2023 in review

Last year was an extremely exciting year for us! To start, we were accepted into the
[Y Combinator 2023 winter batch](https://www.ycombinator.com/companies/moonrepo), which was
extremely unexpected, but very much welcome. The 3 months we spent in YC was quite eye opening, as
we learned so much about the industry, and how to move forward. We spent those 3 months really
diving into what we want to build and deliver, and after much trial and error, and many failed
prototypes, we chose to move forward with launching [proto][proto] as its own tool, improving
[moon][moon], and slowing down development of [moonbase][moonbase] (outside of remote caching).

### moon

For [moon][moon], we officially launched v1 back in March, and celebrated its 2 year birthday in
October. Over the course of 2023, we released 23 minor versions, jam packed with new features such
as:

- Action and project graphs improvements
- Bun tier 1, 2, and 3 support
- Canary & nightly releases
- Code ownership (`CODEOWNERS`)
- Configuration rewrite (using our [schematic](https://github.com/moonrepo/schematic) crate)
- Deno tier 1 and 2 support
- Developer experience improvements
- Documentation polish
- Experiments
- Interactive & persistent tasks
- JavaScript and TypeScript improvements
- Onboarding flow improvements
- `PATH` based task execution
- [proto][proto] integration
- Query language
- [Railway](https://railway.app/) support
- Rust tier 1, 2, and 3 support
- Tagging and boundaries/contraints
- Task extending, inheritance, and configuration enhancements
- Task dependencies configurations
- Toolchain enhancements
- VCS (Git) hooks
- ... and much much more!

However, when looking at our [2023 roadmap](./2023-roadmap), there are a few items we failed to
deliver on. The biggest are additional languages, better tier support, and release workflows. We
ultimately didn't land these features as we plan to move to a plugin based architecture, and didn't
want to invest too much time into the current implementation.

### moonbase

During YC, we officially launched [moonbase][moonbase], our cloud service that offers remote caching
to all moon users (and also includes a free tier). Over the next few months, we continued to improve
the service, by adding basic insights into CI runs (powered by [`moon ci`](/docs/commands/ci)), and
overall stability.

However, we unfortunately made the decision to pause development of new features for moonbase, as we
were unsure of the value that they would provide to end-users compared to the cost it would take to
build & maintain. Some such features include code and project ownership, project registry, and
repository health scores. We may revisit this in the future.

### proto

As for [proto][proto], it's been an exciting year. For context, proto's implementation was
originally built into moon directly, and powered
[moon's integrated toolchain](/docs/concepts/toolchain). We strongly felt this functionality can be
useful as a stand-alone tool, as tool installation and developer environment setup is still a major
pain point for developers.

So we decided to extract it out into its own tool, and thus proto was born. Since then, we've
released 27 minor versions with:

- Additional language support: Go, Python
- Binary symlinking
- Canary & nightly releases
- Detection improvements
- Directory-level configuration
- Deeper shell integration
- Global packages support
- Native shim executables
- Runtime version detection
- WASM and TOML based plugins
- ... and more to come!

## Launching moon v2

It's been almost a year since we launched v1, and we believe we're ready to start planning out and
working on v2. Our goal for major releases is to introduce breaking changes in the most seamless way
possible, and to do so, we plan to incrementally land internal changes in v1 in preparation for v2,
provide codemods for migrating configuration, and of course, provide an in-depth migration guide.

In order of importance, we plan to land the following changes. This list does not include features
that will [land after v2](#post-launch-features).

- Move to a [plugin based architecture](#plugin-based-architecture)
- Rename and standardize some configuration settings
- Removed deprecated features

It's a short list but also a ton of work. We have no ETA on when this will land exactly.

### Plugin based architecture

The biggest change and primary focus for v2 is to move to a WASM plugin based architecture (for
language integration). Based on our work with [proto's plugins](/docs/proto/plugins), we have a very
good idea of how we would model this for moon, and a new love for WASM based plugins (powered by
[Extism](https://extism.org/)).

One of the leading factors for this decision, is that building everything into Rust directly is not
scalable, is a maintenance headache, and is also extremely difficult. It results in a lot of
duplicated code, increased compilation times, and a lot of complexity. By moving to plugins, we can
ditch most of this, and in the grand scheme of things, plugin integration is simply function calls.

Of course there are a handful of additional benefits that come from plugins:

- Enables the community to build and share their own plugins (additional languages).
- Plugins can be individually updated, versioned, and released. Less moon patches.
- Reduces moon's compilation times, as plugins live in their own repositories.
- Easier to contribute to, as moon's codebase is quite complex.

### Post-launch features

Curious what kind of features we have planned for after v2? Of course you are! This isn't an
exhaustive or detailed list, but is top of mind:

- Additional languages support (will be much easier with a plugin system)
- Release workflows (versioning, publishing, changelogs, etc)
- System dependencies within the toolchain
- Language dependency management tools
- Repository and project health scores
- Improved action graph and pipeline

## Launching proto v1

We're extremely close to a v1 release, most definitely in Q1. For the most part, we believe we're
passed the point of introducing breaking changes, and so the remainder of the time will be spent on
polish, improvements, and documentation. There are a few big features we want to land relatively
soon though (but maybe after v1), and they are:

- Build from source for languages (this is quite complicated)
- Build/extension variants for languages (PyPy for Python, PHP extensions, etc)
- Directory and tool level environment variables (think [direnv](https://direnv.net/) kind of
  functionality)

### Expanding language support

While not part of v1, we definitely want to support more official languages in proto. We've been
pushing back on new languages until after v1 and the plugin APIs have stabilized, but since that's
relatively close to being done, expect more in the future! Our top of mind languages at the moment
are: Ruby (and Crystal), PHP, and Java.

Don't forget that the community can also build and share their own plugins! For example, the
[Zig programming language](https://github.com/konomae/zig-plugin) already exists, and is provided by
[konomae](https://github.com/konomae)! Thanks for the amazing work.

## Self-hosting moonbase

And last but not least, let's talk about moonbase. Although we've paused development on new
features, we consistently get requests for self-hosting moonbase (primarily for remote caching), as
companies don't want to store their proprietary builds, even though they are compiled and minified,
in a cloud storage provider that they do not own.

We definitely understand this concern, and that's why we've been working on a self-hosted version of
moonbase (also known as on-premises). We've never done this before, so it's been quite a learning
lesson, especially since we have many facets to take into account: database access, cloud
credentials, error handling, auth, so on and so forth.

We'd say we're about 50% done with this effort, and we aim to have it ready by the end of Q1. With
that said, the self-hosted version of moonbase will _not_ be free, and will use a license based
model. We're still working out the details, but we'll have more information soon.

## Looking for contributors

Thanks for reading this far, but we do have one last thing to talk about. The moonrepo ecosystem and
all its products are quite large, with a lot of complexity. However, we're a small team, with most
of the public-facing work being done by me (Miles), but there's only so much we can do in a given
timeframe. With that said, we're looking for open source contributors that would like to help us
out! We have a long list of features and enhancements that need to be done, and even some secret
projects that would be very cool to work on. If you're interested, please reach out to us on
Discord!

[moon]: /moon
[moonbase]: /moonbase
[proto]: /proto

---

## proto v0.28 - Upgraded WASM runtime

This is a small release that primarily upgrades our WASM runtime.

## Upgraded WASM runtime

proto utilizes [Extism](https://extism.org/) for our WASM plugin architecture, which internally uses
[wasmtime](https://wasmtime.dev/) as our execution runtime. Up until this point, we've been using a
beta release of Extism, v0.5, which has worked quite nicely. We've also been working closely with
the Extism team to report bugs, provide feedback, and help improve the project. Once such feature
was the massive performance gains in [proto v0.24](./proto-v0.24).

Thanks to all the hard work from the Extism team over the past year, an official v1.0 was released.
Because this was a major release, it did include breaking changes around the WASM runtime, and as
such, proto WASM plugins before v0.28 are _no longer compatible_, and will need to be recompiled
with the latest PDKs. Our proto TOML plugins are not affected.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.28.0) for a full list
of changes.

- Will now display an upgrade message when the current proto version is out of date.
- Improved error messages to include plugin specific information.
- Updated our "last used at" logic to avoid race conditions with the tool manifest.

---

## proto v0.29 - Better environment support

In this release, we focused heavily on environment interoperability.

## New environment aware configuration

We've made a small but useful improvement to `.prototools`, environment aware files! When the
`PROTO_ENV` environment variable is set, proto will look for an additional `.prototools.{env}` file
and merge it with the base configuration.

This is useful for certain deploy scenarios where you need different versions of tools, environment
variables, or settings!

```toml title=".prototools"
node = "21.0.0"
```

```toml title=".prototools.production"
node = "20.0.0"
```

## New `[env]` and `[tools.*.env]` settings

We're also introducing 2 new settings to the `.prototools` file, [`[env]`](/docs/proto/config#env)
and [`[tools.*.env]`](/docs/proto/config#toolsenv), both of which configure environment variables
that'll be applied when the tool is executed. This is useful for defining directory-level and
tool-specific variables.

```toml title=".prototools"
[env]
DEBUG = "*"

[tools.node.env]
NODE_ENV = "production"
```

> View the [configuration documentation](/docs/proto/config) for more information on how these work!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.29.0) for a full list
of changes.

- Updated `proto tool info` to display aliases and environment variables.
- Updated WASM logs to be shown alongside proto's `--log` output (under the `extism::pdk`
  namespace).

---

## moon v1.20 - Extension plugins, default task options, and more

In this release, we're excited to introduce extensions, our first type of plugin!

## New extension plugins

In our [2024 roadmap blog post](./2024-roadmap), we talked heavily about plugins, as we believe
they're the future of moon and its ecosystem. What we didn't talk about is that we plan to have
_many types of plugins_, and not just language/platform specific ones. And with that, we're excited
to introduce extensions!

An extension is a WASM plugin that allows you to extend moon with additional functionality, have
whitelisted access to the file system, and receive partial information about the current workspace.
Extensions are extremely useful in offering new and unique functionality that doesn't need to be
built into moon's core.

Once such extension is our built-in `download` extension, which is a basic extension that simply
downloads a file from a URL into the current moon workspace.

```shell
$ moon ext download -- --url https://github.com/moonrepo/proto/releases/latest/download/proto_cli-aarch64-apple-darwin.tar.xz
```

Shipping alongside extensions are the following new features:

- An [official extensions guide](/docs/guides/extensions)!
- An [`extensions`](/docs/config/workspace#extensions) setting for configuring new extensions.
- A [`moon ext`](/docs/commands/ext) command for executing a configured extension.
- The required infrastructure for plugins!

## Configure default options for tasks

[Task options](/docs/config/project#options) provide a way to apply granular changes to a task's
behavior when running in the pipeline. However, they can become tedious when you need to apply them
to many tasks, especially when inheritance is involved. To help with this, you can now configure the
[`taskOptions`](/docs/config/tasks#taskoptions) setting in task related configs, like
`.moon/tasks.yml` and `.moon/tasks/*.yml`, which acts as the base/default options for all inherited
tasks.

For example, the following config:

```yaml title=".moon/tasks.yml"
tasks:
  build:
    # ...
    options:
      outputStyle: 'stream'
      retryCount: 2
  lint:
    # ...
    options:
      outputStyle: 'stream'
      retryCount: 2
  test:
    # ...
    options:
      outputStyle: 'stream'
      retryCount: 2
```

Can simply be rewritten as:

```yaml title=".moon/tasks.yml"
taskOptions:
  outputStyle: 'stream'
  retryCount: 2

tasks:
  build:
    # ...
  lint:
    # ...
  test:
    # ...
```

Because these options are defined at the workspace-level, they adhere to the same merge and
inheritance rules as other settings. Just be aware that these options are inherited first in the
chain, and can be overwritten by other layers, or by project-level tasks.

## Optional task dependencies

By default, all task [`deps`](/docs/config/project#tasks-1) are required to exist when tasks are
being built and expanded, but this isn't always true when dealing with composition and inheritance.
For example, say you're using
[tag-based inheritance](/docs/concepts/task-inheritance#scope-by-project-metadata), and a global
task relies on one of these tagged tasks, but not all projects may define the appropriate tags. In
previous versions of moon, this is a hard failure, as the dependent task does not exist.

To remedy this, we're introducing a new [`optional`](/docs/config/project#optional-1) flag for task
dependencies. When set to `true`, moon will no longer error when the task doesn't exist, and instead
will omit the dependency.

```yaml title=".moon/tasks.yml" {4-6}
tasks:
  build:
    command: 'vite'
    deps:
      - target: '#components:build'
        optional: true
```

> Thanks to [@maastrich](https://github.com/maastrich) for this contribution!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.20.0) for a full list
of changes.

- Added a "Tags" view to the VSCode extension.
- Updated proto to v0.29.1 (from v0.26.4).
- Updated proto installation to trigger for all applicable commands, not just `moon run`,
  `moon check`, and `moon ci`.

---

## moon v1.21 - Deno tier 3, file group improvements, task shells, and more!

With this release, get ready for Deno tier 3 support, file group and task improvements, a new
extension, and more.

## Deno tier 3 support

We've supported Deno tier 1 and 2 for almost a year now, but were hesitant to support tier 3 until
[proto](/proto) stabilizes further. Now that proto is _almost_ at an official v1 release, and other
tools in the toolchain (like Node.js, Bun, and Rust) are powered by proto, we're confident in
supporting Deno tier 3. To make use of this, simply set the
[`deno.version`](/docs/config/toolchain#deno) setting in
[`.moon/toolchain.yml`](/docs/config/toolchain).

```yaml title=".moon/toolchain.yml"
deno:
  version: '1.40.0'
```

When enabled, moon will download and install that version of Deno in the background, and run all
subsequent tasks with it. This is great for ensuring that your project is always using the same
version of Deno, across all machines.

## File groups now support environment variables

Task [`inputs`](/docs/config/project#inputs) have supported environment variables for a while now,
but file groups have not. The main reason for this is that file groups were implemented far before
environment variables in task inputs! To bridge this gap, we've added support for environment
variables in file groups.

```yaml
fileGroups:
  vite:
    - '...'
    - '$VITE_SECRET_KEY'
    - '$NODE_ENV'

tasks:
  build:
    command: 'vite build'
    inputs:
      - '@group(vite)'
```

Environment variables can be referenced using the
[`@group` token function](/docs/concepts/token#group), or the new
[`@envs` token function](/docs/concepts/token#envs). The latter is only supported for `inputs` and
will error for other locations, while the former is supported in `args`, `inputs`, and `outputs`,
but will filter out environment variables when they are not supported.

## New `unixShell` and `windowsShell` task options

When the [`shell`](/docs/config/project#shell) task option is enabled, we run the task within a
shell. However, the chosen shell was hard-coded to `$SHELL` on Unix machines and PowerShell on
Windows, but what if you wanted to run it with a different shell? Or the same shell across all
operating systems? Well, you couldn't.

But not anymore! With this release, we're introducing [`unixShell`](/docs/config/project#unixshell)
and [`windowsShell`](/docs/config/project#windowsshell) task options. When paired with `shell`, the
task will run in a shell of your choice. For example, why not Bash everywhere?

```yaml title="moon.yml"
tasks:
  build:
    command: 'vite build'
    options:
      shell: true
      unixShell: 'bash'
      windowsShell: 'bash'
```

## New `migrate-turborepo` extension

In our previous release, we added support for [extensions, a new kind of WASM plugin](./moon-v1.20).
Since this is a new experimental feature, we really wanted to show off what it can do, and stress
test its boundaries. To do that, we chose to migrate the old `moon migrate from-turborepo` command
into an extension
([source can be found here](https://github.com/moonrepo/moon-extensions/tree/master/crates/migrate-turborepo)).
This is our most complex extension so far, as it:

- Loads and parses files on the file system.
- Reads and writes JSON and YAML files.
- Supports deserializing data into structs.
- Extracts project graph information by executing `moon project-graph`.

Do you currently have a Turborepo powered repository? And want to migrate to moon? Then simply
execute the extension as such. View our
[guide for more information](/docs/guides/extensions#migrate-turborepo)!

```shell
$ moon ext migrate-turborepo
```

As part of the migration from moon's Rust core into a WASM plugin, we've added support for the
following new features:

- Added Bun support behind a new `--bun` flag.
- Added support for Turbo's `globalDotEnv`, `dotEnv`, and `outputMode`.
- Added support for root-level tasks (`//#`) through a root `moon.yml`, instead of logging a
  warning.
- Updated migrated task commands to run through a package manager, instead of
  `moon node run-script`.

:::info

Based on the success of this extension, we plan to support a `migrate-nx` extension in the future!
If you'd like to help in this endeavor, let us know!

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.21.0) for a full list
of changes.

- Added `bun.inferTasksFromScripts` setting to `.moon/toolchain.yml`, for compatibility with
  Node.js.
- Added a `--quiet` global argument, for hiding non-critical moon output.
- Updated tasks with glob-like arguments to automatically enabled the `shell` option, so that glob
  expansion works correctly.
- Implemented a new buffered console layer for writing to stdout/stderr.

---

## moon v1.22 - Organizational settings, wildcard env var inputs, and Nx migration

This release introduces new organizational settings for projects, a migrate from Nx extension, and
more.

## More organizational settings

One aspect of moon that sets us apart from other build systems and tools, is that we have built-in
support for human-readable project and task metadata. This is extremely useful in organizing and
managing large repositories, especially when ownership comes into play. This information is also
used for categorization and filtering for MQL and our editor extensions/plugins.

To expand on this functionality even further, we're adding a few requests from the community, and
they are:

- New `configuration` and `scaffolding` variants for the project [`type`](/docs/config/project#type)
  setting in [`moon.yml`](/docs/config/project). Perfect for contracts and templates.

  ```yaml
  type: 'configuration'
  ```

- New [`stack`](/docs/config/project#stack) setting in [`moon.yml`](/docs/config/project), for
  categorizing which tech stack the project belongs to. Supports `frontend`, `backend`,
  `infrastructure`, and `systems`.

  ```yaml
  stack: 'frontend'
  ```

- New [`description`](/docs/config/project#description-1) setting for tasks, that provides
  human-readable information.

  ```yaml
  tasks:
    build:
      description: 'Builds the project using Vite'
      command: 'vite build'
  ```

## New wildcard environment variable inputs

Task inputs have supported environment variables for quite a while now, but they are explicit, which
can be tedious too manage when you have many environment variables. To make this easier, we've added
support for wildcard environment variables, denoted by a `*`, which will match any environment
variable with that pattern.

For example, say we want to track all Node.js and Vite environment variables that start with `NODE_`
and `VITE_` respectively, we can simply do:

```yaml
tasks:
  build:
    command: 'vite build'
    inputs:
      - '$NODE_*'
      - '$VITE_*'
```

> Do note that this _isn't_ a glob, and the `*` is merely a substitution for any character!

## New `migrate-nx` extension

In our previous release, we added support for [migrating from Turborepo](./moon-v1.21), but what
about Nx? Nx is a very popular build system with many users. A lot of our current moon users were
former Nx users, but unfortunately, they had to go through the tedious process of migrating
everything manually. We wanted to make this process easier for new users, so we created a new
experimental extension to help with this process,
[`migrate-nx`](/docs/guides/extensions#migrate-nx).

```shell
$ moon ext migrate-nx
```

This extension was quite complicated to implement, as Nx has a _ton_ of features. However, when the
extension is executed, we'll convert the root `nx.json` and `workspace.json` files to
[`.moon/workspace.yml`](/docs/config/workspace) and related top-level config files, and we'll also
convert every `project.json` and `package.json` (with an `nx` block) into a
[`moon.yml`](/docs/config/project) file.

Conversion is not a perfect 1:1, as moon and Nx are quite different. Please refer to the
[official documentation](/docs/guides/extensions#migrate-nx) for a list of unsupported settings and
features.

:::info

An awesome feature that didn't make it in time for this release, is an npm package for Nx
compatibility, that will allow Nx executors/plugins to be executed through moon, without the
requirement of Nx itself. This will allow for a seamless transition from Nx to moon, without the
need to change any of your existing Nx executors/plugins till later.

This functionality will be provided by our new
[`@moonrepo/nx-compat` package](https://github.com/moonrepo/moon/tree/master/packages/nx-compat),
which we hope to finish in the coming weeks.

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.22.0) for a full list
of changes.

- Added an `installArgs` setting for bun/npm/pnpm/yarn in `.moon/toolchain.yml`, to customize the
  args used when installing dependencies.
- Updated the `envFile` task option to support a list of file paths.

---

## proto v0.31 - Improved version pinning, removed global packages management, and more

In preparation for an official v1 release, we've improved stability, the overall developer
experience, we're renaming some commands, and removing the "global packages" functionality.

## Improved version pinning

Based on feedback from the community, we've made some slight changes to pinning to reduce confusion.
The biggest points of contention were, "Why does `proto install --pin` pin globally?", and "Why
doesn't `proto pin` resolve the version like `proto install --pin` does?".

To remedy the first issue, we've updated the `--pin` argument to optionally support a string value
of "local" or "global". When local, will pin to the `.prototools` file in the current directory,
otherwise it will pin to `~/.proto/.prototools`.

```shell
$ proto install node --pin # global
$ proto install node --pin global
$ proto install node --pin local
```

As for the second issue, we've introduced a new option called `--resolve`, which will resolve the
version to a fully qualified semantic version (or fail). This isn't the default functionality, as to
not break existing workflows, and because you may want to actually pin "1" instead of "1.2.3".

```shell
$ proto pin node 1 # 1
$ proto pin node 1 --resolve # 1.2.3
```

## Removed global package management (breaking)

A while back we introduced the `proto install-global` and `proto uninstall-global` commands as a
means for managing global packages. This was added to solve issues with the Node.js ecosystem,
primarily around standardizing where global packages would be installed across all package managers.
On top of this, we also introduced a "command interception" feature, which would error telling you
to use proto's command instead of the package manager's.

As a whole, this feature was _very_ disruptive to users, caused a lot of confusion, was simply
poorly implemented, and honestly wasn't really necessary for tools outside of Node.js. Because of
all of this, we've decided to entirely remove our global package management functionality, this
includes:

- `proto install-global` command
- `proto uninstall-global` command
- `proto list-global` command
- `intercept-globals` setting for node/npm/pnpm/yarn
- `globals` setting for TOML plugins

## New npm/pnpm/yarn `shared-globals-dir` setting

Since we removed our global packages support (above), we had to also remove the `intercept-globals`
setting from our Node.js related WASM plugins. However, we still believed in the benefit it
provided, primarily around standardizing where global packages would be installed across all package
managers.

To still support this in some capacity, we've introduced a new `shared-globals-dir` setting for npm,
pnpm, and yarn. This setting still standardizes the install path, _but instead_ of intercepting
commands like it did before, it now appends the global package install commands with additional
arguments or environment variables. This should be entirely transparent to you!

```toml title=".prototools"
[tools.npm]
shared-globals-dir = true
```

An example of how this now works:

```shell
# = v0.31
npm install --global typescript

# Under the hood becomes...
PREFIX=/.proto/tools/node/globals npm install --global typescript
```

## Renamed commands (breaking)

We're still not happy with some of the current command names, especially around tools and plugins,
so we've renamed a few of them. They are:

- Renamed the `proto tool` commands to `proto plugin`. An alias still exists for the time being.
- Removed the `proto tool list-plugins` command, and merged its functionality into
  `proto plugin list`.

As for the `proto plugin list` command, we've removed the versions and aliases from the output by
default, and wrapped them in new `--versions` and `--aliases` options.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.31.0) for a full list
of changes.

- Fixed an issue where empty version strings were being parsed, causing failures.

---

## moon v1.23 - Codegen improvements, stack inheritance, internal tasks, and more

It's been a month since our last release, and we're excited to land major codegen and task
improvements.

## Template & generator improvements

Based on feedback and requests from community, we've made quite a few improvements to our code
generation workflow!

### Git and npm template locators

Our [`generator.templates`](/docs/config/workspace#templates) setting has only supported file system
paths, relative from the workspace root. This has made it quite difficult to share templates across
repositories, but no longer!

Template locations now support Git repositories and npm packages, through the `git:` and `npm:`
prefixes respectively. The `git:` locator requires a Git repository URL and explicit revision
(branch, commit, etc), while the `npm:` locator requires a package name and explicit version. For
example:

```yaml title="moon.yml"
generator:
  templates:
    - 'git://github.com/moonrepo/templates#master'
    - 'npm://@moonrepo/templates#1.2.3'
```

> Learn more about this in the official
> [code generation guide](/docs/guides/codegen#configuring-template-locations)!

### Custom template names

Historically, a template's name was derived from the directory the
[`template.yml`](/docs/config/template) file was located in. While this works great for small repos,
it falls apart for large monorepos when there's multiple teams defining templates, as the chance of
name collisions arise.

To combat this problem, we're introducing a new [`id` setting](/docs/config/template#id) for
templates, which allows you to customize the exact name of the template. This setting is optional,
and if not provided, the name will be derived from the directory as before.

```yaml title="template.yml"
id: 'my-template'
```

### New variable settings

And lastly, we're introducing some additions and improvements to template
[`variables`](/docs/config/template#variables).

- A new `order` setting, which defines the order in which variables are prompted to the user.
- A new `internal` setting, which avoids the value being set from the CLI.
- Enum `default` values now support a list of values (cannot be provided by the CLI yet).
- Enum `prompt`s are now optional, and will fallback to the default value if not provided.

## Stack-based task inheritance

Last month in [moon v1.22](./moon-v1.22), we introduced the [`stack`](/docs/config/project#stack)
setting for organizing projects into what tech stack they belong to. This is primarily for
organizational purposes, and improving our project constraints implementation.

Based on community feeedback, we've expanded the `stack` setting to also apply for
[task inheritance](http://localhost:3000/docs/concepts/task-inheritance#scope-by-project-metadata).
You can now inherit tasks for the stack itself, or through a combination of the project language,
platform, and type. For example:

- `.moon/tasks/backend.yml`
- `.moon/tasks/javascript-backend.yml`
- `.moon/tasks/frontend-library.yml`
- `.moon/tasks/bun-frontend-application.yml`

## Internal tasks

We're introducing a new [task mode](/docs/concepts/task#modes) called internal, which can be enabled
with the [`internal`](/docs/config/project#internal) task option. Internal tasks are tasks that are
not meant to be ran explicitly by the user (via [`moon check`](/docs/commands/check) or
[`moon run`](/docs/commands/run)), but are used internally as dependencies of other tasks.

This functionality provides another way to organize your tasks.

```yaml title="moon.yml"
tasks:
  prepare:
    command: 'intermediate-step'
    options:
      internal: true
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.23.0) for a full list
of changes.

- Added a `variables()` function for templates that returns an object of all variables available.
- Updated `moon project` and `moon task` to include the configuration files that tasks inherit from.
- Updated `moon task` to include the modes it belongs to.

---

## proto v0.34 - New detection strategy, status command, and outdated improvements

In this release, we've focused on the developer experience for common workflows.

## New `only-prototools` detection strategy

proto currently detects versions at runtime using
[1 of 2 strategies](/docs/proto/config#detect-strategy), `first-available` which checks
`.prototools` files and tool-specific files (like `package.json` engines), whichever is first, or
`prefer-prototools` which works like the previous strategy, but prefers `.prototools` (even in a
parent directory).

In this release, we're adding a 3rd strategy called `only-prototools`. This strategy will only check
`.prototools` files and will not check tool-specific files. This is useful if you want explicit
versions, and to avoid unexpected versions from random configs/directories.

```toml title=".prototools"
[settings]
detect-strategy = "only-prototools"
```

> For the v1 release, we plan to make this strategy the new default.

## New `proto status` command

Sometimes you simply want to know what tools are currently active for a target directory, what
versions those tools are resolved to, and the configuration file in which they are defined. To
satisfy this requirement, we've added a new [`proto status`](/docs/proto/commands/status) command,
which outputs something like the following:

```
$ proto status

Tool  Configured  Resolved  Installed                   Config
deno  1.40.0      1.40.0    ~/.proto/tools/deno/1.40.0  ~/.prototools
node  20.8.0      20.8.0    ~/.proto/tools/node/20.8.0  ~/.prototools
npm   10.1.0      10.1.0    ~/.proto/tools/npm/10.1.0   ~/.prototools
```

By default this includes tools from all `.prototools` files up the hierarchy, excluding
`~/.proto/.prototools`. To include global tools as well, pass `--include-global`.

## Improved `proto outdated` experience

The [`proto outdated`](/docs/proto/commands/outdated) command has worked "alright" but its developer
experience wasn't the best. The terminal output was rudimentary, and writing updated versions to
`.prototools` would save to the current directory, instead of the directory they are configured in.

To improve the overall developer experience, we've made the following changes to this command:

- Displays all tools and available updates as a table of data.
- Includes both newest (matching range) and latest versions available.
- Includes the config file that the tool + version was loaded from.
- When `--update` is passed, will now prompt to confirm the update.
- When updating versions, versions are now written to their original config file, instead of local.
- Updated the `--latest` flag to use the latest version when updating, instead of newest.

```
$ proto outdated

Tool  Current  Newest   Latest  Config
deno  1.40.0   1.42.4   1.42.4  ~/.prototools
node  20.8.0   20.12.2  21.7.3  ~/.prototools
npm   10.1.0   10.5.2   10.5.2  ~/.prototools
```

## What about v0.32 and v0.33?

You may have noticed that we don't have blog posts for either of these versions. The v0.32 release
was a relatively light release with no meaningful changes, so we opted to not write a blog post for
it. As for v0.33, we ran into build issues while releasing it, so we decided to skip it and move on
to v0.34.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.34.0) for a full list
of changes.

- Added a `dist-url` setting to some plugins, allowing the distribution download URL to be
  customized.
- Updated `proto setup` (which is ran during proto installation) to modify the `PATH` system
  environment variable on Windows. To disable this functionality, pass `--no-modify-path`.

---

## moon v1.24 - Task mutexes, auto-detect revisions, project dependents, and more!

This is a light release that focused solely on requests and improvements from the community.

## Exclusive resources with task mutexes

Some tasks may require exclusive access to a resource, like a database, file, or network connection,
but other parallel running tasks may also require access to the same resource. When both of these
tasks run, they may conflict with each other, causing one or both to fail. This wasn't an easy
problem to solve in moon, until now!

Thanks to [Andrés Correa Casablanca](https://github.com/castarco) for the idea and implementation,
tasks now support a new option called [`mutex`](/docs/config/project#mutex). This option allows you
to specify a unique name (across the entire workspace) for the mutex, which will be used to lock the
task from running if another task with the same mutex name is already running.

Take the following for example:

```yaml
# server/moon.yml
tasks:
  build:
    command: 'build-server'
    options:
      mutex: 'app'

# client/moon.yml
tasks:
  build:
    command: 'build-client'
    options:
      mutex: 'app'
```

When [`moon run :build`](/docs/commands/run) or [`moon ci`](/docs/commands/ci) is ran, both tasks
will be parallelized within our pipeline, _but_ only one of them will run at a time. If the `server`
task is running, the `client` task will wait until the `server` task is complete. This ensures that
both tasks don't conflict with each other.

This could technically be solved through task `deps`, but with a mutex, it allows you to decouple
project and task dependencies, and instead focus on a virtual resource that is being locked.

## Auto-detect base/head for `moon ci`

We've updated [`moon ci`](/docs/commands/ci) to try and detect the base and head revisions
automatically when running in a popular CI provider, like GitLab and Jenkins. For the base revision,
we'll use the base/target commit SHA or target branch, while the head revision will use the source
commit SHA or `HEAD`. This is great for pull requests and forks!

With that said, these values can be overwritten with environment variables, or command line
arguments. Below is the order of precedence:

- `MOON_BASE` / `MOON_HEAD` environment variables
- `--base` / `--head` command line arguments
- `base_revision` / `head_revision` via CI provider
- `vcs.defaultBranch` setting / `HEAD` literal value

> This functionality is provided by the [`ci_env`](https://github.com/milesj/rust-cicd-env) Rust
> crate. Please refer to that crate for supported providers, and which of them support revision
> detection (primarily the `base_revision` and `head_revision` fields).

## Include dependents for focused project graph

When running [`moon project-graph `](/docs/commands/project-graph), we visualize a graph of the
focused project and all of its dependencies (other projects it depends on). However, if you wanted
to also visualize dependents (other projects that depend on the focused project), this was currently
not possible.

We felt this information could be useful, so we've added a `--dependents`
flattenDiagnosticMessageText, which will include direct dependents in the graph.

```shell
$ moon project-graph server --dependents
```

We also felt dependent information can be useful when querying projects, so have also added support
for the `--dependents` flag to the [`moon query projects`](/docs/commands/query/projects) command.

```shell
$ moon query projects --affected --dependents
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.24.0) for a full list
of changes.

- Added an experimental `moon templates` command, that lists all available codegen templates.
- Added a `runner.autoCleanCache` setting to `.moon/workspace.yml`, allowing the post-run clean
  mechanism to be controlled.
- Updated `moon generate` with better argument to variable handling.
- Updated action graph and project graph visualization to be more readable.
- Updated root-level tasks to have no inputs by default, instead of `**/*`.

---

## proto v0.35 - Support for more shells

This is a light release that adds support for more terminal shells.

## Experimental support for new shells

proto has always supported the primary and common shells like Bash, Zsh, Fish, PowerShell, and more.
In recent years, there has been an influx of new and modern shells, built with technologies such as
Rust. We felt it was time to start supporting some of these new shells, and have added
[experimental support](https://crates.io/crates/starbase_shell) for:

- [Ion](https://github.com/redox-os/ion)
- [Nu](https://www.nushell.sh/)
- [Xonsh](https://xon.sh/)

Furthermore, the [`proto setup`](/docs/proto/commands/setup) command (which is ran when installing
proto) will now prompt the user to select a shell if one could not be detected.

## Generate trace profiles

A major goal of proto is to be extremely efficient and to optimize as much as possible. To help
accomplish this goal, we're introducing the global CLI `--dump` flag, which will generate a trace
profile that can be loaded and reviewed in `chrome://tracing`.

This will display a flame graph with labeled operations, their timing information, and any
associated data. This is the first step in capturing this kind of information, and it will only get
better moving forward.

:::caution

Generating a profile for running a tool, either with `proto run node` or `node` itself, will not
work. This is because the tool process _replaces_ the current proto process entirely, causing the
profile to be interrupted and abort.

:::

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.35.0) for a full list
of changes.

---

## moon v1.25 - New task runner and console reporter

In this release, we focused primarily on rewriting our task runner, and improving our console.

## New task runner implementation

It's been over a month since our last release, but we've been really busy rewriting our task runner
from the ground up! In other build systems, a task runner is typically the orchestator that runs
multiple tasks and manages their state. In moon this is known as the action pipeline (or just
pipeline), and a task runner is simply the execution of a single task. However, executing a single
task is quite involved, as we need to generate a unique hash, check the cache, hydrate outputs if a
cache hit, actually execute the task as a child process, and much more!

Task running is some of the oldest code in moon, as it was part of the initial MVP. Because of this,
it hasn't changed much, but moon has grown quite large and it was time to revisit it with better
design patterns and practices. Furthermore, since the task runner is so critical to moon itself, we
wanted to ensure it worked correctly, and spent more time than usual implementing, testing it, and
verifying edge cases.

With this new task runner, we...

- Improved handling and reliability of output archiving (cache miss) and hydration (cache hit).
- Streamlined the task execution (child process) flow.
- Increased performance by optimizing or removing certain code paths.

> If you're interested in how the task runner was implemented, feel free to take a look at the
> [Rust crate](https://github.com/moonrepo/moon/tree/master/crates/task-runner), and the
> [pull request](https://github.com/moonrepo/moon/pull/1463) itself.

### Fine-grained operations

A major goal of moon is bubbling up information to the user that is applicable to the current
workflow, but what about when that workflow must be debugged or optimized? At that point, it was
almost impossible without digging into the source code.

To make a step in this direction, as part of the new task runner we now track timing information for
individual parts of the run execution, and we're calling these parts operations. An operation is
anything from generating a hash, creating a tarball archive, unpacking the archive (cache
hydration), task execution (the child process), and more.

This timing information is useful in figuring out why a certain task is slower than expected, and
which operation is actually causing the slowness. It also helps to uncover which operations were
actually ran for an action, which were skipped, so on and so forth. At this point in time, the
operations information is only included in the run report, located at `.moon/cache/runReport.json`.
In the future, we plan to display this information in a nice UI.

For an example of this in action, here's a list of all operations that were executed when running
the `build` task for our website.

```json
[
  {
    "duration": {
      "secs": 0,
      "nanos": 609156875
    },
    "finishedAt": "2024-05-27T00:14:54.286628",
    "meta": {
      "type": "hash-generation",
      "hash": "10606e37c5e6ab4008007b30275f1682bae32dca71650ce173eb386d5b6c3309"
    },
    "startedAt": "2024-05-27T00:14:53.677526",
    "status": "passed"
  },
  {
    "duration": {
      "secs": 0,
      "nanos": 32834
    },
    "finishedAt": "2024-05-27T00:14:54.286667",
    "meta": {
      "type": "output-hydration"
    },
    "startedAt": "2024-05-27T00:14:54.286634",
    "status": "skipped"
  },
  {
    "duration": {
      "secs": 15,
      "nanos": 789003125
    },
    "finishedAt": "2024-05-27T00:15:10.075113",
    "meta": {
      "type": "task-execution",
      "command": "docusaurus build",
      "exitCode": 0
    },
    "startedAt": "2024-05-27T00:14:54.286950",
    "status": "passed"
  },
  {
    "duration": {
      "secs": 17,
      "nanos": 214634292
    },
    "finishedAt": "2024-05-27T00:15:27.289995",
    "meta": {
      "type": "archive-creation"
    },
    "startedAt": "2024-05-27T00:15:10.075686",
    "status": "passed"
  }
]
```

Because of these new operations, we can clearly see above that the archive creation process is
taking 17 seconds, which is 2 seconds longer than the build itself! Without this information, we
would have never known that the archive was taking this long, but now we do, and we can optimize it
in a future release!

### Run summaries

Because of the new task runner and the new console ([below](#new-console-reporting-layer)), we have
the ability to bubble up more information than before. Based on requests from the community, we've
taken the output from [`moon ci`](/docs/commands/ci) and applied it to both
[`moon check`](/docs/commands/check) and [`moon run`](/docs/commands/run) behind the `--summary`
flag.

When this flag is passed, we will now summarize all actions that have ran in the pipeline (not just
task related ones), and include failed tasks for review. For example, here's the output of
`moon check website --summary` on moon's repository.

```
$ moon check website --summary

▪▪▪▪ types:build (cached, 1ms, 21bd9add)
▪▪▪▪ runtime:build (cached, e8363e65)
▪▪▪▪ website:typecheck (cached, 0ab91eaa)
▪▪▪▪ website:format (cached, 07ae2388)
▪▪▪▪ website:test (cached, 11d33e2e)
▪▪▪▪ website:lint (cached, 2197fbb1)
▪▪▪▪ website:build (10606e37)
▪▪▪▪ website:build (15s 789ms, 10606e37)

SUMMARY

pass SyncWorkspace
skip SetupNodeTool(20.13.1) (skipped, 250ms)
skip InstallNodeDeps(20.13.1) (skipped, 13ms, f341872f)
pass SyncNodeProject(types) (1ms)
pass SyncNodeProject(runtime) (1ms)
pass RunTask(types:build) (cached, 140ms, 21bd9add)
pass SyncNodeProject(website) (1ms)
pass RunTask(runtime:build) (cached, 32ms, e8363e65)
pass RunTask(website:build) (33s 614ms, 10606e37)
pass RunTask(website:format) (cached, 59ms, 07ae2388)
pass RunTask(website:lint) (cached, 101ms, 2197fbb1)
pass RunTask(website:test) (cached, 64ms, 11d33e2e)
pass RunTask(website:typecheck) (cached, 59ms, 0ab91eaa)

STATS

Actions: 11 completed (6 cached), 2 skipped
   Time: 34s 52ms
```

## New console reporting layer

For the most part, when something in moon needed to be printed to the console, we would simply print
it directly at that point in time, anywhere within the codebase. While this worked, it made it
difficult to orchestrate output from different parts of the codebase, and in the context of Rust,
each call to stdout/stderr [locks the I/O stream](https://nnethercote.github.io/perf-book/io.html),
resulting in performance loss.

To work around this, in [v1.21](./moon-v1.21) we implemented a new
[console layer](https://github.com/moonrepo/moon/tree/master/crates/console) that buffers all stdio
writes, and prints them on 100ms intervals. This avoids locking on every call, and instead batches
them. To expand on this further, in this release we've implemented a new
[reporter layer](https://github.com/moonrepo/moon/tree/master/crates/console-reporter), with a
well-defined interface that is used to print checkpoints (the 4 squares), and status updates from
the action pipeline (and the new task runner).

This reporter layer enables new console UI implementations in the future based on your preferences.
For example, an [interactive UI](https://ratatui.rs/) composed of tables, tabs, and more,
representing the current state of the pipeline.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.25.0) for a full list
of changes.

- Greatly reduced the amount of concurrent locks being held during task execution. May see slight
  performance improvements.
- Updated external configuration files (via https extends) to be cached for 24 hours.
- Updated macOS binaries to be built on macos-12 instead of macos-11.
- Updated proto to v0.35.4 (from v0.34.4).

---

## proto v0.36 - Static registry, plugin searching, and more

In this release, we're taking the first step in supporting a plugin registry.

## New static registry

Our long-term plan for proto is to provide a server-based registry in which users could publish and
manage plugins, and immediately make them available to the community. However, this is quite a
mountain of work, and will take some time, but making plugins available _now_ is a priority.

As a temporary solution, we're introducing a static registry, in which available plugins are defined
in static JSON files, located in the official
[moonrepo/proto](https://github.com/moonrepo/proto/tree/master/registry) repository. This will help
unblock new features moving forward.

## New `proto plugin search` command

Because of the static registry work above, we're now able to introduce a new command,
[`proto plugin search`](/docs/proto/commands/plugin/search), that can be used to search for plugins
provided by the community. No longer will you need to browse the documentation, or search Google for
available plugins.

```
$ proto plugin search moon

Plugins
Available for query: moon

 Plugin  Author    Format  Description                                                          Locator
 moon    moonrepo  TOML    moon is a multi-language build system and codebase management tool.  https://raw.githubusercontent.com/moonrepo/moon/master/proto-plugin.toml
```

## New `proto unpin` command

Additionally, a command that probably should have existed from the start, but did not, is now
available. The [`proto unpin`](/docs/proto/commands/unpin) command does exactly as its name says, it
unpins (removes) a version from a `.prototools` file.

## Plugin locator syntax changes

We've decided to slightly change the syntax of plugin locator strings by embracing the common
protocol syntax. Instead of `source:` and `github:`, we now use `file://`, `https://`, and
`github://`. The former syntax will continue to work for the time being, but will be removed
entirely in the future.

- `source:./file.wasm` -> `file://./file.wasm`
- `source:https://url.com/file.wasm` -> `https://url.com/file.wasm`
- `github:org/repo` -> `github://org/repo`

> If a `proto` command modifies a `.prototools` file, the file will be saved with the new syntax.
> Don't be surprised when this happens!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.36.0) for a full list
of changes.

- Updated `proto uninstall` to also remove entries from `.prototools` if the version was
  uninstalled.
- Updated some error messages to include copy for work arounds.
- We now lock the bin/shims directory when creating/removing files.
  - This is an experiment to help avoid race conditions where multiple proto processes are all
    trying to write to the same location.
  - If this results in too large of a performance hit, we'll remove the locking.

---

## proto v0.37 - Calver support and self diagnosis

This is a small release, but includes 2 very important features.

## Calender versioning support

For the most part, tools use [semver](http://semver.org/) (semantic versions) for their releases,
but every so often you run into a tool that uses another format, [calver](https://calver.org/)
(calendar versions). Some examples of calver are `2024-02`, `2024-10-23`, and `2024-12-9.123`.

Calendar based versions were not supported previously as the syntax between semver and calver are
different enough that they could not be parsed successfully. Well no longer, as we spent the time
writing our own custom parser to differentiate between the 2 formats. This process is quite
complicated, and has many restrictions and caveats, so we took the time to document it under the
name [version specification](/docs/proto/tool-spec).

The biggest difference between semver and calver syntax, is that semver is dot-separated, while
calver is dash-separated. The day part (patch) is also optional in calver.

:::caution

We wrote a ton of tests to cover all the formats and edge cases we could think of, but if you run
into a tool that fails to parse versions correctly, please report an issue immediately! All of our
built-in tools have been tested against.

:::

## New `proto diagnose` command

A common issue within the community that we've seen is commands not being available after installing
a tool. Most of the time, this is caused by certain proto paths not existing within `PATH`. To help
remedy these issues moving forward, we're introducing a new command,
[`proto diagnose`](/docs/proto/commands/diagnose) (or `doctor`) that will attempt to find all issues
with your proto installation.

```
$ proto diagnose

Shell: zsh
Shell profile: ~/.zshrc

Errors
  Issue: Bin directory (~/.proto/bin) was found BEFORE the shims directory (~/.proto/shims) on PATH
  Resolution: Ensure the shims path comes before the bin path in your shell

Warnings
  Issue: Missing PROTO_HOME environment variable (Will default to ~/.proto if not defined)
  Resolution: Export PROTO_HOME="$HOME/.proto" from your shell
```

In the future, we'll expand on this command by also bubbling up issues from your installed tools.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.37.0) for a full list
of changes.

- Improved command execution. May see some slight performance gains.
- Updated wasmtime to v21 (from v17).

---

## moon v1.26 - New experimental pipeline, trace profiles, and more

In this release, we focused primarily on a next-generation actions pipeline.

## New experimental pipeline

The [action pipeline](/docs/how-it-works/action-graph) or just "pipeline", is the system in which we
actually run tasks in topological order when [`moon run`](/docs/commands/run),
[`moon check`](/docs/commands/check), or [`moon ci`](/docs/commands/ci) is executed. The pipeline is
powered by the [action graph](/docs/how-it-works/action-graph) (also known as a task graph or
dependency graph) and is quite complex, as we need to efficiently run tasks on our thread pool,
ensure dependency tasks are ran before running dependent tasks, handle signals (ctrl + c), and much
more.

Our current implementation "works" but could be much better, as it still has some problematic edge
cases, [doesn't always shutdown correctly](https://github.com/moonrepo/moon/issues/902), and is
pretty much tech debt at this point. To remedy this, we spent the last month working on a new action
pipeline that aims to solve all of these problems, with a more modern implementation. Some such
improvements are:

- Increased performance with better concurrency handling and scheduling. Threads in the pool should
  now be constantly utilized.
- More accurately monitors signals (ctrl+c) and shutdowns. We now use Rust channels internally to
  manage this state.
- The CLI will now wait for aborted/cancelled task handles to exit before the entire CLI exits. This
  should alleviate zombie processes.

With all that said, unlike previous releases that replaced the old feature with a new feature, we
chose to gate this new pipeline behind an experimental flag. We want to ensure this works correctly
in all cases, before enabling it by default. So please test it and report back any issues! We've
successfully been using it on moon's repository without issue.

```yaml title=".moon/workspace.yml"
experiments:
  actionPipelineV2: true
```

## Generate trace profiles

A major goal of moon is to be extremely efficient and to optimize as much as possible. To help
accomplish this goal, we're introducing the global CLI `--dump` flag, which will generate a trace
profile that can be loaded and reviewed in `chrome://tracing`.

This will display a flame graph with labeled operations, their timing information, and any
associated data. This is the first step in capturing this kind of information, and it will only get
better moving forward.

## Additional shell support

Based on the work in [proto](/proto), we now have built-in support for additional command line
shells. To start, we've updated the [`unixShell`](/docs/config/project#unixshell) and
[`windowsShell`](/docs/config/project#windowsshell) task options to support the following new
shells:

- Unix: `ion`, `nu` (nushell), `pwsh` (powershell), `xonsh`.
- Windows: `elvish`, `fish`, `nu` (nushell), `xonsh`

And furthermore, we've added Nushell completion support to the
[`moon completions`](/docs/commands/completions) command!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.26.0) for a full list
of changes.

- Updated CLI command execution to be more performant, and to reduce our usage of concurrent locks.
- Updated proto to v0.37.1 (from v0.36.2).

---

## proto v0.38 - Shell activation / hooks

In this release, we're introducing a long requested feature, shell hooks!

## New experimental shell activation workflow

You've most likely used another version manager before proto, and may have used a workflow where
`PATH` was automatically updated with versioned binaries of specific tools, or environment variables
were injected into your shell. This functionality is what's known as shell hooks, and proto now has
experimental support for them through a feature known as
[shell activation](/docs/proto/workflows#shell-activation)!

### How it works

For example, say you're using Zsh as your shell. You could now append the following expression at
the bottom of your shell profile, which evaluates our new
[`proto activate`](/docs/proto/commands/activate) command.

```shell
eval "$(proto activate zsh)"
```

When the current working directory changes (via `cd`), or the CLI prompt changes, this activation
workflow will trigger the following:

- Download and install necessary proto plugins (if they do not exist)
- Load and resolve all `.prototools` configurations up the file system
- Detect and resolve versions for all configured tools
- Export environment variables defined in `[env]` and `[tools.*.env]`
- Prepend `PATH` with binary directories for detected tools

Pretty awesome right? We think so. But as mentioned above, this feature is highly experimental, and
may not work properly across all shells (we're unable to test everything). So if you run into an
issue, please report it!

### Unlocked features

This new workflow unlocks some functionality that was previously not possible with proto shims/bins
directly, and they are:

- Directory paths to globally installed packages are now automatically prepended to `PATH`.
  Previously, you would need to add them manually. This was non-trivial if they were installed to
  versioned locations.
- Directory paths to pre-installed binaries within a tool are also prepended to `PATH`. For example,
  Rust/Cargo and Python provide a lot of executables that were ignored by our shims.
- This workflow is 1 step closer to replacing [direnv](https://direnv.net/) itself.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.38.0) for a full list
of changes.

- Added support for [murex](https://murex.rocks/) shells.
- Added a `--include-global` flag to `proto use`, that will also install globally configured tools.

---

## moon v1.27 - Task scripts, Docker settings, and more

In this release, we're adding improved Docker support, and a long-awaited task request.

## Experimental pipeline enabled by default

In our last release, we [introduced a new action pipeline](./moon-v1.26#new-experimental-pipeline)
that is more performant, accurate, and resilient, but was hidden behind an experimental flag. Since
then, we've seen many users enable it successfully, and no issues have been reported! And with that,
we're enabling the experiment by default.

If you run into an issue with this new pipeline, you can disable the experiment in
`.moon/workspace.yml`, like so. If you do encounter an issue, please report it to GitHub or Discord!

```yaml title=".moon/workspace.yml"
experiments:
  actionPipelineV2: false
```

## New task scripts

Since the beginning, tasks in moon have been modeled around a single command and its arguments; they
are a 1-to-1 relationship. It was designed this way as it was a hard requirement for task
inheritance to work correctly. If you have multiple tasks in the chain that need to be merged
together, how will arguments be handled? Do they merge, overwrite, or replace? Do they prepend or
append? Or maybe you want to keep the arguments but rename the binary/command itself? And many more
such combinations.

But because of this limitation, tasks did not support executing multiple commands (via `&&` or `;`),
as this breaks argument merging (which command should the arguments belong too?). Tasks also did not
support redirects, pipes, and other shell scripting syntax. Over the year we've slowly tried to
support these in tasks, and while they technically do in some capacity, the experience is subpar.

To remedy this, we're introducing a new task field called [`script`](/docs/config/project#script),
which is an alternative to [`command`](/docs/config/project#command) +
[`args`](/docs/config/project#args). Scripts support everything mentioned above, and can be defined
as such (using a very contrived example).

```yaml title="moon.yml"
tasks:
  build:
    script: 'rm -rf ./out && ./doBuild.sh out && ./genStats.sh > stats.json'
    outputs:
      - 'out'
```

- Scripts do support multiple commands, redirects, and pipes, while command/args do not.
- Scripts do not support argument task inheritance merging, while command/args do.
- Scripts do not support passthrough arguments (after `--`), while command/args do.
- Scripts can only be defined with a string, while command/args support a string or array.
- Both scripts and commands support the toolchain.
- Both scripts and commands support task tokens and variables.

:::info

For a full list of comparisons, and more information on commands vs scripts, head over to the
[official task documentation](/docs/concepts/task#commands-vs-scripts)!

:::

## Improved Docker integration

As it turns out, a lot of moon users rely heavily on our Docker integration, which hasn't seen some
love in quite a while. We felt it was time to change that.

### New `moon docker file` command

Since our release of Docker in moon (v0.15), we've provided an [in-depth guide](/docs/guides/docker)
on why our integration exists, and what it aims to solve. However, the guide required a bit of
manual non-trivial setup, which left users confused more than we like. To remedy this, we're
introducing a new command, [`moon docker file`](/docs/commands/docker/file), which will generate a
multi-staged `Dockerfile` for a project.

To demonstrate this, here's what the `Dockerfile` looks like for our website.

```docker
#### BASE STAGE
#### Installs moon.

FROM node:latest AS base
WORKDIR /app

# Install moon binary
RUN curl -fsSL https://moonrepo.dev/install/moon.sh | bash
ENV PATH="/root/.moon/bin:$PATH"

#### SKELETON STAGE
#### Scaffolds repository skeleton structures.

FROM base AS skeleton

# Copy entire repository and scaffold
COPY . .
RUN moon docker scaffold website

#### BUILD STAGE
#### Builds the project.

FROM base AS build

# Copy toolchain
COPY --from=skeleton /root/.proto /root/.proto

# Copy workspace configs
COPY --from=skeleton /app/.moon/docker/workspace .

# Install dependencies
RUN moon docker setup

# Copy project sources
COPY --from=skeleton /app/.moon/docker/sources .

# Build the project
RUN moon run website:build

# Prune extraneous dependencies
RUN moon docker prune

#### START STAGE
#### Runs the project.

FROM base AS start

# Copy built sources
COPY --from=build /root/.proto /root/.proto
COPY --from=build /app /app

CMD moon run website:start
```

### New `docker` settings

To further improve our Docker support, we're also introducing new `docker` settings to both
[`.moon/workspace.yml`](/docs/config/workspace#docker) and
[`moon.yml`](/docs/config/project#docker). These settings allow you to customize the scaffold,
prune, and `Dockerfile` generation flows.

```yaml title=".moon/workspace.yml"
docker:
  prune:
    installToolchainDeps: false
  scaffold:
    include:
      - '*.config.js'
```

```yaml title="moon.yml"
docker:
  file:
    image: 'node:latest'
    buildTask: 'build'
    startTask: 'start'
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.27.0) for a full list
of changes.

- Added support for [murex](https://murex.rocks/) shells.
- Improved the "automatically install dependencies if a manifest/lockfile has changed" flow. This
  should trigger less than before.
- We now generate JSON schemas for our configuration files to `.moon/cache/schemas`, so that they
  can be dynamically created based on the current moon version and environment.
- When writing JSON and YAML files, we attempt to write back to the file with its original
  indentation.

---

## proto v0.39 - Mid-year quality of life improvements

This is a small release that includes many quality of life improvements.

## Improved `proto activate` performance

In [v0.38](./proto-v0.38) we released the [`proto activate`](/docs/proto/commands/activate) command
as a means of bootstrapping your shell with necessary paths and variables. Since then, we've fixed a
handful of bugs and focused on performance for this release.

In this release, we've reduced the time it took to execute activation from 200-300ms down to
10-20ms. We've also fixed some syntax issues around Bash and Zsh shells.

## Merged `proto install` and `proto use` commands

When proto was first built we had separate commands for installing all tools
([`proto use`](/docs/proto/commands/use)), and installing a single tool
([`proto install`](/docs/proto/commands/install)). For historical reasons, this was loosely based
off of nvm, but we have diverged heavily since then.

Going forward, the `proto use` command is now deprecated, and all of its functionality has been
merged into `proto install`. To install all tools, simply don't pass arguments to the command!

```shell
# Install all tools
$ proto install

# Install a single tool
$ proto install node
```

We like this change, as it aligns with package/dependency manager based workflows.

## Customize built-in tools

proto ships with a handful of [official built-in plugins](/docs/proto/tools#built-in) for popular
tools like Node.js, Go, and more. While this is great as it reduces configuration boilerplate, it
may cause an inconvenience for adoption or migration related reasons. To support these workflows,
we're introducing a new setting, [`settings.builtin-plugins`](/docs/proto/config#builtin-plugins),
that can be used to disable all built-in plugins, or only allow a few select plugins.

```toml title=".prototools"
[settings]
# Disable all
builtin-plugins = false
# Enable some
builtin-plugins = ["node", "bun"]
```

## Pin proto itself

proto has yet to reach an official v1 release, as we're constantly fine-tuning and reworking APIs.
Because of this, we may accidentally introduce unexpected changes, or introduce breaking changes
that you were relying on. To help mitigate these issues, you can now
[pin the version of proto itself](/docs/proto/config#lock-proto-version) in `.prototools`.

```toml title=".prototools"
proto = "0.39.0"
```

When this pin exists, all proto shims will attempt to execute proto using that exact version. This
allows for the global `proto` binary to differ in version from what is executed.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.39.0) for a full list
of changes.

- Added `PROTO_NO_MODIFY_PROFILE` and `PROTO_NO_MODIFY_PATH` environment variables to `proto setup`
  (for automated workflows).
- Updated `proto status` to display and include versions from ecosystem files (`.nvmrc`, etc).
- Updated `github://` plugin locators to support monorepos. Append the project name (that tags are
  prefixed with) to the path: `github://moonrepo/plugins/node_tool`

---

## proto v0.40 - Config mode, progress bars, and more

import Image from '@site/src/components/Image';

This is a small release that includes many quality of life improvements.

## New `--config-mode` global option

When proto is ran, we find and load all applicable [`.prototools` files](/docs/proto/config). For
the most part, we would traverse upwards, and sometimes load `~/.proto/.prototools`, while other
times not. It was quite confusing when certain config files were loaded. This was further
exacerbated by the `--include-global` and `--only-local` options, which were only available to some
commands (and have been removed entirely).

To remedy and standardize this, we're introducing a new global option
[`--config-mode`](/docs/proto/config#resolution-mode) (`-c`), which controls how configuration are
loaded. This option supports the following values.

- `global` - Only load `~/.proto/.prototools`.
- `local` - Only load `./.prototools` in the current directory.
- `upwards` - Load `.prototools` while traversing upwards, but do not load `~/.proto/.prototools`.
- `upwards-global` / `all` - Load `.prototools` while traversing upwards, and do load
  `~/.proto/.prototools`.

Now what is the default mode? As mentioned above, we wanted to standardize the default across all
commands, but the problem is, is that each command has different requirements. So in the end, the
default mode is actually 2 different modes depending on the command being ran, which is:

- For `activate`, `install`, `outdated`, `status` commands -> `upwards` mode
- All other commands -> `upwards-global` mode

## Improved progress bars

We've improved (or added) the progress bars for [`proto install`](/docs/proto/commands/install),
[`proto upgrade`](/docs/proto/commands/upgrade), and the auto-install flow for
[`proto run`](/docs/proto/commands/run). The progress bars will now display the current phase
(download, unpack, etc), and the download phase will now include current / total downloaded bytes.

Furthermore, when installing multiple tools, we now display a progress bar for each tool.

## Improved HTTP requests

For historical context, requests made from the proto CLI itself use a different HTTP client than
requests made from a WASM plugin. The reason for this is that the Rust-based HTTP client that proto
uses is not compatible within WASM, so plugins use a different library. This disconnect meant that
WASM requests did _not_ inherit the [`[settings.http]`](/docs/proto/config#settingshttp) settings,
which meant in some cases, requests would fail or not authenticate correctly, and there was no
work-around.

This is a very tricky problem to solve, but we have implemented a possible solution through a
concept known as [host functions](/docs/guides/wasm-plugins#host-functions--macros). Host functions
are basically functions that exist on the host machine (proto), and can be called from the guest
runtime (WASM). This new host function utilizes the same HTTP client as proto to make requests,
which results in WASM no longer being disconnected.

However, since there is a cost for calling host functions from the guest, and then serializing the
response from the host back to the guest, there is a small chance that performance will be affected.
We will continue to monitor the implementation, so please report any issues!

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.40.0) for a full list
of changes.

- Removed `--include-global` and `--only-local` flags from all applicable commands. Use the new
  `--config-mode` instead.

---

## moon v1.28 - Task presets, OS tasks, meta tokens, and more

In this release, we've focused on developer experience and quality-of-life improvements.

## New task presets

For the longest time, moon has supported the [`local`](/docs/config/project#local) setting for
tasks. This setting was added early on to reduce the amount of options configuration necessary for
tasks that "should only run locally". However, after years of supporting this setting, we've
discovered a few short-comings with it:

- The name is confusing. It's not apparent what "local" really means for newcomers.
- This setting also changes non-local related options, like `persistent` and `cache`, which isn't
  apparent to the user.
- Setting the value to `false` doesn't inverse the options values. For example, enabling `runInCI`.

At this point we thought to ourselves "how can we improve this experience?". Instead of reworking
`local`, we've opted to introduce a new task setting called [`preset`](/docs/config/project#preset),
which configures a collection of task options, and deprecate the `local` setting. Presets are a much
better pattern, as it allows us to support multiple presets, and uniquely name our presets. For
example, old `local` tasks can be rewritten as such:

```yaml title="moon.yml"
# Before
tasks:
  start:
    command: 'vite dev'
    local: true

# After
tasks:
  start:
    command: 'vite dev'
    preset: 'server'
```

To start, we're introducing 2 presets: `server` and `watcher`. Check out the
[documentation for more information](/docs/config/project#preset) on what these presets configure!
If you have ideas for other presets, we would love to hear them.

## New OS specific tasks

When moon was originally designed, it was meant to be a very simple but easily configurable task
runner. But since then, moon has grown drastically, and so has the requirements of its users. One
such request was being able to define tasks that only run for certain operating systems.

This wasn't possible before; but is now thanks to the new
[`os` task option](/docs/config/project#os). This option can be configured with "linux", "macos", or
"windows" to target those specific systems, and can be a single value, or list of values.

```yaml title="moon.yml"
tasks:
  build-linux:
    command: 'cargo build --target x86_64-unknown-linux-gnu'
    options:
      os: 'linux'
  build-macos:
    command: 'cargo build --target x86_64-apple-darwin'
    options:
      os: 'macos'
  build-windows:
    command: 'cargo build --target x86_64-pc-windows-msvc'
    options:
      os: 'windows'
```

When a task is ran on a non-compatible system, it will be converted to a no-operation task, so that
dependency chains still resolve correctly.

> In the future, we will look into supporting system architecture as well.

## New `@meta` token function

In our last release, we introduced the [`project.metadata`](/docs/config/project#metadata-1) setting
as a means for consumers to define their own metadata. This is great but it provided no other
benefit, as it required consumers to open up config files to discover this metadata, or consumers to
write custom abstractions/tooling. We want to improve the integration of this information within
moon, so to start, we're introducing a new token function [`@meta(key)`](/docs/concepts/token#meta).

The [`@meta(key)`](/docs/concepts/token#meta) token function can be used to access project metadata
from both the [`project`](/docs/config/project#project) and
[`project.metadata`](/docs/config/project#metadata-1) settings. The former values will be used
as-is, while the latter values will be JSON stringified (since consumers can define anything).

With this new token, our task composition has grown even deeper. For example, you can define a task
at the top-level that a project inherits, and then define metadata within that project for the task!
With that said, this is more of a stopgap solution until we support true variables within
configuration.

```yaml title=".moon/tasks.yml"
tasks:
  build:
    script: 'compile --label @meta(name) --compress @meta(compression)'
```

```yaml title="/moon.yml"
project:
  name: 'example'
  metadata:
    compression: 9
```

And lastly, while we're on the topic of tokens, we're also introducing `$projectName`,
`$projectChannel`, and `$projectOwner` token variables, as an easier alternative solution.

## New `disallowRunInCiMismatch` experiment

Have you ever ran [`moon ci`](/docs/commands/ci) in CI and encountered a scenario where tasks that
_should_ have run didn't run? Or the dependency of a task never runs causing the dependent to fail?
If so, this may apply to you!

This scenario is most likely caused by an invalid relationship where the dependent is
[`runInCI`](/docs/config/project#runinci) enabled, but the dependency is
[`runInCI`](/docs/config/project#runinci) disabled. For example:

```yml title="moon.yml"
tasks:
  build:
    # ...
    options:
      runInCI: false

  analyze:
    # ...
    deps: ['build']
    options:
      runInCI: true
```

Because `build` is disabled, its outputs may not be created. Additionally, if `build` is affected by
touched files, the `analyze` task will not run automatically unless it was also affected. We try our
best to accommodate these scenarios and "detect" when things should run or not, but it's fallible,
as there's many ways that tasks can relate to each other.

To try and remedy this going forward, we're introducing the new `disallowRunInCiMismatch` experiment
that will _hard error_ if an invalid relationship is configured. We want to try and capture how
often users are configuring this, whether intentionally or accidentally. If the error becomes a
blocker, the experiment can be disabled as so:

```yaml title=".moon/workspace.yml"
experiments:
  disallowRunInCiMismatch: false
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.28.0) for a full list
of changes.

- We've sunset the CI insights feature in moonbase. We will no longer be tracking CI run history.
  This is a retroactive change that applies to all moon versions.
- Added `codeowners.requiredApprovals` setting to `.moon/workspace.yml`, that will apply
  requirements to all paths.
- Updated the terminal checkpoint (4 squares) colors to better reflect their state.
- Updated `MOON_TOOLCHAIN_FORCE_GLOBALS` to support filtering by tool IDs, instead of applying to
  everything.

---

## moon v1.29 - Improved affected tracking, experimental Pkl configuration, and more

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this release, we're excited to introduce an improved affected tracker and a new (but
experimental) configuration format!

## New affected projects tracker

We've received a lot of feedback that our affected projects and tasks logic works differently across
commands, or that it's hard to understand why something is affected or not affected. We wanted to
add more clarity around affected projects, so have implemented a new affected tracker.

This new tracker includes a ton of new logging that we believe will answer the "why". For example,
once the tracker has finished tracking, we'll log all affected projects and tasks, and what marked
their affected state.

```shell
[DEBUG] moon_affected::affected_tracker  Project website is affected by  files=["website/blog/2024-10-01_moon-v1.29.mdx"] upstream=[] downstream=[] other=false
[DEBUG] moon_affected::affected_tracker  Project runtime is affected by files=[] upstream=[] downstream=["website"] other=false
[DEBUG] moon_affected::affected_tracker  Project types is affected by  files=[] upstream=[] downstream=["website", "runtime"] other=false
[DEBUG] moon_affected::affected_tracker  Task runtime:build is affected by  env=[] files=[] upstream=[] downstream=["website:start", "website:build"] other=false
[DEBUG] moon_affected::affected_tracker  Task website:start is affected by  env=[] files=["website/blog/2024-10-01_moon-v1.29.mdx"] upstream=[] downstream=[] other=false
[DEBUG] moon_affected::affected_tracker  Task types:build is affected by  env=[] files=[] upstream=[] downstream=["website:start", "runtime:build", "website:build"] other=false
[DEBUG] moon_affected::affected_tracker  Task website:build is affected by  env=[] files=["website/blog/2024-10-01_moon-v1.29.mdx"] upstream=[] downstream=[] other=false
```

What marks an affected state is based on one or many of the following:

- By touched files
- By environment variables (task only)
- By upstream dependencies
- By downstream dependents (project only)
- And other minor internal logic

This information is also included in the run report at `.moon/cache/runReport.json`, under the
`context.affected` property. An example of this looks like:

```json
{
  "projects": {
    "website": {
      "files": ["website/blog/2024-10-01_moon-v1.29.mdx"],
      "other": true
    },
    "runtime": {
      "downstream": ["website"],
      "other": true
    },
    "types": {
      "downstream": ["website", "runtime"],
      "other": true
    }
  },
  "tasks": {
    "website:build": {
      "files": ["website/blog/2024-10-01_moon-v1.29.mdx"],
      "other": false
    },
    "types:build": {
      "downstream": ["website:build"],
      "other": false
    },
    "runtime:build": {
      "downstream": ["website:build"],
      "other": false
    }
  }
}
```

### Control upstream / downstream depth

With this new tracker, we now have the ability to control the traversal depth for upstream
dependencies and downstream dependents in `moon query projects`, via the `--upstream` and
`--downstream` options respectively (the `--dependents` option is now deprecated).

These options support the following values:

- `none` - Do not traverse deps.
- `direct` - Traverse direct parent/child deps.
- `deep` - Traverse full hierarchy deps.

```shell
$ moon query projects --affected --upstream none --downstream deep
```

### What about tasks?

We have the existing affected logic that has powered moon for years, and have updated that to
include the new logging. However, it's not perfect and we want to improve it.

To support this overall enhancement for tasks, we need to support a task graph, which we currently
do not. We only have a project graph (which has tasks), and an action graph (which has more than
tasks). In a future release, we'll introduce a new task graph that will fill the gaps.

## Experimental support for Pkl based configuration

Pkl, what is that? If you haven't heard of Pkl yet,
[Pkl is a programmable configuration format by Apple](https://pkl-lang.org/). But what about YAML?
YAML has served us well since the beginning, but we're not happy with YAML. It's better than JSON,
TOML, and XML, but still has its downsides. We want something better, something that meets the
following requirements:

- Is easy to read and write.
- Is dynamic and programmable (loops, variables, etc).
- Has type-safety or built-in schema support.
- Has Rust serde integration.

The primary requirement that we are hoping to achieve is adopting a configuration format that is
_programmable_. We want something that has native support for variables, loops, conditions, and
more, so that you could curate and compose your configuration very easily. Hacking this
functionality into YAML is a terrible user experience in our opinion!

And with all that said, I'm sure you're curious what Pkl actually looks like in practice. Here's a
few examples (unfortunately no syntax highlighting)!

```pkl
type = "application"
language = "typescript"
dependsOn = List("client", "ui")

tasks {
  ["build"] {
    command = "docusaurus build"
    deps = List("^:build")
    outputs = List("build")
    options {
      interactive = true
      retryCount = 3
    }
  }
  ["typecheck"] {
    command = "tsc --build"
    inputs = new Listing {
      "@globs(sources)"
      "@globs(tests)"
      "tsconfig.json"
      "/tsconfig.options.json"
    }
  }
}
```

```pkl
projects {
  globs = List("apps/*", "packages/*")
  sources {
    ["root"] = "."
  }
}

vcs {
  defaultBranch = "master"
}
```

```pkl
node {
  version = "20.15.0"
  packageManager = "yarn"
  yarn {
    version = "4.3.1"
  }
  addEnginesConstraint = false
  inferTasksFromScripts = false
}
```

Pretty straight forward for the most part! Lists/Listings (arrays) are a bit different than what you
may be used to, but they're super easy to learn.

### Advanced examples

I've talked a lot about programmable configs, but what exactly does that look like? Let's go through
a few examples. Say you are building a Rust crate and you need a build task for each operating
system. In YAML you would need to define each of these manually, but with Pkl, you can build it with
a loop!

```pkl
tasks {
  for (_os in List("linux", "macos", "windows")) {
    ["build-\(_os)"] {
      command = "cargo"
      args = List(
        "--target",
        if (_os == "linux") "x86_64-unknown-linux-gnu"
          else if (_os == "macos") "x86_64-apple-darwin"
          else "i686-pc-windows-msvc",
        "--verbose"
      )
      options {
        os = _os
      }
    }
  }
}
```

Or maybe you want to share inputs across multiple tasks. This can be achieved with `local`
variables.

```pkl
local _sharedInputs = List("src/**/*")

tasks {
  ["test"] {
    // ...
    inputs = List("tests/**/*") + _sharedInputs
  }
  ["lint"] {
    // ...
    inputs = List("**/*.graphql") + _sharedInputs
  }
}
```

Pretty awesome right? This is just a taste of what Pkl has to offer! We highly suggest reading the
[language reference](https://pkl-lang.org/main/current/language-reference/index.html), the
[standard library](https://pkl-lang.org/main/current/standard-library.html), or looking at our
[example configurations](https://github.com/moonrepo/moon/tree/master/crates/config/tests/__fixtures__/pkl)
while testing Pkl.

> In the future, if Pkl seems like the right fit, we plan to take full advantage of what it has to
> offer, by creating our own Pkl projects, modules, and types!

### Caveats and restrictions

Since this is an entirely new configuration format that is quite dynamic compared to YAML, there are
some key differences to be aware of!

- Each `.pkl` file is evaluated in isolation (loops are processed, variables assigned, etc). This
  means that task inheritance and file merging cannot extend or infer this native functionality.

- `default` is a
  [special feature](https://pkl-lang.org/main/current/language-reference/index.html#default-element)
  in Pkl and cannot be used as a setting name. This only applies to
  [`template.yml`](/docs/config/template#default), but can be worked around by using `defaultValue`
  instead.

```pkl title="template.yml"
variables {
  ["age"] {
    type = "number"
    prompt = "Age?"
    defaultValue = 0
}
```

- `local` is also a reserved word in Pkl. It can be worked around by escaping it with backticks, or
  you can simply use the [`preset` setting](/docs/config/project#preset) instead.

```pkl
tasks {
  ["example"] {
    `local` = true
    # Or
    preset = "server"
  }
}
```

- Only files are supported. Cannot use or extend from URLs.

### How to use Pkl?

As mentioned in the heading, Pkl support is experimental, and _is not_ enabled by default. If you're
interested in trying out Pkl, you can with the following:

- [Install `pkl` onto `PATH`](https://pkl-lang.org/main/current/pkl-cli/index.html#installation).
  Pkl uses a client-server communication model.
  - Can also be installed with proto:
    `proto plugin add pkl https://raw.githubusercontent.com/milesj/proto-plugins/refs/heads/master/pkl.toml`
- Use the `.pkl` file extension instead of `.yml`.
- Pass the `--experimentPklConfig` CLI option, or set the `MOON_EXPERIMENT_PKL_CONFIG` environment
  variable.

```shell
$ moon check --all --experimentPklConfig
# Or
$ MOON_EXPERIMENT_PKL_CONFIG=true moon check --all
```

> Pkl can be used alongside YAML with no issues! We'll merge, inherit, and compose as usual.

### What about X instead?

There are a handful of other interesting or popular programmable configurations out there, so why
isn't moon experimenting with those? The answer is, we may! Just so long as they meet the
requirements. With that said, we do have some opinions below:

- [Starlark/Skylark](https://github.com/bazelbuild/starlark/) - On our list to evaluate.
- [Nickel](https://nickel-lang.org), [Jsonnet](https://jsonnet.org) - On our list to evaluate, but
  not a fan of the JSON-like syntax.
- [Dhall](https://dhall-lang.org) - While this meets most of our requirements, the syntax isn't as
  readable or user-friendly as we'd like.
- [CUE](https://cuelang.org/) - No Rust support, so unlikely. It also works quite differently than
  the other tools.
- [KCL](https://www.kcl-lang.io/) - Nice syntax and meets the requirements, but no Rust support.

If there's another format you think we should investigate, drop us a line in Discord!

## Looking for contributors!

Are you a fan of moon (or proto)? Interested in learning Rust or writing more Rust? Want to
contribute to an awesome project (we think so)? Well it just so happens that we are looking for
active contributors!

We have a very long roadmap of features we would like to implement, but do not have enough time or
resources to implement them in the timeframe we would like. These features range from very small
(low hanging fruit) to very large (and quite complex).

If this sounds like something you may be interested in, post a message in Discord and let us know!
Only a few hours a week commitment is good enough for us.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.29.0) for a full list
of changes.

- Added a new task option, `cacheLifetime`, that controls how long a task will be cached for.
- Added a new task merge strategy, `preserve`, that preserves the original inherited value.
- Added a new setting `vcs.hookFormat` to `.moon/workspace.yml`, that can customize the shell/file
  format for hooks.
- Updated task `outputs` to support token and environment variables.
- Updated `moon query projects` to include the project description as a trailing value.
- Updated `moon query tasks` to include the task type and platform, and the task description as a
  trailing value.

---

## proto v0.42 - New bin linking, JSON/YAML plugins, and more

import NonWasmTabs from '@site/src/components/NonWasmTabs';

Happy Halloween 🎃! In this release, we have a new bin linking strategy, and more schema plugin
formats.

## New bin linking strategy

Early on in proto's development, we added `~/.proto/bin` symlink support for installed tools, but
chose to base it on the versions globally pinned in `~/.proto/.prototools`. We opted for this
approach as there wasn't a better solution at the time, and we merely wanted an alternative to
shims. Since then, bin linking has become an after-thought.

However, a suggestion from [@meop](https://github.com/meop) sparked a great idea for the future of
bin linking. Instead of symlinking bins based on versions pinned in `~/.proto/.prototools`, bins are
now symlinked based on all of the versions installed, but grouped according to version ranges. The
main binary will always point to the highest installed version, while we also create binaries for
the highest major, and highest major + minor combinations.

For example, for Node.js (`node`), we may have the following:

- `~/.proto/bin/node` - Points to the highest version.
- `~/.proto/bin/node-` - Points to the highest version within that major range (`~major`). Is
  created for each separate major version, for example: `node-20`, `node-22`.
- `~/.proto/bin/node-.` - Points to the highest version within that major + minor
  range (`~major.minor`). Is created for each separate major + minor version, for example:
  `node-20.1`, `node-22.4`.
- `~/.proto/bin/node-canary` - Points to a canary install, if it exists.

Thanks to this approach, you could easily execute commands with specific versions of a tool,
_without_ having to set environment variables, update configurations, or force overrides. Just
execute the binary directly!

```shell
$ node --version && which node
23.1.0
~/.proto/bin/node -> ~/.proto/tools/node/23.1.0/bin/node

$ node-22 --version && which node-22
22.5.1
~/.proto/bin/node-22 -> ~/.proto/tools/node/22.5.1/bin/node
```

> This change is not retroactive and will slowly be applied tool-by-tool when it is installed. To
> force relinking of all binaries, you can use `proto regen --bin` after upgrading.

## Support for JSON and YAML based plugins

Support for TOML based plugins, an alternative to WASM based plugins, was integrated in proto v0.7;
which is 35 versions ago! Since then, we've had great success with TOML plugins, as they represent
about 97% of all plugins in the registry. The other 3% is WASM of course.

However, TOML is a configuration format that is quite unknown outside of the Rust ecosystem, and has
a bit of a learning curve for new users. To ease the plugin authoring process, we now support JSON
and YAML based plugins! To demonstrate this, here's our official moon plugin in all 3 formats:

> JSON and YAML use camelCase keys, while TOML uses kebab-case.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.42.0) for a full list
of changes.

- Each tool's primary executable file name is no longer based on the plugin's identifier, and is now
  based on what's configured in the new `LocateExecutablesOutput.exes` setting.
- We now cache all text-based HTTP requests made from WASM plugins for 12 hours. This should greatly
  reduce the overhead cost of making requests, and will help for situations where an internet
  connection is lost.

---

## moon v1.30 - Python support, self-hosted remote caching, task graph, and more!

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

It's been almost 2 months since our last release, and we're excited to announce some major features
requested by the community!

## Experimental Python tier 2 and 3 support

Thanks to a contribution from [@harlequin](https://github.com/harlequin), we now provide Python tier
[2](/docs/how-it-works/languages#tier-2--platform) and
[3](/docs/how-it-works/languages#tier-3--toolchain) support. Python is a very popular language, so
it was about time that we officially supported it in some capacity. When enabling Python in moon,
the following functionality will be enabled:

- Will download and install Python into the toolchain (if `python.version` is defined).
- Will parse `requirements.txt` to extract dependency and version information for hashing.
- Will automatically activate virtual environments and setup `PATH` for tasks.
- Will automatically install dependencies for `requirements.txt` via pip.
- And a handful of internal interoperability features.

However, we're still marking this implementation as experimental, as it hasn't been thoroughly
tested, and we're not 100% positive the workflows are what users expect. So please provide any
feedback, good or bad!

Furthermore, as mentioned above, we install dependencies with pip (the version of pip that comes
pre-installed with the current Python version). At this time, _we do not support_ other package
managers like Poetry, Hatch, PDM, Rye, or uv, but we will in the future!

### New `python` configurations

Languages in
[moon are enabled through configuration](/docs/how-it-works/languages#enabling-a-language) blocks in
[`.moon/toolchain.yml`](/docs/config/toolchain), and Python is no different. We now support a
[`python`](/docs/config/toolchain#python) toolchain setting
([view all available settings](/docs/config/toolchain)).

```yaml title=".moon/toolchain.yml"
python:
  version: '3.14.0'
```

When the `python` setting is defined, it will enable the language and
[deep platform integration](/docs/how-it-works/languages#tier-2--platform), and when the
`python.version` field is defined, it will further enable
[toolchain support](/docs/how-it-works/languages#tier-3--toolchain). Both of these features provide
heavy automation, improving the overall developer experience.

This is fantastic, but what if another Python project in the monorepo requires a different toolchain
channel/version? If so, they can use the new [`toolchain.python`](/docs/config/project#python)
setting in [`moon.yml`](/docs/config/project) to define project-level overrides.

```yaml title="/moon.yml"
toolchain:
  python:
    version: '3.12.0'
```

### Built-in virtual environments

Of course we also have support for Python virtual environments. When running a task, moon will
automatically enable the virtual environment in the workspace root or a project root (depending on
config)! The name of the venv can be customized with the
[`python.venvName`](/docs/config/toolchain#venvname) setting, otherwise it defaults to `.venv`.

```yaml title=".moon/toolchain.yml"
python:
  venvName: '.venvcustom'
```

## Unstable self-hosted remote caching

This has been a request from the community for a very long time, and we get it, not every user wants
to store their build artifacts (not source code) in a third-party cloud provider. While we're proud
of our [moonbase service](/moonbase), it wasn't a viable option for many companies because of their
proprietary requirements. We spent a few months reworking moonbase to work as a self-hosted service,
so users can host it as on-prem solution, but it has been a very costly initiative. During this
process, we came to the conclusion that spending our time and resources on moonbase simply isn't
worth it, so we made the hard decision to sunset moonbase in the future.

So what does that mean for remote caching? Simply put, you can now host your own remote caching
service! Instead of building a custom API for consumers to implement, we opted to implement the
[Bazel Remote Execution API](https://github.com/bazelbuild/remote-apis/blob/main/build/bazel/remote/execution/v2/remote_execution.proto),
which supports a content addressable storage (CAS) API, and is used by other popular build tools,
like Bazel, Buck, Pants, and more!

Because we opted for a community solution, we can now focus all our efforts on [moon](/moon) and
[proto](/proto)! Additionally, adopting RE API allows you, the user, to use an off-the-shelf
solution, like [`bazel-remote`](https://github.com/buchgr/bazel-remote), instead of building your
own custom caching server! For example, to make use of remote caching, simply serve `bazel-remote`:

```shell
bazel-remote --dir /path/to/moon-cache --max_size 10 --storage_mode uncompressed --grpc_address 0.0.0.0:9092
```

And then configure the new [`unstable_remote`](/docs/config/workspace#unstable_remote) setting in
[`.moon/workspace.yml`](/docs/config/workspace).

```yaml title=".moon/workspace.yml"
unstable_remote:
  host: 'grpc://your-host.com:9092'
```

Pretty awesome right? Jump to the
[official remote caching](/docs/guides/remote-cache#self-hosted-unstable) documentation for more
information on this implementation.

### Unsupported features

Since this is a new feature, we're marking it as unstable, as it hasn't been thoroughly tested, and
_does not_ support the entire Bazel RE API. The following features _have not_ been implemented, but
will be in the future.

- HTTP(S) host (we only support gRPC(S))
- Digest hashing functions besides SHA256
- Compression formats (we only support identity/uncompressed right now)
- Write/read bytestream for large blobs (4mb is the current limit)
- Better TLS/mTLS support (it has some issues)
- Directory blob types

## New task graph and improved affected tracker

In our [last release](./moon-v1.29#new-affected-projects-tracker), we announced a new affected
tracker for projects, but _not_ for tasks. The reason behind this was simple, we couldn't! Up until
now, we had no concept of a task graph, we had a project graph (that had tasks) and an action graph
(that ran tasks), but the relationships between tasks were split across both of these graphs.

This made it complicated to support tasks for the new affected tracker, as the action graph
_consumes_ the tracker, not the other way around. To remedy this issue, we now support an official
task graph, which is derived from the project graph, and then feeds into the action graph. Since the
task graph sits outside of the action graph, we're now able to support tasks in the affected
tracker!

Because of the new task graph, the following improvements have been introduced:

- Tasks are now supported in the affected tracker (as mentioned).
- We can now properly query dependencies and dependents of specific tasks.
- We can now associate types to relationships (graph edges). For example, in the future we can add
  optional, cleanup, and other kinds of dependencies.
- We've added a new command, [`moon task-graph`](/docs/commands/task-graph), that can visualize
  tasks in isolation.
- We've updated the [`moon query tasks`](/docs/commands/query/tasks) to derive information from the
  task graph.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.30.0) for a full list
of changes.

- Added basic support for Git submodules, and will now extract touched files from all submodules.
- Added 7 new token variables: `$arch`, `$os`, `$osFamily`, `$vcsBranch`, `$vcsRepository`,
  `$vcsRevision`, `$workingDir`
- Added a `rust.binstallVersion` setting to `.moon/toolchain.yml`.
- Updated Pkl configurations to support `read()` for environment variables.

---

## proto v0.44 - New terminal user interface and versions command

import Image from '@site/src/components/Image';

Merry Christmas and happy holidays 🎄! In this release, we're introducing a new terminal user
interface.

## New terminal output

We're excited to introduce new terminal outputs, also known as a terminal user interface (TUI), for
all commands! We stumbled upon the [iocraft](https://docs.rs/iocraft/latest/iocraft/) Rust crate,
which is a library for rendering terminal output using components and JSX-like syntax. As fans of
[React](https://react.dev/) and [Ink](https://github.com/vadimdemedes/ink), this felt like the
perfect opportunity to revisit all of our commands and implement a new interface unique to proto
(and moon in the future).

Here are some examples of this new output. A lot of it is still a work in progress and will be
tweaked going forward, but we're already impressed with what iocraft can achieve!

### Notices

### Information

### Tables

### Prompts

### Progress

## New `proto versions` command

After much feedback, we've decided to merge the `proto list` and `proto list-remote` commands into a
new command, [`proto versions`](/docs/proto/commands/versions). This command will list all versions
available for the provided tool, while also annotating which of those versions has been installed
locally.

This data can now be accessed as JSON by passing the `--json` flag.

```shel
$ proto versions node
...
22.0.0
22.1.0
22.2.0
22.3.0
22.4.0
22.4.1
22.5.0
22.5.1
22.6.0
22.7.0
22.8.0
22.9.0
22.10.0
22.11.0
22.12.0
23.0.0
23.1.0
23.2.0
23.3.0
23.4.0 - installed 12/19/24
23.5.0 - installed 12/25/24
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.44.0) for a full list
of changes.

- Added a `--yes` option to `proto outdated`, that skips confirmation prompts.
- Added a `--json` option to `proto clean`, to capture the cleaned result as JSON.
- Updated `proto clean` to accept a target in which to clean as the 1st argument. For example,
  `proto clean cache`.
- Moved the `--json` and `--yes` options into global options.

---

## moon v1.31 - Toolchain progress, glob-based targets, task & remote cache improvements

Happy new years everyone 🎉! In this release, we've landed a handful of quality-of-life
improvements.

## Goodbye platform, hello toolchain

In preparation for toolchain WASM plugins, we've had to rewrite and rethink a lot of the internals
of moon. Once such feature is the concept of a "platform", which is primarily interacted with
through a task's [`platform`](/docs/config/project#platform-1) setting or a project's
[`platform`](/docs/config/project#platform) setting.

We do our best to detect the language and runtime (the "platform") that a project or task belongs
to. This is important as it determines what tools to install, paths to include in `PATH`, and much
more. However, there are situations where our detection fails, or you need to be explicit, so the
`platform` settings exist.

The new toolchain system is much more powerful, but it works quite differently, so we're slowly
making changes within each release before flipping the switch. In this release, we are deprecating
the concept of the platform, and renaming everything to toolchain. The following changes were made:

- Deprecated the top-level `platform` setting in `moon.yml`, use `toolchain.default` instead.
  - Additionally, the toolchain can now be inferred from the top-level `language` setting and any
    config files in the project/workspace root. This pattern is preferred when possible.
- Deprecated the `platform` task setting, use `toolchain` instead.
- Deprecated the `taskPlatform` query field, use `taskToolchain` instead.
- Deprecated the `--platform` option for `moon query tasks`, use `--toolchain` instead.
- Deprecated the `$taskPlatform` token, use `$taskToolchain` instead.

:::warning

On the surface these two features look the same, but internally they are quite different. We've done
our best to support backwards compatibility, but there may be some edge cases that our testing suite
did not cover. If you run into any problems, mainly tasks being associated with the wrong toolchain,
please report an issue!

:::

## Run tasks using glob-based targets

This has been a request from the community for sometime, as it fills a gap that running multiple
tasks with a non-project scope, or running tasks with a query, simply couldn't achieve. For example,
say you had `build-debug` and `build-release` tasks, and wanted to future-proof it for potential new
build related tasks.

Before this release, you would need to explicitly list all targets in
[`moon run`](/docs/commands/run) or [`moon ci`](/docs/commands/ci), but with globs, you can achieve
the same affect with 1 glob target.

```shell
# Before
$ moon run :build-debug :build-release

# After
$ moon run ':build-*'
```

Furthermore, glob syntax can also be applied to the project scope, allowing you to filter the target
instead of applying to all projects.

```shell
$ moon run '*-{app,lib}:build-*'
```

Because these glob targets are real globs, they support all the
[same syntax](/docs/concepts/file-pattern#globs) as other glob related functionality, but we suggest
keeping it simple and sticking to `*`, `[]`, and `{}`.

:::info

Be sure to quote targets that contain glob syntax, otherwise your shell native glob expansion may
trigger instead, or your shell may fail with an error.

:::

## Task improvements

We also spent some time improving the ergonomics of tasks, our most important feature.

### Inferring inputs

Up until now, you had to explicitly configure the [`inputs`](/docs/config/project#inputs) of a task.
This can be very tedious, so we're looking into ways to automate this. The first is through a new
feature we are calling "inferring inputs from task parameters", where we automatically include
inputs from any file group token functions and substituted environment variables, found within
`command`, `script`, `args`, or `env`.

To demonstate this, here's a task that utilizes file group tokens in previous releases.

```yaml title="moon.yml"
tasks:
  lint:
    command: 'lint @group(sources) @group(tests)'
    inputs:
      - '@group(sources)'
      - '@group(tests)'
```

As you can immediately tell, there's a fair bit of duplication here. Going forward, the tokens found
within `inputs` can be omitted, as we can infer that the files defined in the `sources` and `tests`
file groups should be inputs. The task above can simply be rewritten as.

```yaml title="moon.yml"
tasks:
  lint:
    command: 'lint @group(sources) @group(tests)'
```

Useful right? However, if you do _not_ want this functionality, you can disable it with the new task
option [`inferInputs`](/docs/config/project#inferinputs) (which is enabled by default).

```yaml title="moon.yml"
tasks:
  lint:
    # ...
    options:
      inferInputs: false
```

### Always run in CI

The [`runInCI`](/docs/config/project#runinci) task option pairs nicely with the `moon ci` command,
as it does most of the heavy lifting in determining what tasks to run based on affected/touched
files. However, there are sometimes situations where a task should _always_ run in CI, regardless of
whether it was affected or not.

This isn't currently possible in moon, until now! We've updated the `runInCI` option to support a
new value, "always", which will always run the task in CI!

```yaml title="moon.yml"
tasks:
  build:
    # ...
    options:
      runInCI: 'always'
```

## Remote cache improvements

In our last release, v1.30, we released
[unstable support for self-hosted remote caching](./moon-v1.30#unstable-self-hosted-remote-caching).
While still unstable in this release, we've landed more improvements.

### Zstandard compression

We've added a new setting,
[`unstable_remote.cache.compression`](/docs/config/workspace#compression), that defines a
compression format to use when uploading and downloading blobs. At this time, we only support `zstd`
as an option, which is _not_ enabled by default.

```yaml title=".moon/workspace.yml"
unstable_remote:
  cache:
    compression: 'zstd'
```

If you're using `bazel-remote` as your cache server, you'll also need to run it with zstandard
enabled.

```shell
$ bazel-remote --dir /path/to/moon-cache --max_size 10 --storage_mode zstd --grpc_address 0.0.0.0:9092
```

### Symlinking on Windows

In the previous release, if we encountered an output blob that should be created as a symlink, we
would simply copy the file contents on Windows when restoring instead of symlinking. On Unix, these
outputs were symlinked correctly.

The reason for this, is that symlinks require
[privileged access on Windows](https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-10/security/threat-protection/security-policy-settings/create-symbolic-links)
to function correctly. We felt that abiding the REAPI specification was more important than the
privileged access requirement, so if you're on Windows, be sure to allow/enable symlinks on each
machine.

### Sunsetting moonbase

Since we're migrating to and advocating for the self-hosted remote caching solution, we will be
sunsetting our [moonbase](/moonbase) product hosted at https://moonrepo.app on March 31st. All
active subscriptions will be cancelled at the end of February, but caching will continue to work,
albeit at the unpaid plan limits. We suggest migrating to the self-hosted solution before then!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.31.0) for a full list
of changes.

- Added glob support (and `glob://`) to `generator.templates` in `.moon/workspace.yml`, allowing you
  to glob for your codegen template locations.
- Added a `--filter` option to `moon templates`.
- Updated the `extends` setting in `.moon/workspace.yml`, `toolchain.yml`, and `tasks.yml`, to
  support a list of files/URLs to extend.
- Updated toolchain dependency installs to retry up to 3 attempts if the install command fails.
- Improved the task output prefixing logic.

---

## proto v0.45 - New built-in tools and build from source

import Image from '@site/src/components/Image';

In this release, we're very excited to introduce building tools from source, a feature that's been
in development for over a year.

## New built-in tools

It's been quite some time since we've introduced a new official built-in tool, so in this release,
we have 3!

### `moon`

This was a no-brainer, and honestly, we probably should have done it much sooner. We were quite
surprised to see that moon is the 3rd most installed tool in proto, right behind pnpm and node
respectively. We felt that it was now time to make it official.

```shell
$ proto install moon
```

If you were using the moon TOML plugin before (below), you can now remove this entry from your
`.prototools`.

```toml title=".prototools"
[plugins]
moon = "https://raw.githubusercontent.com/moonrepo/moon/master/proto-plugin.toml"
```

### `uv`

Additionally, Python interest has grown over recent months, especially with the introduction of
[Python support in moon](./moon-v1.30), so we felt it was time to support the new hotness,
[uv](https://docs.astral.sh/uv/)! We plan to bring uv integration into moon in the near future.

```shell
$ proto install uv
```

:::info

Although uv can also manage Python installations, we suggest using proto to keep everything
streamlined and isolated.

:::

### `ruby`

And lastly, we now support [Ruby](https://www.ruby-lang.org/en/), a popular general purpose
programming language. Ruby was extremely difficult to support, primarily because Ruby does _not_
support the concept of pre-builts, and _must_ be compiled from source files.

But thanks to our new build from source install strategy (below), Ruby support is now possible.

```shell
$ proto install ruby
```

## Build from source (unstable)

Up until now, tools could only be installed if they supported pre-built binaries, which was
typically more than enough. However, there are many languages that do not support pre-builts and
must be built from source, such as Ruby, PHP, and up until recently, Python. Building binaries from
source code is actually quite complicated, as the instructions for doing so is different across
operating systems, architectures, and even system package managers.

Regardless, we've spent the past year slowly working on a solution and have finally managed to
implement something usable, all through a powerful WASM API. And with that, the following tools now
support build from source.

- `deno`
- `go`
- `moon`
- `node`
- `python` (via `python-build`)
- `ruby` (via `ruby-build`)

To actually build from source instead of downloading a prebuilt, simply pass `--build` to
[`proto install`](/docs/proto/commands/install). For tools that only support build (like Ruby), the
`--build` flag is optional.

```shell
$ proto install python --build
```

To demonstrate how this works, here's Go being built from source. We start by grouping operations
into steps, with the first step being the installation of system dependencies (via Homebrew or
something similar). We then check that certain requirements are met, or abort if unmet. Up next, we
need to acquire the source code, either by downloading an archive, or cloning a Git repository. And
lastly, running through and executing the build instructions/commands.

:::info

While this feature is very exciting, it is extremely unstable, so please report any issues, and
provide any and all feedback!

:::

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.45.0) for a full list
of changes.

---

## moon v1.32 - Remote cache and built-in toolchain improvements

In this release we focused primarily on remote caching and toolchain improvements.

## Improved remote caching stability

The main focus of this release was the stability of our remote caching implementation, by fixing all
bugs and edge cases, and adding support for missing or new features.

### New settings

To support new features (below), we are introducing 2 new settings,
[`unstable_remote.api`](/docs/config/workspace#api) and
[`unstable_remote.auth`](/docs/config/workspace#auth). The `api` setting defines what API format the
remote server supports and expects client requests to be sent in, either `grpc` (default) or `http`.

```yaml title=".moon/workspace.yml"
unstable_remote:
  api: 'grpc'
```

While the `auth` setting does 2 things; allows HTTP headers to be configured that will be injected
into all gRPC/HTTP requests, and a token (via environment variable) to be used for bearer
authorization (instead of TLS/mTLS).

```yaml title=".moon/workspace.yml"
unstable_remote:
  auth:
    headers:
      'X-Custom-Header': 'value'
```

### HTTP API support

If you don't want or can't use gRPC, we now support the
[HTTP caching protocol](https://bazel.build/remote/caching#http-caching). This is a very simple API
that uploads action results to `/ac/` endpoints, and output blobs to `/cas/` endpoints (content
addressable storage). The HTTP API is _very_ simple and does not support any of the features
provided by gRPC, like batch uploading/downloading, streaming, or missing blob detection.

To use this protocol, set the new `api` setting to `http`, and configure an HTTP host.

```yaml title=".moon/workspace.yml"
unstable_remote:
  api: 'http'
  host: 'https://cache.yourhost.com'
```

### ByteStream support

We now support the ByteStream API for gRPC servers, which will automatically download and upload
blobs larger than 4mb by streaming chunks of data. Previously, if we encountered a blob larger than
4mb, we would abort uploading to the cache for that action, so subseqeuent runs would always be a
cache miss.

### Depot cloud hosting

Our good friends at Depot ([depot.dev](https://depot.dev/)) recently announced
[Depot Cache](https://depot.dev/blog/introducing-depot-cache), a cloud-based caching solution that's
compatible with the Bazel remote execution/caching API. We were very excited to read this
announcement, and wanted to get it working in moon immediately. It took a bit of work, and uncovered
a lot of bugs on our end, but we eventually got it working!

To make use of Depot Cache, create an account on their end, and then configure moon with the
following.

```yaml
unstable_remote:
  host: 'grpcs://cache.depot.dev'
  auth:
    token: 'DEPOT_TOKEN'
    # If you have multiple org's
    headers:
      'X-Depot-Org': ''
```

You'll need to set the `DEPOT_TOKEN` environment variable on every machine that will use remote
caching.
[Learn more about this flow in our documentation](/docs/guides/remote-cache#cloud-hosted-depot).

:::info

moon itself now uses Depot Cache for its remote caching, and it has been working quite well! You can
see it in action within each pull request.

:::

### Miscellaneous

- You can now use `http(s)` protocols for gRPC servers, instead of just `grpc(s)`.
- Added timeouts and concurrency limits to our internal clients. In the future, we will also support
  retrying.
- Added a `MOON_DEBUG_REMOTE` environment variable, which can be used to debug internal errors for
  diagnosing connection/integration issues.
- Improved handling of TLS/mTLS connections.

## Improved built-in toolchains

It's been quite some time since we've made any changes to our existing built-in toolchains, and
since there's been many updates in the ecosystem (like Deno v2), we felt it was time to do a pass on
them and introduce some improvements.

### Bun

- Added support for the new text-based `bun.lock` file in
  [Bun v1.2](https://bun.sh/blog/bun-v1.2#introducing-bun-lock).
  - We do our best to detect between the text and binary formats, but we suggest configuring
    `--save-text-lockfile` in [`bun.installArgs`](/docs/config/toolchain#installargs) to be
    explicit.

### Deno

- Added support for [Deno v2](https://deno.com/blog/v2.0).
  - Now supports all lockfile versions (1-4), thanks to the official `deno_lockfile` crate.
  - Now uses `deno install` in v2+ instead of `deno cache` that was used in v1.
  - Added a new [`deno.installArgs`](/docs/config/toolchain#installargs-1) setting.
- Added support for workspaces that were introduced in [Deno v1.45](https://deno.com/blog/v1.45).
  - When a project is within a workspace, it will now install dependencies once in the workspace,
    instead of in each project.

### Python

- Added unstable [uv support](https://docs.astral.sh/uv/). Can be enabled with the new
  [`python.packageManager`](/docs/config/toolchain#packagemanager-1) and
  [`python.uv`](/docs/config/toolchain#uv) settings.
  - Right now, has basic toolchain support, including dependency installs and virtual environments.
  - Uses `uv venv` instead of `python venv` and `uv sync` instead of `pip install`.
  - Relies on `pyproject.toml` and `uv.lock` instead of `requirements.txt`.
- Renamed the `python.rootRequirementsOnly` setting to
  [`python.rootVenvOnly`](/docs/config/toolchain#rootvenvonly). Open for discussion on the name of
  this setting.
- Will now inherit versions from the root `.prototools`.

```yaml title=".moon/toolchain.yml"
python:
  version: '3.12.0'
  packageManager: 'uv'
  uv:
    version: '0.5.26'
```

### Rust

- The root-level project is now properly taken into account when detecting if a project is within
  the Cargo workspace.
- Project dependencies (`dependsOn`) are now automatically inferred from `Cargo.toml` dependencies
  (only `path` allowed).

## Pkl configuration now available

In [moon v1.29](./moon-v1.29) we introduced support for Pkl-based (`.pkl`) configuration as an
alternative to YAML (`.yml`), but it was hidden behind an experimental flag. Going forward, you can
now use Pkl without having to enable the experimental flag, and can remove any references to
`--experimentPklConfig` or `MOON_EXPERIMENT_PKL_CONFIG`.

Additionally, we now have [official documentation on what Pkl is](/docs/guides/pkl-config), how to
use it, and some examples of what it looks like. Check it out!

:::info

Based on feedback from the community, and our current thoughts on the configuration problem, at this
point in time, we plan to support multiple configuration formats instead of choosing one, and will
most likely include support for JSON/JSONC in v2. We're also open to other formats that may work
well in moon, and are compatible with our current codebase.

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.32.0) for a full list
of changes.

- Added unstable support for multiple package workspaces when installing dependencies and resolving
  lockfiles.
- Reworked child process handling to better handle signals and shutdown accordingly. Additionally,
  when the pipeline receives a signal, we now display the status that shutdown the pipeline in the
  summary.
- Reworked the new task `inferInputs` option to not infer environment variables from popular CI/CD
  providers, as those values constantly change, causing tasks to always be affected. If you would
  like to reference these values, add them as an explicit inputs.

---

## proto v0.47 - New backend system & asdf support

In this release, we're stoked to release backends, a new type of plugin that enables the use of
3rd-party plugins.

## New backend: `asdf`

Since proto's inception, we've been asked the question "how's this different than asdf?", or "why
not just use asdf?". The answer to both of these questions is still the same 3 things:

- To start, asdf isn't multi-platform, it's Unix only and doesn't support Windows (proto does).
- Secondly, asdf is powered by Bash scripts, which means a bash-compatible interpreter or shell is
  required (proto uses WASM).
- And lastly, proto is built on Rust, so it's extremely fast and reliable.

With all that said, asdf has a massive [plugin registry](https://github.com/asdf-vm/asdf-plugins)
compared to proto's, and it would take a really long time for proto to reach parity. Because of
this, we've been working on a new plugin type called a "[backend](/docs/proto/tool-spec#backends)",
which allows 3rd-party plugins to be utilized within proto for downloading and installing tools,
locating executables, and more.

Of course, our first backend is [asdf](https://asdf-vm.com/). To install a tool from asdf's
registry, prefix the version in `.prototools` with [`asdf:`](/docs/proto/tool-spec#backends), or
configure the [`backend`](/docs/proto/config#backend) setting.

```toml title=".prototools"
# For this single version
zig = "asdf:0.13.0"

# For all versions
zig = "0.13.0"

[tools.zig]
backend = "asdf"
```

This backend implementation _does not_ use the `asdf` binary itself, and instead emulates the
environment as best we can. Because of this, some tools may not be usable through proto, especially
those that rely on `asdf` itself. Furthermore, the 2 bullet points above are unfortunately still
restrictions: This is Unix only and requires Bash.

> In the next release, we'll investigate the use of Scoop or Chocolatey as a potential backend for
> Windows users. If you're interested in this endeavor, send us a message in Discord!

## New built-in tool: `poetry`

In [v0.45](./proto-v0.45) we introduced 3 new tools, and in this release, we're releasing 1 more! We
want to expand our Python support, and since we already support pip and uv, we wanted to also
support Poetry, which has been requested by the community many times now. Poetry installation works
quite differently than other tools, so please report any issues or improvements.

```shell
$ proto install poetry
```

## proto now shims itself

Until now, proto was a stand-alone binary that existed on `PATH` and was not coupled to proto's
store (`~/.proto`) outside of possibly existing in `~/.proto/bin` for convenience. Over the past
couple of releases, we've been working on supporting proto as an
[official tool](https://github.com/moonrepo/plugins/tree/master/tools/proto) within proto, so
commands like `proto install proto` and `proto pin proto 0.45` actually function correctly.

Starting in this release, when proto is installed via proto, either through `proto install` or
`proto upgrade`, a shim will be created at `~/.proto/shims/proto`, allowing for runtime version
detection and pinning. This basically means you can now pin a project to a certain version of proto
like any other tool, for example:

```toml title=".prototools"
proto = "0.46"
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.47.0) for a full list
of changes.

- Updated offline connection checks to also ping IPv6 addresses for Google & CloudFlare DNS.

---

## moon v1.33 - Alpha support for toolchain WASM plugins

With this release, we're stoked to provide an initial release for plugin support.

## Alpha release of toolchain WASM plugins

For over a [year now](./2024-roadmap#plugin-based-architecture), we've talked about supporting
WASM-based toolchain plugins... but what's taking so long? Migrating from a "hard-coded in core"
approach to a dynamic plugin approach was actually quite difficult, especially in Rust. It took us
way longer than we expected.

With that said, we're excited to announce alpha support for WASM-based toolchain plugins. In this
release, we have a working solution, but with partial support for the toolchain's
[tiered features](/docs/how-it-works/languages#tier-structure-and-responsibilities). At this point
in time, we provide full support for tier 0, major support for tier 1 excluding lockfile/manifest
parsing, minor support for tier 2, no support for tier 3 (but will use
[proto's APIs](/docs/proto/wasm-plugin)), and support for non-tiered features, like
[`moon init`](/docs/commands/init) and [`moon docker`](/docs/commands/docker).

If you're curious, the following WASM function APIs are now available:

- `register_toolchain` - Registers the toolchain and provide metadata for detection and other
  purposes.
- `initialize_toolchain` - Provides prompts to use during `moon init` to gather settings values.
- `define_toolchain_config` - Defines a configuration schema for use within JSON schemas.
- `define_docker_metadata` - Defines metadata related to `docker` commands.
- `hash_task_contents` - Injects content into the task hashing process.
- `prune_docker` - Custom operations to run during `docker prune`.
- `scaffold_docker` - Custom operations to run during `docker scaffold`.
- `sync_project` - Runs syncing operations per project (during the `SyncProject` action).
- `sync_workspace` - Runs syncing operations at the workspace root (during the `SyncWorkspace`
  action).

We know everyone is very excited about these plugins, so feel free to start using them today!
However, since we don't have full tiered support, most of the advanced functionality related to
running tasks is currently not supported (except for task hashing which is supported).

Additionally, we do _not_ have documentation yet for these new APIs, but we do have the following
resources to help you get started:

- [Getting started with WASM plugins](/docs/guides/wasm-plugins)
- [Example toolchain WASM plugins](https://github.com/moonrepo/plugins/tree/master/toolchains)
- [`moon_pdk` documentation](https://docs.rs/moon_pdk) (functions, macros, etc)
- [`moon_pdk_api` documentation](https://docs.rs/moon_pdk_api) (structs, enums, etc)

### TypeScript toolchain

To verify that our WASM plugin implementation works correctly, we've
[migrated the TypeScript toolchain entirely to a WASM plugin](https://github.com/moonrepo/plugins/tree/master/toolchains/typescript),
and it's no longer hard-coded in our Rust core! If you've configured
[`typescript`](/docs/config/toolchain#typescript) in
[`.moon/toolchain.yml`](/docs/config/toolchain), then you'll automatically use the new plugin under
the hood.

This is our first step in supporting plugins in core. We chose TypeScript as our 1st plugin because
it was the simplest of all the toolchains, was primarily used for project syncing, and did not
require all tiered APIs.

With that said, most of the code had to be rewritten when porting, but we tried to keep as much
parity as possible. Please report an issues or differences you encounter. Additionally, because
TypeScript is now a "true" toolchain, it will appear in the toolchains list for projects and tasks.
This is required since it runs operations in the context of the plugin.

Because toolchain plugins are configured differently internally, and since TypeScript is now a
plugin, the configuration syntax for disabling the TypeScript toolchain at the project-level has
changed. While not a breaking change in this release, the old format will be removed in the future.

```yml title="moon.yml"
# Before
toolchain:
  typescript:
    disable: true

# After
toolchain:
  typescript: false # or null
```

:::warning

If you use the TypeScript toolchain, you'll need to update your configuration files or editor to
point to the newer [JSON schemas](#dynamic-json-schemas), otherwise your editor may error with
"Property typescript is not allowed".

:::

## Experimental `moonx` executable

Based on a [request from the community](https://github.com/moonrepo/moon/issues/1828), we're
introducing a new executable `moonx`, which is simply a shorthand for `moon run ...`. In the future
we will expand this with more "shorthand" functionality.

```shell
$ moonx app:build
```

Because of our current release process, the `moonx` executable is _not_ packaged in the release (on
GitHub), and is instead created the first time `moon` runs. Furthermore, `moonx` is not a binary
executable, and is instead a shim (a Bash script on Unix, and a PowerShell (`.ps1`) script on
Windows). In the future, this will become a true binary.

## Dynamic JSON schemas

With the initial support for toolchain plugins, the available configuration in
[`.moon/toolchain.yml`](/docs/config/toolchain) and [`moon.yml`](/docs/config/project) is no longer
static, and is instead dynamic based on the enabled/configured toolchains. Because of this, the JSON
schemas provided at `moonrepo.dev` and in the GitHub release are not accurate for some toolchain
related settings, but accurate for everything else.

This may lead to a poor developer experience where your editor shows errors for unknown settings. To
remedy this, we now generate dynamic schemas at `.moon/cache/schemas` with accurate settings. If
you're editor supports the `$schema` property, you can update them like so:

```yaml title=".moon/toolchain.yml"
$schema: './cache/schemas/toolchain.json'
```

```yaml title="app/moon.yml"
$schema: '../.moon/cache/schemas/toolchain.json'
```

The VS Code YAML server does not support the
[`$schema` property](https://github.com/redhat-developer/yaml-language-server/pull/970), but there
is a
[work around](https://github.com/redhat-developer/yaml-language-server?tab=readme-ov-file#using-inlined-schema).
However, that syntax is a bit unfortunate, so our official moon VS Code extension supports updating
`.vscode/settings`. Simply open the command palette and select "moon: Append YAML schemas
configuration to settings".

:::info

These schemas are automatically generated through [`moon run`](/docs/commands/run) but can be
manually generated with [`moon sync config-schemas`](/docs/commands/sync/config-schemas).

:::

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.33.0) for a full list
of changes.

- Added support for `moon run ~:build`, which will run the `build` task in the closest project
  (traversing upwards).
- Added `$XDG_DATA_HOME` support when detecting the moon store. Will be used if `$MOON_HOME` is not
  set, and will fallback to `$HOME/.moon`.
- Added elapsed/timing information to child processes and WASM calls within logs.
- Improved the handling of CTRL-C, CTRL-BREAK, and other signals on Windows.
- Updated `moon init` with toolchain plugin support.
- Updated `toolchain.default` in `moon.yml` to support a list of IDs.
- Updated file hashing (via `git hash-object`) to continously pipe stdin to avoid hanging processes.

---

## moon v1.34 - Action customization, faster globs, better Git, and more!

With this release, we're introducing a handful of performance and customization improvements!

## moonbase has been sunset

As mentioned in previous releases, we have sunset [moonbase](/moonbase), our remote caching service.
A while back we had internal discussions on whether to rework moonbase so that it could be
self-hosted (on-premises), or adopt the
[Bazel Remote Execution API](https://github.com/bazelbuild/remote-apis) and utilize what the open
source community has to offer. We ultimately decided with the latter, as it frees up resources on
our end to focus on moon and proto, and also provides a better path forward for moon adoption.

If you are currently using moonbase, we suggest migrating to our new
[remote caching options](/docs/guides/remote-cache). And if you have an active moonbase
subscription, it will be cancelled within the week, and any partial billing for this month will be
prorated.

## Customize actions in the pipeline

When a task is ran in moon, we create an [action graph](/docs/how-it-works/action-graph) (not a task
graph) of actions, which are operations required to run to ensure a successful execution. This
includes non-task related functionality, like project and workspace syncing, installing
dependencies, and ensuring the toolchain has been setup. While these actions only take milliseconds
to execute (on a cache hit), they can become quite a barrier and source of friction (on cache miss).

Until now, there wasn't anyway to disable/skip these extra actions -- besides some non-documented
environment variables that didn't actually omit the actions (they were still in the graph), but
simply skipped the inner execution. In this release, we're introducing 4 new settings for
[`pipeline`](/docs/config/workspace#pipeline) (formerly `runner`) in
[`.moon/workspace.yml`](/docs/config/workspace).

- `installDependencies` setting toggles the inclusion of the `InstallWorkspaceDeps` and
  `InstallProjectDeps` actions, and can be scoped to toolchain IDs.
- `syncProjects` setting toggles the inclusion of the `SyncProject` actions, and can be scoped to
  project IDs.
- `syncProjectDependencies` setting toggles whether to recursively create `SyncProject` actions for
  each dependency of a project, or just for itself.
- `syncWorkspace` setting toggles the inclusion of the root `SyncWorkspace` action.

For example, if you want to disable all of these actions entirely, you can do this:

```yaml title=".moon/workspace.yml"
pipeline:
  installDependencies: false
  syncProjects: false
  syncProjectDependencies: false
  syncWorkspace: false
```

And as mentioned above, the `installDependencies` and `syncProjects` settings support configuring a
list of IDs, which acts as an allow list. Any IDs not listed here will not create actions.

```yaml title=".moon/workspace.yml"
pipeline:
  # Only install Node.js dependencies
  installDependencies: ['node']
  # Only sync the `app` project
  syncProjects: ['app']
```

:::info

Even if you disable actions with the `pipeline` setting, the [`moon sync`](/docs/commands/sync)
commands can still be used to run sync operations, as they ignore that setting. This provides a
solution where you want to avoid the overhead when running a task, but still take advantage of
moon's syncing to ensure a healthy repository state.

:::

### New `--no-actions` flag

To expand upon the above, we're introducing a `--no-actions` flag to
[`moon run`](/docs/commands/run), that will run the task without the other actions being added to
the graph. We suggest only using this flag once dependencies have been installed, and the toolchain
has been setup!

```shell
$ moon run app:start --no-actions
```

## New experiments

It's been a while since we've added new experiments, and in this release, we've got 2! We encourage
everyone to enable these experiments to ensure they are working correctly, but do note that these
are a work in progress and may be buggy.

### Faster glob walking

We've been monitoring glob performance for sometime now, as walking the filesystem has been one of
the largest bottlenecks, especially in large codebases. We felt it was about time to tackle the
problem.

With this new implementation, we are doing a few things to increase performance. To start, we are
parallelizing walking per directory, where previously this would happen serially. Next, we partition
globs based on a common ancestor directory, which reduces the amount of unnecessary walking. And
lastly, we cache common globs to avoid walking all together.

In our benchmarks and tests (moon itself is already using it), we are seeing performance increases
by 1.5-2x! To start using this new glob implementation, enable the new `fasterGlobWalk` experiment.

```yaml title=".moon/workspace.yml"
experiments:
  fasterGlobWalk: true
```

### Better Git integration

Our current Git integration works, assuming you're not doing anything complex, like using submodules
or worktrees. If you are using the latter, things have been buggy. We're not happy about this, as we
want to support all the different ways a repository can be architected.

So we started over from scratch! We even created
[real repositories](https://github.com/moonrepo/git-test) to ensure our understanding and
implementation of these features is accurate. This new implementation achieves the following:

- Supports submodules, subtrees, and worktees (unique among build systems).
  - Our competitors don't support these, and we expect them to "borrow" our implementation in the
    future (like they have with other features).
- Git commands are parallelized when applicable.
- Touched files within submodules are now properly extracted.
- File discovery and hashing is more performant.

If you'd like to try this new Git implementation (moon itself already is), enable the `gitV2`
experiment.

```yaml title=".moon/workspace.yml"
experiments:
  gitV2: true
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.34.0) for a full list
of changes.

- Added a `--json` flag to `moon templates`.
- Integrated a new console rendering system with new terminal styles, prompts, and output.
- Improved the performance of environment variable substitution.
- Improved toolchain plugin loading to be on-demand.
- Improved sync cache invalidation for codeowners, config schemas, and VCS hooks.

## What's next?

Going forward, we plan to release new updates on a bi-weekly schedule, instead of a monthly
schedule. This will result in less features each release, but will reduce the burden and complexity
of large releases. With that said, this is what we have tentatively planned for the next release!

- Migrate the Rust toolchain to a WASM plugin.
- Investigate a new args/command line parser.
- Add Poetry support for the Python toolchain.

---

## moonbase has been sunset

As mentioned in previous moon releases and announcements, we have sunset [moonbase](/moonbase), our
remote caching service.

A while back we had internal discussions on whether to rework moonbase so that it could be
self-hosted (on-premises), or adopt the
[Bazel Remote Execution API](https://github.com/bazelbuild/remote-apis) and utilize what the open
source community has to offer. We ultimately decided with the latter, as it frees up resources on
our end to focus on moon and proto, and also provides a better path forward for moon adoption.

If you are currently using moonbase, we suggest migrating to our new
[remote caching options](/docs/guides/remote-cache). And if you have an active moonbase
subscription, it will be cancelled within the week, and any partial billing for this month will be
prorated.

With that said, we have some ideas brewing on how to bring this back in another form. Perhaps our
own implementation of the Bazel Remote Execution API that can be self-hosted and deeply integrate
with moon.

---

## moon v1.35 - Action graph improvements, task priorities, and more!

With this release, we're taking yet another step to supporting plugins.

## Improved action graph

For this release we wanted to introduce a new WASM based Rust toolchain, but we encountered a few
blockers while integrating with the action graph, so instead of working on the toolchain, we decided
to rewrite the action graph to properly support plugins.

The biggest blocker was around locating the toolchain's dependency root, and in Rust's case, the
Cargo workspace (where `Cargo.lock` is located). We technically have some of this logic in the
current Rust platform, but it always assumed that the Cargo workspace was in the root of the moon
workspace (the same applies to Bun and Node). This heavily restricted all moon users. With the new
plugin system, the dependency root can be located anywhere in the moon workspace, and we'll attempt
to locate it!

While rewriting the action graph, we made a ton of improvements (some won't be noticeable until
plugins are more prevalent). To start the graph is now async compatible, and in the future, we'll
update it to also support concurrency, so that the graph can be built in parallel across threads.
Additionally, a main focus was reducing the amount of edges (relationships) being created between
nodes (actions). And lastly, the following changes were made for the actions themselves.

- Added a new `InstallDependencies` action for WASM plugins.
  - The dependencies root is now dynamically located by traversing the file system, unlike the
    previous implementation that assumed everything was in the workspace root.
- Added a new `SetupEnvironment` action for WASM plugins.
  - This runs after `SetupToolchain` but before `InstallDependencies`.
  - Can be used to setup the workspace or project environment. For example, initializing Python
    venv, or making manifest/lockfile changes.
- Updated `RunTask` to setup toolchains and install dependencies for each `toolchain` that has been
  configured, instead of just the 1st one (work in progress).
- Updated `SyncProject` to no longer depend on `SetupToolchain`, and not be grouped by
  language/toolchain, and instead encompass all of them applicable to the project.

## Task priorities

Based on a request from the community that we really liked, we're introducing a new concept called
task priorities. Each task can configure a priority level using the new task option
[`priority`](/docs/config/project#priority), and the priority level determines the position of the
task within the action pipeline queue. A task with a higher priority will run sooner rather than
later, while still respecting the topological order.

```yaml title="app/moon.yml" {5}
tasks:
  build:
    # ...
    options:
      priority: 'high'
```

There are a few things to be aware of with this implementation:

- All non-task related actions (like setup toolchain) will still always run first.
- Higher priority tasks that depend on lower priority tasks will effectively mark them as high
  priority, as we attempt to complete them sooner.
- The order within each priority level is sorted topological, but is still non-deterministic if
  tasks run in parallel.

## Enabled experiments

In our last release, we introduced [2 new experiments](./moon-v1.34#new-experiments),
`fasterGlobWalk` and `gitV2`. In the past few weeks, we've had many users (including ourself) enable
these experiments without issue. As such, we've decided to enable them by default in this release.

If you encounter an issue with either of these experiments, you can disable them in
`.moon/workspace.yml`. And of course, please report it so we can fix it!

```yaml title=".moon/workspace.yml"
experiments:
  fasterGlobWalk: false
  gitV2: false
```

## Light terminal theme

By default, moon assumes a dark themed terminal is being used, and will output our branded colors
accordingly. However, if you use a light theme, these colors are hard to read, and there's no way to
change them.

To mitigate this, we're introducing a light based terminal theme, which can be enabled with the
`--theme` global option, or the `MOON_THEME` environment variable.

```shell
$ moon run app:build --theme light
# Or
$ MOON_THEME=light moon run app:build
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.35.0) for a full list
of changes.

- Added a new task option, `cacheKey`, which can be used to seed the hash, and invalidate local and
  remote caches.
- Added a `--log=verbose` level, which includes span information on top of the trace level.
- Added 2 new webhooks, `toolchain.installing` and `toolchain.installed`, which emit when a
  toolchain WASM plugin is installing a tool (via proto).

## What's next?

Now that are action graph supports plugins, we can take the next step in migrating an existing
platform into a toolchain.

- Migrate the Rust toolchain to a WASM plugin.
- Investigate a new args/command line parser.
- Add Poetry support for the Python toolchain.

---

## moon v1.36 - Toolchain plugins beta, optimized remote caching, and codegen improvements

In this release, we're very excited to fully release toolchain plugins!

## Beta release of toolchain WASM plugins

Two months ago we announced [alpha toolchain plugins](./moon-v1.33) with support for tier 3, but not
tier 2. The reason for this was that tier 3 is powered by [proto APIs](/docs/proto/wasm-plugin),
which already existed! We simply hooked them up to moon. The bulk of the remaining plugin work was
tier 2 support, which we are excited to announce has been completed! The following APIs have been
implemented:

- `extend_project_graph` - Extend projects with toolchain specific info.
- `extend_task_command` - Extend the command child process with parameters.
- `extend_task_script` - Extend the script child process with parameters.
- `locate_dependencies_root` - Locate the package dependencies workspace root.
- `parse_manifest` - Parse a manifest file to extract dependencies.
- `parse_lock` - Parse a lock file to extract resolved dependencies.

And the following surface areas have been integrated with:

- In the project graph:
  - Extend projects with dependencies, tasks, and an alias.
- In the action pipeline:
  - Added `SetupEnvironment` action that executes the `setup_environment` API.
  - Added `InstallDependencies` action that executes the `install_dependencies` API.
- When running tasks:
  - Extend the command/script with additional parameters before executing.
  - Inject dependency and lock information into the hash.
- With Docker:
  - Updated `docker prune` to utilize the new WASM APIs for toolchain plugins.

As of this release, all 27 APIs have been implemented, and toolchain plugins are now available for
general use! However, they are still quite unstable, not fully tested, and the APIs may change
between releases, but you can start using them today if you're feeling adventurous!

With all this said, we do not have documentation yet. We plan to slowly work on this across the next
few releases. In the meantime, check out the following resources for more information:

- [`moon_pdk`](https://docs.rs/moon_pdk/) - Rust plugin development kit.
- Existing [toolchain plugins](https://github.com/moonrepo/plugins/tree/master/toolchains).
- In development [Rust toolchain](https://github.com/moonrepo/plugins/pull/48).

## Optimized remote caching

Like the past few releases, we've made some improvements to the remote caching layer.

To start, we're adding a new
[`unstable_remote.cache.verifyIntegrity`](/docs/config/workspace#verifyintegrity) setting, that will
verify the digest (hash) of downloaded blobs to ensure they aren't corrupted or incomplete. We
currently check the file size, but this will also now check the content. This setting will slightly
degrade performance but ensure reliability.

```yaml title=".moon/workspace.yml"
unstable_remote:
  cache:
    verifyIntegrity: true
```

While we're on the topic of reliability, we're also introducing an implicit rollback mechanic that
will remove partially downloaded or incomplete blobs if hydration ever fails at some point. This
will also run between executions to ensure there are no stale artifacts lying around.

And lastly, we've parallelized the blob existence checks, reducing the amount of large requests for
heavy tasks, and reworked how we inherit `MOON_REMOTE_*` environment variables.

## Improved code generation

It's been a while since we've added new features to code generation, but thanks to some great
requests from the community, we have 2 this release!

### Archive URLs

The first is that [remote archives](/docs/guides/codegen#archive-urls) (zip, tar, etc) can be used
as template locations. The archive will then be downloaded and unpacked into `~/.moon/templates`.

```yaml title=".moon/workspace.yml"
generator:
  templates:
    - 'https://domain.com/some/path/to/archive.zip'
```

### Array and object types

The second is that we now support `array` and `object`
[variable types](/docs/config/template#variables) in `template.yml`. The values within each of these
collections can be any JSON-compatible type.

```yaml title="template.yml"
variables:
  type:
    type: 'array'
    prompt: 'Type?'
    default: ['app', 'lib']
  metadata:
    type: 'object'
    prompt: 'Metadata?'
    default:
      internal: true
```

These variables and their nested values can then be accessed within templates using dot or bracket
notation.

```twig
{{ type[0] }}
{{ metadata.internal }}
```

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.36.0) for a full list
of changes.

- Added `--host` and `--port` options to `moon action-graph`, `moon task-graph`, and
  `moon project-graph`.
- Added `--stdin` option to `moon ci` and `moon run`, which will allow touched files to be passed
  via stdin, instead of running VCS commands to determine them.
- Removed the restriction around `moon.{yml,pkl}` not being allowed as a task input. However, will
  not be included when using `**/*`.

## What's next?

Now that toolchain plugins are in beta, we can take the next step in migrating an existing platform
into a toolchain.

- Migrate the Rust toolchain to a WASM plugin.

---

## moon v1.37 - Rust WASM toolchain and MCP support

In this release, we're stoked to release another WASM toolchain plugin, and experimental MCP/AI
support!

## RFC: Task input additions and enhancements

We're planning to improve task inputs and have written up an
[RFC to discuss these changes](https://github.com/moonrepo/moon/issues/1985). We'd appreciate any
and all feedback!

## New Rust toolchain powered by WASM

With [toolchain plugins](./moon-v1.36) entering beta last release, it's only natural that we start
migrating the legacy toolchains into plugins. And with this release, the next one we've migrated is
the Rust toolchain! However, unlike the TypeScript toolchain, the new Rust toolchain is opt-in and
must be enabled. Simply rename `rust` to `unstable_rust` in `.moon/toolchain.yml`.

```yaml title=".moon/toolchain.yml"
unstable_rust:
  version: '1.87.0'
  components: ['clippy', 'rustfmt']
  targets: ['wasm32-wasip1']
  syncToolchainConfig: true
```

### New functionality

Although the new Rust toolchain is a one-to-one port, the WASM APIs provide far more flexibility and
functionality than before. For example, the follow improvements and enhancements have been made:

- The Cargo workspace can now exist at any folder depth and does not need to exist at the moon
  workspace root. Additionally, because of this, we can now support multiple Cargo workspaces in the
  same moon workspace.
- Added a new `addMsrvConstraint` setting, which will sync the version as a constraint to
  `Cargo.toml` under the `workspace.package.rust-version` or `package.rust-version` fields.
- Improved the accuracy of implicit project dependencies (inferred from `Cargo.toml`).
- Improved the parsing of manifest (`Cargo.toml`) and lock (`Cargo.lock`) files. This information is
  then fed into the task hashing process.
- Improved the Docker prune implementation by preserving all binaries (inferred from
  `cargo metadata`) while deleting the `target` directory.
- Any `cargo` or `rustup` commands are now hashed and cached, and will only re-run when parameters
  change. Unlike the current toolchain, which always runs these commands.

Quite a list of improvements, and this doesn't even include all the WASM / plugin improvements that
have been slowly introduced! Give this new toolchain a try, and let us know what you think!

## MCP editor integration

AI is all the rage these days, and even more so lately with the introduction of
[MCP](https://modelcontextprotocol.io) (model context protocol) and agentic workflows. MCP is a new
way for AI assistants to "understand" what's going on in your project without you having to explain
everything. It works by feeding structured information, like in the context of moon, projects,
tasks, and relationships, directly into AI models like GitHub Copilot or Cursor.

No more tedious explanations required! The AI can jump straight to helpful suggestions that actually
work in your codebase, saving you time, and making the whole experience much smoother, especially in
complex monorepos with lots of moving parts.

To support agentic workflows, we're introducing an experimental [`moon mcp`](/docs/commands/mcp)
command, that starts an MCP server, and can be [integrated into your editor](/docs/guides/mcp). For
example, VS Code:

```json title=".vscode/mcp.json"
{
  "servers": {
    "moon": {
      "type": "stdio",
      "command": "moon",
      "args": ["mcp"],
      "env": {
        "MOON_WORKSPACE_ROOT": "${workspaceFolder}"
      }
    }
  }
}
```

### Supported tools

Our MCP server currently supports the following tools. We'll be adding more tools in the future, so
if you have any suggestions, please let us know!

- `get_project` - Get a project and its tasks by `id`.
- `get_projects` - Get all projects.
- `get_task` - Get a task by `target`.
- `get_tasks` - Get all tasks.

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.37.0) for a full list
of changes.

- Added `environment.initializing` and `environment.initialized` webhook events.
- Added `root` and `toolchain` fields to `dependencies.installing` and `dependencies.installed`
  webhook events.
- Updated proto to [v0.49.4](https://github.com/moonrepo/proto/releases/tag/v0.49.4) (from 0.49.1).

## What's next?

With toolchains plugins being stabilized more, we'd like to focus on some other areas.

- Better command line argument parsing/joining (especially for task `args`)
- Better child process I/O piping
- Terminal notifications
- WASM toolchain documentation

### Looking for toolchain contributors!

Now that the Rust toolchain has been ported to WASM, we'd like to start porting the other
toolchains, starting with Go and JavaScript (not Bun or Node.js), and also investigate supporting
toolchains for entirely new languages, like PHP and Ruby! If you're interested in contributing these
toolchains, please ping us in Discord!

The only requirements is that these toolchains must be written in Rust and must exist in the
[moonrepo/plugins](https://github.com/moonrepo/plugins) repository!

---

## proto v0.50 - URL rewrites, on-init activation, preserved comments, and more

In this release, we're landing a handful of quality of life improvements that have been requested by
the community.

## Rewrite URLs for better interoperability

proto is heavily reliant on URLs, as they power everything from tool and plugin downloading to
version resolving. Many URLs are hard-coded into proto but most of them come from plugins. For the
most part this is fine, but if you work within a corporate environment, or have a firewall, you may
have to deal with proxy servers, mirrors, or other factors.

Until now, this was very difficult to circumvent, so we wanted to provide a built-in solution to
this problem, and as such, we're introducing the new
[`url-rewrites`](/docs/proto/config#url-rewrites) configuration setting. This setting accepts a map
of regex patterns to replacements, and will rewrite URLs that match the pattern.

```toml title=".prototools"
[settings.url-rewrites]
"github.com/(\\w+)/(\\w+)" = "gh-mirror.corp.com/$1/$2"
"mo+n" = "lunar"
```

For example, in the configuration above, any URL that contains `github.com` will be replaced with
`gh-mirror.corp.com`, and any URL that contains the word "moon" (with different length o's) will be
replaced with "lunar". Learn more about URL rewriting in the settings documentation!

## Activation flow now triggers immediately

Our [activation flow](/docs/proto/workflows#shell-activation) (shell hooks) is seeing more and more
usage, with improved stability, but based on feedback we've received, there was still some pain
points. One of these pain points was that activation would not trigger immediately (new terminal
window/tab), and would only trigger after changing directories.

There was a way around this using the `--on-init` flag, but that was not easily discoverable, and
the setup as a whole was not very intuitive. With this release, that flag has been deprecated and
the activation flow now triggers immediately, so you can start using your tools right away.

Historically we've been hesitent to do this, as we were worried about potential performance hits
when having to download WASM plugins, or refetch caches. However in practice this has not been an
issue.

## Comments are now preserved in `.prototools`

This has been a long standing issue and a long requested feature, and it's finally here! Comments
are now preserved in `.prototools` files, and they'll no longer be removed when running `proto`
commands that modify these files (like [`proto alias`](/docs/proto/commands/alias) or
[`proto pin`](/docs/proto/commands/pin)).

Historically this has been a hard problem to solve, as Rust serde (serialization/deserialization
library) strips comments when deserializing (reading) the file. To solve this problem, we had to
avoid serde, and operate on an AST-like structure instead. Because of this, we lose type-safety and
there may be some edge cases not accounted for.

## Plugin commands are now executed within a shell

When a plugin executes a command (child process) on the host system (your computer), it now executes
it within a shell, e.g. `bash -c "command"`. This change was made to ensure environment variables
(like `PATH`), aliases, and other shell features that you have configured are available to the
plugin.

By default the shell to use is detected from the parent host process, but you can override it with
the `PROTO_SHELL` environment variable. For example, to use `zsh` you can set:

```shell
PROTO_SHELL=zsh
```

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.50.0) for a full list
of changes.

- Added `--dir` and `--all` options to the [`proto bin`](/docs/proto/commands/bin) command.
- Added environment variable support to many non-tool related `.prototools` settings.
- Updated `proto install ` (without version) to install a version pinned in `.prototools`,
  instead of the latest version.

---

## moon v1.38 - Go WASM toolchain, MCP tools, terminal notifications, and more!

In this release, we're stoked to release the Go WASM toolchain plugin, and improved MCP/AI support!

## RFC: Task inheritance via inline configuration

Task inheritance is one of moon's most powerful features, allowing you to define tasks at the
top-level and have them automatically inherited by projects that match certain conditions. In it's
current form, task inheritance is based on the file name of the configuration file, but this
approach has several limitations.

We're planning to improve task inheritance and have written up an
[RFC to discuss these changes](https://github.com/moonrepo/moon/issues/2023). We'd appreciate any
and all feedback!

## New Go toolchain powered by WASM

Official Go toolchain support has been requested by the community for a long time now, and with the
somewhat stabilization of WASM plugins and the introduction of the
[Rust toolchain in the last release](./moon-v1.37), we felt it was finally time to add Go! To enable
Go, run our new command or add an [`unstable_go`](/docs/config/toolchain#unstable_go) entry to
`.moon/toolchain.yml`.

```shell
$ moon toolchain add unstable_go
```

```yaml title=".moon/toolchain.yml"
unstable_go:
  version: '1.24.0'
  workspaces: true
```

The Go toolchain releases with full [tier 1, 2, and 3 support](/docs/how-it-works/languages)!
Additionally, the following features and functionality is available when enabling the toolchain:

- Supports Go workspaces through the `go.work` file. Can be disabled with the
  [`unstable_go.workspaces`](/docs/config/toolchain#unstable_go) setting.
- Extracts the `go.mod` `module` directive as a project alias.
- Extracts project relationships and dependency information from `go.mod` `require` directives.
- Extracts version and checksum information from `go.sum` and `go.work.sum` files.
- Injects Go globals directory (`GOBIN`) into task command/script child processes.
- Supports installing Go globals via `go install` commands. Can be customized with the
  [`unstable_go.bins`](/docs/config/toolchain#unstable_go) setting.
- Automatically runs `go mod` or `go work` commands when installing dependencies.
- Basic Docker image and pruning support.

We hope you enjoy this new Go toolchain. With that said, we are _not_ Go experts, and would love to
hear from you on what works, what doesn't, what can be improved, and what features you would like to
see added!

## New MCP tools

In our last release, we introduced the [`moon mcp` command](./moon-v1.37#mcp-editor-integration),
offering deep editor integration with AI models like GitHub Copilot and Cursor. This release expands
on that by introducing 3 more tools to utilize:

- `get_touched_files` - Gets touched files between base and head revisions.
- `sync_projects` - Runs the `SyncProject` action for one or many projects by `id`.
- `sync_workspace` - Runs the `SyncWorkspace` action.

## New OS terminal notifications

This was a feature we originally scoped out during moon's inception, almost 3 years ago, but we
never got around to implementing it. However, there has been some improvements to native operating
system notifications in Rust lately, so it felt like a good time to finally implement it!

And on that note, we are introducing a new
[`notifier.terminalNotifications`](/docs/config/workspace#terminalnotifications) setting that allows
you to receive terminal notifications for pipeline events.

```yaml title=".moon/workspace.yml"
notifier:
  terminalNotifications: 'failure'
```

> View the [official guide](/docs/guides/notifications) for more information!

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.38.0) for a full list
of changes.

- Added new `moon toolchain` command and sub-commands.
  - Add a toolchain to `.moon/toolchain.yml` with `moon toolchain add`.
  - View information about a toolchain plugin with `moon toolchain info`.
- Added a `notifier.webhookAcknowledge` setting, that ensures webhooks resolve with a 2XX status
  code.
- Updated proto to [v0.50.1](https://github.com/moonrepo/proto/releases/tag/v0.50.0) (from 0.49.4).

## What's next?

With toolchains plugins being stabilized more, we'd like to focus on some other areas.

- Better command line argument parsing/joining (especially for task `args`)
- Better child process I/O piping
- WASM toolchain documentation

---

## proto v0.51 - Unstable lockfiles and plugin registries

With this release, we're excited to introduce two major features that pave the way for proto's
future!

## Unstable lockfile support

Lockfiles have been requested by the community since proto's inception, but adopting them has been a
non-trivial task, as it requires touching almost every aspect of proto. With that said, we've been
slowly reworking the internals to support lockfiles, and with this release, we're introducing
unstable support for them!

If you're unaware of what lockfiles are, they allow you to pin the exact version (and checksum) of a
tool that is installed, ensuring that your development environment is consistent and reproducible.
If you've used package managers like npm, Cargo, or uv, you're likely familiar with this concept.

In proto, the concept of lockfiles is mostly the same, but the manner in which they are created and
updated may differ based on other tools. To start, lockfiles in proto are _opt-in_ and can be
enabled with the new [`settings.unstable-lockfile`](/docs/proto/config#unstable-lockfile) setting in
`.prototools`.

```toml title=".prototools"
[settings]
unstable-lockfile = true
```

This will create a `.protolock` file in the current directory, relative to the `.prototools` file.
In effect, this locks that directory and all of its subdirectories. As a side-effect, nested
lockfiles are not supported.

To demonstrate how lockfiles work, installing the following tools with `proto install`...

```toml title=".prototools"
bun = "1.2.0"
deno = "2.4.0"
node = "22.17.0"

[settings]
unstable-lockfile = true
```

... would generate the following `.protolock` file:

```toml title=".protolock"
# Generated by proto. Do not modify!

[[tools.bun]]
spec = "1.2.0"
version = "1.2.0"
checksum = "sha256:fa72173cb2220d00e2d2650fefdc0b5b37bfd8bb33d8d671b50efb409c2f5745"

[[tools.deno]]
spec = "2.4.0"
version = "2.4.0"
checksum = "sha256:c913d018d64c48dcc5b7b90d844efb6d017595a7c1e237f89141df1b3ef8b962"

[[tools.node]]
spec = "22.17.0"
version = "22.17.0"
checksum = "sha256:cc9cc294eaf782dd93c8c51f460da610cc35753c6a9947411731524d16e97914"
```

### Updated workflows

The [`proto run`](/docs/proto/commands/run) (shims),
[`proto install`](/docs/proto/commands/install), and
[`proto uninstall`](/docs/proto/commands/uninstall) commands have been updated to support lockfiles.

When running or installing tools and a matching specification exists in the lockfile, the locked
version will be inherited even if there's a newer version upstream, and the tool's checksum will be
validated when available. These checks can be bypassed with the new `--update-lockfile` flag
(install only).

Inversely, when uninstalling tools, the lockfile will be updated to remove any matching
specification records.

### Still a work in progress

We are marking lockfiles as unstable as they have not been fully implemented or thoroughly tested.
There are other commands like [`proto outdated`](/docs/proto/commands/outdated) and
[`proto status`](/docs/proto/commands/status) that are not lockfile aware yet, but will be in the
future.

But please, give them a whirl and let us know what you think!

## Unstable OCI registries for plugin storage

Another important feature that is necessary for proto's success is support for an official plugin
registry. Before we get to that, we need to lay the groundwork for how plugins are stored and
distributed. With this release, we're introducing unstable support for
[OCI registries](https://opencontainers.org/) as a storage mechanism for plugins. If you're
unfamiliar with OCI registries, they are a standard for storing and distributing container images
(Docker), but can also be used to store other types of
[artifacts](https://oras.land/docs/concepts/artifact), in this case, WASM plugins.

To support registries, we have introduced a new
[`settings.unstable-registries`](/docs/proto/config#unstable-registries) setting in `.prototools`,
which allows you to configure a list of registries to query for applicable plugins. For example:

```toml title=".prototools"
[settings]
unstable-registries = [
  { registry: "ghcr.io", namespace: "moonrepo" }
]
```

Additionally, we are introducing a new `registry://` plugin locator, which allows you to configure a
plugin by its OCI reference.

```toml title=".prototools"
[plugins]
# Longform with tag
bun = "registry://ghcr.io/moonrepo/bun_tool:v1.2.3"
# Longform without tag
bun = "registry://ghcr.io/moonrepo/bun_tool"
# Shortform with tag
bun = "registry://bun_tool:v1.2.3"
# Shortform without tag
bun = "registry://bun_tool"
```

### How it works

Using a container registry to store plugins seems odd at first, but it actually allows us to
leverage existing specifications, infrastructure, and tools to manage and distribute plugins. We
don't want to re-invent the wheel here, so why not use something that most of the industry is
already using?

With that said, how does this work in proto? Since we are not a container image, we use the
[artifact portion of the specification](https://oras.land/docs/concepts/artifact) instead.
Primarily, plugins are stored in layers! The blob/content of WASM, TOML, JSON, and YAML plugins are
stored in CAS, and referenced in layers by a sha256 digest.

As for annotations, we support the
[OCI standard annotations](https://github.com/opencontainers/image-spec/blob/main/annotations.md),
but will also support moonrepo-specific annotations in the future.

:::info

At this time, we do not provide a mechanism for uploading plugins to a registry. You'll need to do
that manually.

:::

### Official registry?

We do have plans to support an official moonrepo plugin registry, for both proto and moon. We are in
the process of investigating solutions to this and will provide more details soon.

## Other changes

View the [official release](https://github.com/moonrepo/proto/releases/tag/v0.51.0) for a full list
of changes.

- Removed `--canary` from `proto install`, just use `canary` as the version specifier instead.

## Looking for contributors

We have a lot of cool stuff planned for proto, like backend plugins, more official tools, improved
workflows, an official registry, and more! So if you're interested in Rust or WASM, we would love
and appreciate your help. Feel free to ping us on Discord!

---

## moon v1.39 - Improved task inputs, better proto integration, and project layers

This is a rather small release, but it does include some important changes to task inputs, and
proto's integration.

## Improved task inputs

A few months ago we introduced an
[RFC for improving task inputs](https://github.com/moonrepo/moon/issues/1985) that introduces new
syntax, functionality, and input types. In this release, we have implemented a portion of the RFC
for testing before we implement the rest. Continue reading for more details!

### New formats

To start, we are introducing 2 new formats for configuring task inputs, a URI format and an object
format, both of which support custom parameters.

#### URIs

URIs should be rather familiar, as they are a string prefixed with a scheme (`://`), followed by a
value, and an optional list of query parameters (`?`). Currently files can be specified using the
[`file://` scheme](/docs/config/project#file-paths), and globs with the
[`glob://` scheme](/docs/config/project#glob-patterns). Environment variables do not support URIs.

```yml title="moon.yml"
tasks:
  build:
    # ...
    inputs:
      - 'file:///*.config.js?optional'
      - 'glob://src/**/*.ts'
```

:::info

Files and globs can still be configured using literal strings. The URI format can be used when
customizing parameters!

:::

#### Objects

Objects provide an alternative to strings, allowing you to customize parameters in a standard and
familiar format. Files can be specified using the [`file` key](/docs/config/project#file-paths), and
globs with the [`glob` key](/docs/config/project#glob-patterns). Environment variables do not
support objects.

```yml title="moon.yml"
tasks:
  build:
    # ...
    inputs:
      - file: '/*.config.js'
        optional: true
      - glob: 'src/**/*.ts'
```

### New parameters

As mentioned above, file and glob inputs now support parameters, which can be customized using URI
and object formats. The following parameters are available:

#### Files

- `content` (`string`) - When determining affected state, will match against the file's content
  using the defined regex pattern, instead of relying on file existence.
- `optional` (`boolean`) - When hashing and set to `true` and the file is missing, will not log a
  warning. When set to `false` and the file is missing, will fail with an error. Defaults to logging
  a warning.

#### Globs

- `cache` (`boolean`) - When gathering inputs for hashing, defines whether the glob results should
  be cached for the duration of the moon process. Defaults to `true`.

## Better proto integration

In previous versions of moon, we would automatically install [proto](/proto) for you based on
certain conditions. This logic was applied to all `moon` sub-commands, which was not necessary, as
it was only required for task running related commands.

To improve this, we have integrated proto into the action pipeline through a new action,
`SetupProto`, which runs before any `SetupToolchain` action. With this, proto is only installed when
required by that specific toolchain, and not for every command.

### New `proto` setting

Additionally, we are introducing a [`proto`](/docs/config/toolchain#proto) setting in
[`.moon/toolchain.yml`](/docs/config/toolchain), which can be used to control the integration of
proto in moon. To start, you can now customize the proto version! This is extremely useful if you
want to test new proto features, or need to rollback to an older version.

```yml title=".moon/toolchain.yml"
proto:
  version: '0.51.4'
```

### Other changes

Lastly, proto has been upgrade to [v0.51](https://github.com/moonrepo/proto/releases/tag/v0.51.0),
which includes 2 major features: lockfiles and custom registries. However, we have yet to test these
features thoroughly in moon, so they are not "officially" supported yet, but you can still use them
if you wish. We will be adding support for these features in the future.

## Project layers

Project layers may sound like a new feature, but they are simply a rename of the project type. Going
forward, the `type` setting in [`moon.yml`](/docs/config/project) has been renamed to
[`layer`](/docs/config/project#layer), but backwards compatibility will be maintained until v2. Why
the rename?

The term "layer" better reflects the purpose and functionality of this concept, as it defines a
layer (the [`layer`](/docs/config/project#layer) setting) within the development stack (the
[`stack`](/docs/config/project#stack) setting), and helps to enforce proper relationships. This
change aims to improve clarity and consistency in our configuration.

For example, the following layers are available, from highest to lowest. Layers can then depend on
lower layers, but not higher layers. Except for automations and applications, they can also depend
on themself.

| Layer           | Description                                                         |
| --------------- | ------------------------------------------------------------------- |
| `automation`    | An automated testing suite, like E2E, integration, or visual tests. |
| `application`   | An application of any kind.                                         |
| `tool`          | An internal tool, CLI, one-off script, etc.                         |
| `library`       | A self-contained, shareable, and publishable set of code.           |
| `scaffolding`   | Templates or generators for scaffolding.                            |
| `configuration` | Configuration files or infrastructure.                              |
| `unknown`       | When not configured.                                                |

Because of this rename, the following changes have been made:

- `type` --> `layer` in `moon.yml`
- `--type` --> `--layer` in `moon query projects`
- `projectType` --> `projectLayer` for MQL
- `$projectType` --> `$projectLayer` for task tokens
- `enforceProjectTypeRelationships` --> `enforceLayerRelationships` in `.moon/workspace.yml`

## Other changes

View the [official release](https://github.com/moonrepo/moon/releases/tag/v1.39.0) for a full list
of changes.

- Added unstable support for bubbling up logs from WASM plugins.
- Updated the `@moonrepo/cli` npm package to no longer rely on postinstall scripts.
- Improved argument quoting for commands and scripts.

## What's next?

With toolchains plugins being stabilized more, we'd like to focus on some other areas.

- Better command line argument parsing/joining (especially for task `args`)
- Pkl configuration improvements
- WASM toolchain documentation
