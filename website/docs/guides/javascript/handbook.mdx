---
title: Monorepo handbook
toc_max_heading_level: 6
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Utilizing JavaScript in a monorepo can be a daunting task, as there are many ways to structure your
code and to configure your tools. With this handbook, we'll help guide you through this process.

## moon setup

For this part of the handbook, we'll be focusing on [moon](/moon), our build system. To start,
languages in moon act like plugins, where their functionality and support _is not_ enabled unless
explicitly configured. We follow this approach to avoid unnecessary overhead.

### Enabling the language

To enable JavaScript support, define the [`node`](../../config/toolchain#node) setting in
[`.moon/toolchain.yml`](../../config/toolchain), even if an empty object.

```yaml title=".moon/toolchain.yml"
# Enable Node.js
node: {}

# Enable Node.js and override default settings
node:
	packageManager: 'pnpm'
```

This will enable the Node.js platform and provide the following automations around its ecosystem:

- Node modules will automatically be installed if dependencies in `package.json` have changed, or
  the lockfile has changed, since the last time a task has ran.
  - We'll also take `package.json` workspaces into account and install modules in the correct
    location; either the workspace root, in a project, or both.
- Relationships between projects will automatically be discovered based on `dependencies`,
  `devDependencies`, and `peerDependencies` in `package.json`.
  - The versions of these packages will also be automatically synced when changed.
- Tasks can be [automatically inferred](../../config/toolchain#infertasksfromscripts) from
  `package.json` scripts.
- And much more!

### Utilizing the toolchain

When a language is enabled, moon by default will assume that the language's binary is available
within the current environment (typically on `PATH`). This has the downside of requiring all
developers and machines to manually install the correct version of the language, _and to stay in
sync_.

Instead, you can utilize [moon's toolchain](../../concepts/toolchain), which will download and
install the language in the background, and ensure every task is executed using the exact version
across all machines.

Enabling the toolchain is as simple as defining the [`node.version`](../../config/toolchain#version)
setting.

```yaml title=".moon/toolchain.yml"
# Enable Node.js toolchain with an explicit version
node:
	version: '18.0.0'
```

### Using `package.json` names and scripts

If you're looking to prototype moon, or reduce the migration effort to moon tasks, you can configure
moon to inherit `package.json` scripts, and internally convert them to moon tasks. This can be
achieved with the [`node.inferTasksFromScripts`](../../config/toolchain#infertasksfromscripts)
setting.

```yaml title=".moon/toolchain.yml"
node:
	inferTasksFromScripts: true
```

Furthermore, if you'd like to reference projects by their package name (both in configuration and on
the command line), instead of the moon project name, enable the
[`node.aliasPackageNames`](../../config/toolchain#aliaspackagenames) setting.

```yaml title=".moon/toolchain.yml"
node:
	aliasPackageNames: 'name-and-scope'
```

> These are not enabled by default as we want to encourage the
> [use of moon tasks](../../faq#can-we-use-packagejson-scripts).

## Repository structure

JavaScript monorepo's work best when projects are split into applications and packages, with each
project containing its own `package.json` and dependencies. A root `package.json` must also exist
that pieces all projects together through workspaces.

For small repositories, the following structure typically works well:

```
/
├── .moon/
├── package.json
├── apps/
│   └── client/
|       ├── ...
│       └── package.json
│   └── server/
|       ├── ...
│       └── package.json
└── packages/
    ├── components/
    |   ├── ...
    │   └── package.json
    ├── theme/
    |   ├── ...
    │   └── package.json
    └── utils/
        ├── ...
        └── package.json
```

For large repositories, grouping projects by team or department helps with ownership and
organization. With this structure, applications and libraries can be nested at any depth.

```
/
├── .moon/
├── package.json
├── infra/
│   └── ...
├── internal/
│   └── ...
├── payments/
│   └── ...
└── shared/
    └── ...
```

### Applications

Applications are runnable or executable, like an HTTP server, and are pieced together with packages
and its own encapsulated code. They represent the whole, while packages are the pieces. Applications
can import and depend on packages, but they _must not_ import and depend on other applications.

In moon, you can denote a project as an application using the [`type`](../../config/project#type)
setting in [`moon.yml`](../../config/project).

```yaml title="moon.yml"
type: 'application'
```

### Packages

Packages (also known as a libraries) are self-contained reusable pieces of code, and are the
suggested pattern for [code sharing](#code-sharing). Packages can import and depend on other
packages, but they _must not_ import and depend on applications!

In moon, you can denote a project as a library using the [`type`](../../config/project#type) setting
in [`moon.yml`](../../config/project).

```yaml title="moon.yml"
type: 'library'
```

### Configuration

Every tool that you'll utilize in a repository will have its own configuration file. This will be a
lot of config files, but regardless of what tool it is, where the config file should go will fall
into 1 of these categories:

- **Settings are inherited by all projects.** These are known as universal tools, and enforce code
  consistency and quality across the entire repository. Their config file must exist in the
  repository root, but may support overrides in each project.
  - Examples: Babel, [ESLint](../examples/eslint), [Prettier](../examples/prettier),
    [TypeScript](../examples/typescript)
- **Settings are unique per project.** These are developers tools that must be configured separately
  for each project, as they'll have different concerns. Their config file must exist in each
  project, but a shared configuration may exist as a base (for example, Jest presets).
  - Examples: [Jest](../examples/jest), [TypeScript](../examples/typescript) (with project
    references)
- **Settings are one-offs.** These are typically for applications or tools that require their own
  config, but aren't prevalent throughout the entire repository.
  - Examples: [Astro](../examples/astro), [Next](../examples/next), [Nuxt](../examples/nuxt),
    [Remix](../examples/remix), Tailwind

## Dependency management

Dependencies, also known as node modules, are required by all projects, and are installed through a
package manager like npm, pnpm, or yarn. It doesn't matter which package manager you choose, but we
highly suggest choosing one that has proper workspaces support.

Package workspaces is a concept that resolves all `package.json`s in a repository using glob
patterns, and installs all dependencies within the tree at once. It also creates symlinks in
`node_modules` of local packages, enabling code sharing, and deduplicates and hoists packages to the
root when applicable.

Workspaces can be enabled with the following:

import PackageWorkspaces from '../../__partials__/node/package-workspaces.mdx';

<PackageWorkspaces />

:::caution

Package workspaces are not a requirement for monorepos, but they do solve an array of problems
around module resolution, avoiding duplicate packages in bundles, and general interoperability.
Proceed with caution for non-workspaces setups!

:::

### Workspace commands

The following common commands can be used for adding, removing, or managing dependencies in a
workspace. View the package manager's official documentation for a thorough list of commands.

<Tabs
  groupId="package-manager"
  defaultValue="yarn"
  values={[
    { label: 'npm', value: 'npm' },
    { label: 'pnpm', value: 'pnpm' },
    { label: 'Yarn', value: 'yarn' },
    { label: 'Yarn (classic)', value: 'yarn1' },
  ]}
>
<TabItem value="npm">

Install dependencies:

```shell
npm install
```

Add a package:

```shell
# At the root
npm install <dependency>

# In a project
npm install <dependency> --workspace <project>
```

Remove a package:

```shell
# At the root
npm install <dependency>

# In a project
npm install <dependency> --workspace <project>
```

Update packages:

```shell
npx npm-check-updates --interactive
```

</TabItem>
<TabItem value="pnpm">

Install dependencies:

```shell
pnpm install
```

Add a package:

```shell
# At the root
pnpm add <dependency>

# In a project
pnpm add <dependency> --filter <project>
```

Remove a package:

```shell
# At the root
pnpm remove <dependency>

# In a project
pnpm remove <dependency> --filter <project>
```

Update packages:

```shell
pnpm update -i -r --latest
```

</TabItem>
<TabItem value="yarn">

Install dependencies:

```shell
yarn install
```

Add a package:

```shell
# At the root
yarn add <dependency>

# In a project
yarn workspace <project> add <dependency>
```

Remove a package:

```shell
# At the root
yarn remove <dependency>

# In a project
yarn workspace <project> remove <dependency>
```

Update packages:

```shell
yarn upgrade-interactive
```

</TabItem>
<TabItem value="yarn1">

Install dependencies:

```shell
yarn install
```

Add a package:

```shell
# At the root
yarn add <dependency> -w

# In a project
yarn workspace <project> add <dependency>
```

Remove a package:

```shell
# At the root
yarn remove <dependency> -w

# In a project
yarn workspace <project> remove <dependency>
```

Update packages:

```shell
yarn upgrade-interactive --latest
```

</TabItem>
</Tabs>

### Developer tools at the root

While not a strict guideline to follow, we've found that installing universal developer tool related
dependencies (Babel, ESLint, Jest, TypeScript, etc) in the root `package.json` as `devDependencies`
to be a good pattern for consistency, quality, and the health of the repository. It provides the
following benefits:

- It ensures all projects are utilizing the same version (and sometimes configuration) of a tool.
- It allows the tool to easily be upgraded. Upgrade once, applied everywhere.
- It avoids conflicting or outdated versions of the same package.

With that being said, this _does not_ include development dependencies that are unique to a project!

### Product libraries in a project

Product, application, and or framework specific packages should be installed as production
`dependencies` in a project's `package.json`. We've found this pattern to work well for the
following reasons:

- Application dependencies are pinned per project, avoiding accidental regressions.
- Applications can upgrade their dependencies and avoid breaking neighbor applications.

## Code sharing

### Internal packages

### External packages

### Bundler integration
